!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in p||(p[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==v.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=p[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(v.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=p[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return x[e]||(x[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},r.name);t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=p[s],v=x[s];v?l=v.exports:c&&!c.declarative?l=c.esModule:c?(d(c),v=c.module,l=v.exports):l=f(s),v&&v.importers?(v.importers.push(t),t.dependencies.push(v)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=p[e];if(t)t.declarative?c(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=f(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=p[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){if(r===e)return r;var t={};if("object"==typeof r||"function"==typeof r)if(g){var n;for(var o in r)(n=Object.getOwnPropertyDescriptor(r,o))&&h(t,o,n)}else{var a=r&&r.hasOwnProperty;for(var o in r)(!a||r.hasOwnProperty(o))&&(t[o]=r[o])}return t["default"]=r,h(t,"__useDefault",{value:!0}),t}function c(r,t){var n=p[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==v.call(t,u)&&(p[u]?c(u,t):f(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function f(e){if(D[e])return D[e];if("@node/"==e.substr(0,6))return y(e.substr(6));var r=p[e];if(!r)throw"Module "+e+" not present.";return a(e),c(e,[]),p[e]=void 0,r.declarative&&h(r.module.exports,"__esModule",{value:!0}),D[e]=r.declarative?r.module.exports:r.esModule}var p={},v=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},g=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(m){g=!1}var h;!function(){try{Object.defineProperty({},"a",{})&&(h=Object.defineProperty)}catch(e){h=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var x={},y="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&require,D={"@empty":{}};return function(e,n,o){return function(a){a(function(a){for(var u={_nodeRequire:y,register:r,registerDynamic:t,get:f,set:function(e,r){D[e]=r},newModule:function(e){return e}},d=0;d<n.length;d++)(function(e,r){r&&r.__esModule?D[e]=r:D[e]=s(r)})(n[d],arguments[d]);o(u);var i=f(e[0]);if(e.length>1)for(var d=1;d<e.length;d++)f(e[d]);return i.__useDefault?i["default"]:i})}}}("undefined"!=typeof self?self:global)

(["1","1"], [], function($__System) {

!function(e){function r(e,r){for(var n=e.split(".");n.length;)r=r[n.shift()];return r}function n(n){if("string"==typeof n)return r(n,e);if(!(n instanceof Array))throw new Error("Global exports must be a string or array.");for(var t={},o=!0,f=0;f<n.length;f++){var i=r(n[f],e);o&&(t["default"]=i,o=!1),t[n[f].split(".").pop()]=i}return t}function t(r){if(Object.keys)Object.keys(e).forEach(r);else for(var n in e)a.call(e,n)&&r(n)}function o(r){t(function(n){if(-1==l.call(s,n)){try{var t=e[n]}catch(o){s.push(n)}r(n,t)}})}var f,i=$__System,a=Object.prototype.hasOwnProperty,l=Array.prototype.indexOf||function(e){for(var r=0,n=this.length;n>r;r++)if(this[r]===e)return r;return-1},s=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB","mozInnerScreenY","mozInnerScreenX"];i.set("@@global-helpers",i.newModule({prepareGlobal:function(r,t,i){var a=e.define;e.define=void 0;var l;if(i){l={};for(var s in i)l[s]=e[s],e[s]=i[s]}return t||(f={},o(function(e,r){f[e]=r})),function(){var r;if(t)r=n(t);else{r={};var i,s;o(function(e,n){f[e]!==n&&"undefined"!=typeof n&&(r[e]=n,"undefined"!=typeof i?s||i===n||(s=!0):i=n)}),r=s?r:i}if(l)for(var u in l)e[u]=l[u];return e.define=a,r}}}))}("undefined"!=typeof self?self:global);
!function(e){function n(e,n){e=e.replace(l,"");var r=e.match(u),t=(r[1].split(",")[n]||"require").replace(s,""),i=p[t]||(p[t]=new RegExp(a+t+f,"g"));i.lastIndex=0;for(var o,c=[];o=i.exec(e);)c.push(o[2]||o[3]);return c}function r(e,n,t,o){if("object"==typeof e&&!(e instanceof Array))return r.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof n&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var l=i.get(e);return l.__useDefault?l["default"]:l}throw new TypeError("Invalid require")}for(var a=[],f=0;f<e.length;f++)a.push(i["import"](e[f],o));Promise.all(a).then(function(e){n&&n.apply(null,e)},t)}function t(t,l,a){"string"!=typeof t&&(a=l,l=t,t=null),l instanceof Array||(a=l,l=["require","exports","module"].splice(0,a.length)),"function"!=typeof a&&(a=function(e){return function(){return e}}(a)),void 0===l[l.length-1]&&l.pop();var f,u,s;-1!=(f=o.call(l,"require"))&&(l.splice(f,1),t||(l=l.concat(n(a.toString(),f)))),-1!=(u=o.call(l,"exports"))&&l.splice(u,1),-1!=(s=o.call(l,"module"))&&l.splice(s,1);var p={name:t,deps:l,execute:function(n,t,o){for(var p=[],c=0;c<l.length;c++)p.push(n(l[c]));o.uri=o.id,o.config=function(){},-1!=s&&p.splice(s,0,o),-1!=u&&p.splice(u,0,t),-1!=f&&p.splice(f,0,function(e,t,l){return"string"==typeof e&&"function"!=typeof t?n(e):r.call(i,e,t,l,o.id)});var d=a.apply(-1==u?e:t,p);return"undefined"==typeof d&&o&&(d=o.exports),"undefined"!=typeof d?d:void 0}};if(t)c.anonDefine||c.isBundle?c.anonDefine&&c.anonDefine.name&&(c.anonDefine=null):c.anonDefine=p,c.isBundle=!0,i.registerDynamic(p.name,p.deps,!1,p.execute);else{if(c.anonDefine&&!c.anonDefine.name)throw new Error("Multiple anonymous defines in module "+t);c.anonDefine=p}}var i=$__System,o=Array.prototype.indexOf||function(e){for(var n=0,r=this.length;r>n;n++)if(this[n]===e)return n;return-1},l=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,a="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",f="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",u=/\(([^\)]*)\)/,s=/^\s+|\s+$/g,p={};t.amd={};var c={isBundle:!1,anonDefine:null};i.amdDefine=t,i.amdRequire=r}("undefined"!=typeof self?self:global);
$__System.registerDynamic("2", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var IO;
  IO = (function() {
    function IO(other) {
      if ((other instanceof IO) || (typeof other === 'object' && (other.x != null) && (other.y != null) && (other.z != null) && (other.voxels != null))) {
        this.voxels = other.voxels;
        this.x = other.x;
        this.y = other.y;
        this.z = other.z;
        if (other.readonly) {
          this.readonly = true;
        }
        return true;
      }
    }
    IO.prototype.verify = function() {
      var i,
          j,
          k,
          len,
          len1,
          len2,
          ref,
          ref1,
          ref2,
          ref3,
          ref4,
          ref5,
          ref6,
          x,
          y,
          z;
      if (!((this.x != null) && (this.y != null) && (this.z != null) && (this.voxels != null))) {
        return false;
      }
      if (!(this.x > 0 && this.y > 0 && this.z > 0 && Array.isArray(this.voxels))) {
        return false;
      }
      if (this.voxels.length > this.z) {
        return false;
      }
      ref = this.voxels;
      for (i = 0, len = ref.length; i < len; i++) {
        z = ref[i];
        if (!Array.isArray(z) || z.length > this.y) {
          return false;
        }
        for (j = 0, len1 = z.length; j < len1; j++) {
          y = z[j];
          if (!Array.isArray(y) || y.length > this.x) {
            return false;
          }
          for (k = 0, len2 = y.length; k < len2; k++) {
            x = y[k];
            if (typeof x !== 'object') {
              return false;
            }
            if (!(typeof x.r === 'number' && (0 <= (ref1 = x.r) && ref1 <= 255))) {
              return false;
            }
            if (!(typeof x.g === 'number' && (0 <= (ref2 = x.g) && ref2 <= 255))) {
              return false;
            }
            if (!(typeof x.b === 'number' && (0 <= (ref3 = x.b) && ref3 <= 255))) {
              return false;
            }
            if (x.r === 255 && x.g === 0 && (x.b = 255)) {
              if (!(typeof x.a === 'number' && x.a === 250)) {
                return false;
              }
              if (!(typeof x.t === 'number' && x.t === 7)) {
                return false;
              }
              if (!(typeof x.s === 'number' && x.s === 7)) {
                return false;
              }
            } else {
              if (!(typeof x.a === 'number' && ((ref4 = x.a) === 16 || ref4 === 48 || ref4 === 80 || ref4 === 112 || ref4 === 144 || ref4 === 176 || ref4 === 208 || ref4 === 240 || ref4 === 255))) {
                return false;
              }
              if (!(typeof x.t === 'number' && (0 <= (ref5 = x.t) && ref5 <= 4))) {
                return false;
              }
              if (!(typeof x.s === 'number' && (0 <= (ref6 = x.s) && ref6 <= 4))) {
                return false;
              }
            }
          }
        }
      }
      return true;
    };
    IO.prototype.rotateX = function(d) {
      var i,
          j,
          k,
          ref,
          ref1,
          ref2,
          ref3,
          ref4,
          ref5,
          voxels,
          x,
          y,
          z;
      voxels = this.voxels.slice(0);
      this.voxels = [];
      for (z = i = 0, ref = this.z; i < ref; z = i += 1) {
        for (y = j = 0, ref1 = this.y; j < ref1; y = j += 1) {
          for (x = k = 0, ref2 = this.x; k < ref2; x = k += 1) {
            if (!(((ref3 = voxels[d ? this.z - z - 1 : z]) != null ? (ref4 = ref3[d ? y : this.y - y - 1]) != null ? ref4[x] : void 0 : void 0) != null)) {
              continue;
            }
            if (this.voxels[y] == null) {
              this.voxels[y] = [];
            }
            if (this.voxels[y][z] == null) {
              this.voxels[y][z] = [];
            }
            this.voxels[y][z][x] = voxels[d ? this.z - z - 1 : z][d ? y : this.y - y - 1][x];
          }
        }
      }
      return ref5 = [this.y, this.z], this.z = ref5[0], this.y = ref5[1], ref5;
    };
    IO.prototype.rotateY = function(d) {
      var i,
          j,
          k,
          ref,
          ref1,
          ref2,
          ref3,
          ref4,
          ref5,
          voxels,
          x,
          y,
          z;
      voxels = this.voxels.slice(0);
      this.voxels = [];
      for (z = i = 0, ref = this.z; i < ref; z = i += 1) {
        for (y = j = 0, ref1 = this.y; j < ref1; y = j += 1) {
          for (x = k = 0, ref2 = this.x; k < ref2; x = k += 1) {
            if (!(((ref3 = voxels[d ? this.z - z - 1 : z]) != null ? (ref4 = ref3[y]) != null ? ref4[d ? x : this.x - x - 1] : void 0 : void 0) != null)) {
              continue;
            }
            if (this.voxels[x] == null) {
              this.voxels[x] = [];
            }
            if (this.voxels[x][y] == null) {
              this.voxels[x][y] = [];
            }
            this.voxels[x][y][z] = voxels[d ? this.z - z - 1 : z][y][d ? x : this.x - x - 1];
          }
        }
      }
      return ref5 = [this.x, this.z], this.z = ref5[0], this.x = ref5[1], ref5;
    };
    IO.prototype.rotateZ = function(d) {
      var i,
          j,
          k,
          ref,
          ref1,
          ref2,
          ref3,
          ref4,
          ref5,
          voxels,
          x,
          y,
          z;
      voxels = this.voxels.slice(0);
      this.voxels = [];
      for (z = i = 0, ref = this.z; i < ref; z = i += 1) {
        for (y = j = 0, ref1 = this.y; j < ref1; y = j += 1) {
          for (x = k = 0, ref2 = this.x; k < ref2; x = k += 1) {
            if (!(((ref3 = voxels[z]) != null ? (ref4 = ref3[d ? y : this.y - y - 1]) != null ? ref4[d ? this.x - x - 1 : x] : void 0 : void 0) != null)) {
              continue;
            }
            if (this.voxels[z] == null) {
              this.voxels[z] = [];
            }
            if (this.voxels[z][x] == null) {
              this.voxels[z][x] = [];
            }
            this.voxels[z][x][y] = voxels[z][d ? y : this.y - y - 1][d ? this.x - x - 1 : x];
          }
        }
      }
      return ref5 = [this.x, this.y], this.y = ref5[0], this.x = ref5[1], ref5;
    };
    IO.prototype.mirrorX = function() {
      var i,
          ref,
          results,
          voxels,
          x,
          y,
          z;
      voxels = this.voxels.slice(0);
      this.voxels = [];
      results = [];
      for (z = i = 0, ref = this.z; i < ref; z = i += 1) {
        results.push((function() {
          var j,
              ref1,
              results1;
          results1 = [];
          for (y = j = 0, ref1 = this.y; j < ref1; y = j += 1) {
            results1.push((function() {
              var k,
                  ref2,
                  ref3,
                  ref4,
                  results2;
              results2 = [];
              for (x = k = 0, ref2 = this.x; k < ref2; x = k += 1) {
                if (!(((ref3 = voxels[z]) != null ? (ref4 = ref3[y]) != null ? ref4[this.x - x - 1] : void 0 : void 0) != null)) {
                  continue;
                }
                if (this.voxels[z] == null) {
                  this.voxels[z] = [];
                }
                if (this.voxels[z][y] == null) {
                  this.voxels[z][y] = [];
                }
                results2.push(this.voxels[z][y][x] = voxels[z][y][this.x - x - 1]);
              }
              return results2;
            }).call(this));
          }
          return results1;
        }).call(this));
      }
      return results;
    };
    IO.prototype.mirrorY = function() {
      var i,
          ref,
          results,
          voxels,
          x,
          y,
          z;
      voxels = this.voxels.slice(0);
      this.voxels = [];
      results = [];
      for (z = i = 0, ref = this.z; i < ref; z = i += 1) {
        results.push((function() {
          var j,
              ref1,
              results1;
          results1 = [];
          for (y = j = 0, ref1 = this.y; j < ref1; y = j += 1) {
            results1.push((function() {
              var k,
                  ref2,
                  ref3,
                  ref4,
                  results2;
              results2 = [];
              for (x = k = 0, ref2 = this.x; k < ref2; x = k += 1) {
                if (!(((ref3 = voxels[z]) != null ? (ref4 = ref3[this.y - y - 1]) != null ? ref4[x] : void 0 : void 0) != null)) {
                  continue;
                }
                if (this.voxels[z] == null) {
                  this.voxels[z] = [];
                }
                if (this.voxels[z][y] == null) {
                  this.voxels[z][y] = [];
                }
                results2.push(this.voxels[z][y][x] = voxels[z][this.y - y - 1][x]);
              }
              return results2;
            }).call(this));
          }
          return results1;
        }).call(this));
      }
      return results;
    };
    IO.prototype.mirrorZ = function() {
      var i,
          ref,
          results,
          voxels,
          x,
          y,
          z;
      voxels = this.voxels.slice(0);
      this.voxels = [];
      results = [];
      for (z = i = 0, ref = this.z; i < ref; z = i += 1) {
        results.push((function() {
          var j,
              ref1,
              results1;
          results1 = [];
          for (y = j = 0, ref1 = this.y; j < ref1; y = j += 1) {
            results1.push((function() {
              var k,
                  ref2,
                  ref3,
                  ref4,
                  results2;
              results2 = [];
              for (x = k = 0, ref2 = this.x; k < ref2; x = k += 1) {
                if (!(((ref3 = voxels[this.z - z - 1]) != null ? (ref4 = ref3[y]) != null ? ref4[x] : void 0 : void 0) != null)) {
                  continue;
                }
                if (this.voxels[z] == null) {
                  this.voxels[z] = [];
                }
                if (this.voxels[z][y] == null) {
                  this.voxels[z][y] = [];
                }
                results2.push(this.voxels[z][y][x] = voxels[this.z - z - 1][y][x]);
              }
              return results2;
            }).call(this));
          }
          return results1;
        }).call(this));
      }
      return results;
    };
    IO.prototype.moveX = function(d) {
      var i,
          ref,
          results,
          x,
          x0,
          y,
          z;
      results = [];
      for (z = i = 0, ref = this.z; i < ref; z = i += 1) {
        if (this.voxels[z] != null) {
          results.push((function() {
            var j,
                k,
                ref1,
                ref2,
                ref3,
                ref4,
                ref5,
                results1;
            results1 = [];
            for (y = j = 0, ref1 = this.y; j < ref1; y = j += 1) {
              if (!(((ref2 = this.voxels[z]) != null ? ref2[y] : void 0) != null)) {
                continue;
              }
              x0 = this.voxels[z][y][d ? 0 : this.x - 1];
              for (x = k = 0, ref3 = this.x - 1; k < ref3; x = k += 1) {
                if (((ref4 = this.voxels[z]) != null ? (ref5 = ref4[y]) != null ? ref5[d ? x + 1 : this.x - 2 - x] : void 0 : void 0) != null) {
                  this.voxels[z][y][d ? x : this.x - 1 - x] = this.voxels[z][y][d ? x + 1 : this.x - 2 - x];
                } else {
                  delete this.voxels[z][y][d ? x : this.x - 1 - x];
                }
              }
              if (x0 != null) {
                results1.push(this.voxels[z][y][d ? this.x - 1 : 0] = x0);
              } else {
                results1.push(delete this.voxels[z][y][d ? this.x - 1 : 0]);
              }
            }
            return results1;
          }).call(this));
        }
      }
      return results;
    };
    IO.prototype.moveY = function(d) {
      var i,
          j,
          ref,
          ref1,
          ref2,
          results,
          y,
          y0,
          z;
      results = [];
      for (z = i = 0, ref = this.z; i < ref; z = i += 1) {
        if (!(this.voxels[z] != null)) {
          continue;
        }
        y0 = this.voxels[z][d ? 0 : this.y - 1];
        for (y = j = 0, ref1 = this.y - 1; j < ref1; y = j += 1) {
          if (((ref2 = this.voxels[z]) != null ? ref2[d ? y + 1 : this.y - 2 - y] : void 0) != null) {
            this.voxels[z][d ? y : this.y - 1 - y] = this.voxels[z][d ? y + 1 : this.y - 2 - y];
          } else {
            delete this.voxels[z][d ? y : this.y - 1 - y];
          }
        }
        if (y0 != null) {
          results.push(this.voxels[z][d ? this.y - 1 : 0] = y0);
        } else {
          results.push(delete this.voxels[z][d ? this.y - 1 : 0]);
        }
      }
      return results;
    };
    IO.prototype.moveZ = function(d) {
      var i,
          ref,
          z,
          z0;
      z0 = this.voxels[d ? 0 : this.z - 1];
      for (z = i = 0, ref = this.z - 1; i < ref; z = i += 1) {
        if (this.voxels[d ? z + 1 : this.z - 2 - z] != null) {
          this.voxels[d ? z : this.z - 1 - z] = this.voxels[d ? z + 1 : this.z - 2 - z];
        } else {
          delete this.voxels[d ? z : this.z - 1 - z];
        }
      }
      if (z0 != null) {
        return this.voxels[d ? this.z - 1 : 0] = z0;
      } else {
        return delete this.voxels[d ? this.z - 1 : 0];
      }
    };
    IO.prototype.resize = function(x1, y1, z1, ox, oy, oz) {
      var i,
          ref,
          results,
          y,
          z;
      this.x = x1;
      this.y = y1;
      this.z = z1;
      if (oz >= 0) {
        this.voxels = this.voxels.slice(oz, this.z + oz);
      } else {
        this.voxels.unshift.apply(this.voxels, Array(-oz));
        this.voxels = this.voxels.slice(0, this.z);
      }
      results = [];
      for (z = i = 0, ref = this.z; i < ref; z = i += 1) {
        if (!(this.voxels[z] != null)) {
          continue;
        }
        if (oy >= 0) {
          this.voxels[z] = this.voxels[z].slice(oy, this.y + oy);
        } else {
          this.voxels[z].unshift.apply(this.voxels[z], Array(-oy));
          this.voxels[z] = this.voxels[z].slice(0, this.y);
        }
        results.push((function() {
          var j,
              ref1,
              results1;
          results1 = [];
          for (y = j = 0, ref1 = this.y; j < ref1; y = j += 1) {
            if (this.voxels[z][y] != null) {
              if (ox >= 0) {
                results1.push(this.voxels[z][y] = this.voxels[z][y].slice(ox, this.x + ox));
              } else {
                this.voxels[z][y].unshift.apply(this.voxels[z][y], Array(-ox));
                results1.push(this.voxels[z][y] = this.voxels[z][y].slice(0, this.x));
              }
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    };
    IO.prototype.computeBoundingBox = function() {
      var i,
          j,
          k,
          maxX,
          maxY,
          maxZ,
          minX,
          minY,
          minZ,
          ref,
          ref1,
          ref2,
          x,
          y,
          z;
      maxX = maxY = maxZ = 0;
      minX = this.x - 1;
      minY = this.y - 1;
      minZ = this.z - 1;
      for (z = i = 0, ref = this.z; i < ref; z = i += 1) {
        if (!(this.voxels[z] != null)) {
          continue;
        }
        minZ = Math.min(minZ, z);
        maxZ = Math.max(maxZ, z);
        for (y = j = 0, ref1 = this.y; j < ref1; y = j += 1) {
          if (!(this.voxels[z][y] != null)) {
            continue;
          }
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
          for (x = k = 0, ref2 = this.x; k < ref2; x = k += 1) {
            if (!(this.voxels[z][y][x] != null)) {
              continue;
            }
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
          }
        }
      }
      if (maxX === 0) {
        return [this.x, this.y, this.z, 0, 0, 0];
      }
      return [maxX - minX + 1, maxY - minY + 1, maxZ - minZ + 1, minX, minY, minZ];
    };
    IO.prototype.getAttachmentPoint = function() {
      var i,
          j,
          k,
          ref,
          ref1,
          ref2,
          x,
          y,
          z;
      for (z = i = 0, ref = this.z; i < ref; z = i += 1) {
        if (this.voxels[z] != null) {
          for (y = j = 0, ref1 = this.y; j < ref1; y = j += 1) {
            if (this.voxels[z][y] != null) {
              for (x = k = 0, ref2 = this.x; k < ref2; x = k += 1) {
                if ((this.voxels[z][y][x] != null) && this.voxels[z][y][x].t === 7) {
                  return [x, y, z];
                }
              }
            }
          }
        }
      }
      return [0, 0, 0];
    };
    IO.prototype.merge = function(mio, offsets, relativeAP) {
      var apx,
          apy,
          apz,
          i,
          j,
          k,
          ref,
          ref1,
          ref2,
          ref3,
          ref4,
          ref5,
          ref6,
          rx,
          ry,
          rz,
          x,
          y,
          z;
      if (offsets == null) {
        offsets = {
          x: 0,
          y: 0,
          z: 0
        };
      }
      if (!((mio.x != null) && (mio.y != null) && (mio.z != null) && (mio.voxels != null))) {
        return;
      }
      if (mio.readonly) {
        this.readonly = true;
      }
      if (relativeAP) {
        ref = mio.getAttachmentPoint(), apx = ref[0], apy = ref[1], apz = ref[2];
        offsets.x -= apx;
        offsets.y -= apy;
        offsets.z -= apz;
      }
      if (offsets.x < 0 || offsets.y < 0 || offsets.z < 0) {
        rx = Math.min(0, offsets.x);
        ry = Math.min(0, offsets.y);
        rz = Math.min(0, offsets.z);
        this.resize(this.x - rx, this.y - ry, this.z - rz, rx, ry, rz);
        offsets.x = Math.max(0, offsets.x);
        offsets.y = Math.max(0, offsets.y);
        offsets.z = Math.max(0, offsets.z);
      }
      this.x = Math.max(this.x, mio.x + offsets.x);
      this.y = Math.max(this.y, mio.y + offsets.y);
      this.z = Math.max(this.z, mio.z + offsets.z);
      for (z = i = ref1 = offsets.z, ref2 = this.z; i < ref2; z = i += 1) {
        if (!(mio.voxels[z - offsets.z] != null)) {
          continue;
        }
        if (this.voxels[z] == null) {
          this.voxels[z] = [];
        }
        for (y = j = ref3 = offsets.y, ref4 = this.y; j < ref4; y = j += 1) {
          if (!(mio.voxels[z - offsets.z][y - offsets.y] != null)) {
            continue;
          }
          if (this.voxels[z][y] == null) {
            this.voxels[z][y] = [];
          }
          for (x = k = ref5 = offsets.x, ref6 = this.x; k < ref6; x = k += 1) {
            if (mio.voxels[z - offsets.z][y - offsets.y][x - offsets.x] != null) {
              this.voxels[z][y][x] = mio.voxels[z - offsets.z][y - offsets.y][x - offsets.x];
            }
          }
        }
      }
    };
    return IO;
  })();
  module.exports = IO;
  return module.exports;
});

$__System.registerDynamic("3", ["2"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var Base64IO,
      JsonIO,
      extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty,
      slice = [].slice;
  Base64IO = (function(superClass) {
    extend(Base64IO, superClass);
    function Base64IO(base64) {
      var _,
          d,
          data,
          i,
          index,
          j,
          k,
          l,
          m,
          n,
          o,
          p,
          palette,
          paletteSize,
          q,
          r,
          ref,
          ref1,
          ref2,
          ref3,
          ref4,
          ref5,
          ref6,
          short,
          vox,
          x,
          x1,
          x2,
          x3,
          x4,
          y,
          y1,
          y2,
          y3,
          y4,
          z,
          z1,
          z2,
          z3,
          z4;
      if (Base64IO.__super__.constructor.call(this, base64)) {
        return;
      }
      this.voxels = [];
      d = atob(base64).split('').map(function(c) {
        return c.charCodeAt(0);
      });
      if (d[0] === 0) {
        _ = d[0], x1 = d[1], x2 = d[2], x3 = d[3], x4 = d[4], y1 = d[5], y2 = d[6], y3 = d[7], y4 = d[8], z1 = d[9], z2 = d[10], z3 = d[11], z4 = d[12], this.readonly = d[13], data = 15 <= d.length ? slice.call(d, 14) : [];
        this.x = new Uint32Array(new Uint8Array([x1, x2, x3, x4]).buffer)[0];
        this.y = new Uint32Array(new Uint8Array([y1, y2, y3, y4]).buffer)[0];
        this.z = new Uint32Array(new Uint8Array([z1, z2, z3, z4]).buffer)[0];
      } else {
        this.x = d[0], this.y = d[1], this.z = d[2], this.readonly = d[3], data = 5 <= d.length ? slice.call(d, 4) : [];
      }
      i = r = 0;
      vox = {};
      if (data[0] === 85) {
        paletteSize = 256 * data[1] + data[2];
        short = data[1] === 0 && data[2] < 128 ? 1 : 2;
        palette = [null];
        for (j = k = 3, ref = paletteSize * 5 + 3; k < ref; j = k += 5) {
          palette.push({
            r: data[j + 1],
            g: data[j + 2],
            b: data[j + 3],
            a: data[j + 4],
            s: data[j] % 16,
            t: data[j] >> 4
          });
        }
        i = paletteSize * 5 + 3;
        for (z = l = 0, ref1 = this.z; l < ref1; z = l += 1) {
          for (y = m = 0, ref2 = this.y; m < ref2; y = m += 1) {
            for (x = n = 0, ref3 = this.x; n < ref3; x = n += 1) {
              if (r === 0) {
                if (data[i] > 127) {
                  r = data[i] - 126;
                  i++;
                } else {
                  r = 1;
                }
                if (short === 1) {
                  index = data[i];
                } else {
                  index = data[i] * 256 + data[i + 1];
                }
                if (index !== 0) {
                  vox = palette[index];
                } else {
                  vox = null;
                }
                i += short;
              }
              if (vox != null) {
                if (this.voxels[z] == null) {
                  this.voxels[z] = [];
                }
                if (this.voxels[z][y] == null) {
                  this.voxels[z][y] = [];
                }
                this.voxels[z][y][x] = {
                  r: vox.r,
                  g: vox.g,
                  b: vox.b,
                  a: vox.a,
                  s: vox.s,
                  t: vox.t
                };
              }
              r--;
            }
          }
        }
      } else {
        for (z = o = 0, ref4 = this.z; o < ref4; z = o += 1) {
          for (y = p = 0, ref5 = this.y; p < ref5; y = p += 1) {
            for (x = q = 0, ref6 = this.x; q < ref6; x = q += 1) {
              if (r === 0) {
                if (data[i] > 127) {
                  r = data[i] - 127;
                  i++;
                } else {
                  r = 1;
                }
                if (data[i] > 127) {
                  throw new Error("Base64 parsing error");
                }
                if (data[i] < 64) {
                  vox = {
                    r: data[i + 1],
                    g: data[i + 2],
                    b: data[i + 3],
                    a: data[i + 4],
                    s: data[i] % 8,
                    t: data[i] >> 3
                  };
                  i += 5;
                } else {
                  vox = null;
                  i++;
                }
              }
              if (vox != null) {
                if (this.voxels[z] == null) {
                  this.voxels[z] = [];
                }
                if (this.voxels[z][y] == null) {
                  this.voxels[z][y] = [];
                }
                this.voxels[z][y][x] = {
                  r: vox.r,
                  g: vox.g,
                  b: vox.b,
                  a: vox.a,
                  s: vox.s,
                  t: vox.t
                };
              }
              r--;
            }
          }
        }
      }
      if (i !== data.length) {
        console.warn("There shouldn't be any bytes left");
      }
      if (!this.readonly) {
        console.log("voxels:");
      }
      if (!this.readonly) {
        console.log(this.voxels);
      }
    }
    Base64IO.prototype["export"] = function(readonly, version) {
      var data,
          equal,
          hex,
          i,
          index,
          k,
          l,
          len,
          m,
          mat,
          n,
          r,
          rcolors,
          ref,
          ref1,
          ref2,
          ref3,
          ref4,
          ref5,
          ref6,
          ref7,
          ref8,
          short,
          v,
          vox,
          x,
          x1,
          x2,
          x3,
          x4,
          y,
          y1,
          y2,
          y3,
          y4,
          z,
          z1,
          z2,
          z3,
          z4;
      if (version == null) {
        version = 1;
      }
      if (this.readonly) {
        readonly = true;
      }
      equal = function(a, b, index) {
        var i,
            k,
            len,
            ref;
        if (!(index < vox.length)) {
          return false;
        }
        if ((a == null) && (b == null)) {
          return true;
        }
        if ((a == null) || (b == null)) {
          return false;
        }
        ref = ['r', 'g', 'b', 'a', 't', 's'];
        for (k = 0, len = ref.length; k < len; k++) {
          i = ref[k];
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      };
      if (this.x > 255 || this.y > 255 || this.z > 255) {
        ref = new Uint8Array(new Uint32Array([this.x]).buffer), x1 = ref[0], x2 = ref[1], x3 = ref[2], x4 = ref[3];
        ref1 = new Uint8Array(new Uint32Array([this.y]).buffer), y1 = ref1[0], y2 = ref1[1], y3 = ref1[2], y4 = ref1[3];
        ref2 = new Uint8Array(new Uint32Array([this.z]).buffer), z1 = ref2[0], z2 = ref2[1], z3 = ref2[2], z4 = ref2[3];
        data = [0, x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4, readonly ? 1 : 0];
      } else {
        data = [this.x, this.y, this.z, readonly ? 1 : 0];
      }
      vox = [];
      for (z = k = 0, ref3 = this.z; k < ref3; z = k += 1) {
        for (y = l = 0, ref4 = this.y; l < ref4; y = l += 1) {
          for (x = m = 0, ref5 = this.x; m < ref5; x = m += 1) {
            vox.push((ref6 = this.voxels[z]) != null ? (ref7 = ref6[y]) != null ? ref7[x] : void 0 : void 0);
          }
        }
      }
      i = 0;
      if (version === 1) {
        while (i < vox.length) {
          r = 1;
          while (r < 128) {
            if (equal(vox[i + r - 1], vox[i + r], i + r)) {
              r++;
            } else {
              break;
            }
          }
          if (r > 1) {
            data.push(127 + r);
          }
          if (vox[i] != null) {
            data.push(8 * vox[i].t + vox[i].s, vox[i].r, vox[i].g, vox[i].b, vox[i].a);
          } else {
            data.push(64);
          }
          i += r;
        }
      }
      if (version === 2) {
        data.push(85, 0, 0);
        rcolors = [];
        for (n = 0, len = vox.length; n < len; n++) {
          v = vox[n];
          if (!(v != null)) {
            continue;
          }
          hex = v.b + 256 * v.g + 65536 * v.r;
          mat = v.a + 256 * v.t + 2048 * v.s;
          if (rcolors[hex] == null) {
            rcolors[hex] = [];
          }
          if (((ref8 = rcolors[hex]) != null ? ref8[mat] : void 0) == null) {
            data.push(16 * v.t + v.s, v.r, v.g, v.b, v.a);
            rcolors[hex][mat] = (data.length - 7) / 5;
            if (!((data.length - 7) / 5 < 32768)) {
              throw new Error("To many colors for Troxel2 palette");
            }
          }
        }
        data[5] = Math.floor((data.length - 7) / 1280);
        data[6] = (data.length - 7) / 5 % 256;
        short = data[5] === 0 && data[6] < 128;
        while (i < vox.length) {
          r = 1;
          while (r < 129) {
            if (equal(vox[i + r - 1], vox[i + r], i + r)) {
              r++;
            } else {
              break;
            }
          }
          if (r > 1) {
            data.push(126 + r);
          }
          if (vox[i] != null) {
            index = rcolors[vox[i].b + 256 * vox[i].g + 65536 * vox[i].r][vox[i].a + 256 * vox[i].t + 2048 * vox[i].s];
            if (short) {
              data.push(index);
            } else {
              data.push(Math.floor(index / 256), index % 256);
            }
          } else {
            if (short) {
              data.push(0);
            } else {
              data.push(0, 0);
            }
          }
          i += r;
        }
      }
      console.log("export base64:");
      console.log(data);
      return btoa(String.fromCharCode.apply(null, data));
    };
    return Base64IO;
  })($__require('2'));
  JsonIO = (function(superClass) {
    extend(JsonIO, superClass);
    function JsonIO(json) {
      var ref;
      if (JsonIO.__super__.constructor.call(this, json)) {
        return;
      }
      ref = JSON.parse(json), this.x = ref.x, this.y = ref.y, this.z = ref.z, this.voxels = ref.voxels;
    }
    JsonIO.prototype["export"] = function(pretty) {
      return JSON.stringify({
        x: this.x,
        y: this.y,
        z: this.z,
        voxels: this.voxels
      }, null, pretty ? '    ' : '');
    };
    return JsonIO;
  })($__require('2'));
  module.exports = Base64IO;
  return module.exports;
});

$__System.registerDynamic("4", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "THREE", null);
  (function() {
    THREE.SSAOShader = {
      uniforms: {
        "tDiffuse": {
          type: "t",
          value: null
        },
        "tDepth": {
          type: "t",
          value: null
        },
        "size": {
          type: "v2",
          value: new THREE.Vector2(512, 512)
        },
        "cameraNear": {
          type: "f",
          value: 1
        },
        "cameraFar": {
          type: "f",
          value: 100
        },
        "onlyAO": {
          type: "i",
          value: 0
        },
        "aoClamp": {
          type: "f",
          value: 0.5
        },
        "lumInfluence": {
          type: "f",
          value: 0.5
        }
      },
      vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
      fragmentShader: ["uniform float cameraNear;", "uniform float cameraFar;", "uniform bool onlyAO;", "uniform vec2 size;", "uniform float aoClamp;", "uniform float lumInfluence;", "uniform sampler2D tDiffuse;", "uniform sampler2D tDepth;", "varying vec2 vUv;", "#define DL 2.399963229728653", "#define EULER 2.718281828459045", "float width = size.x;", "float height = size.y;", "float cameraFarPlusNear = cameraFar + cameraNear;", "float cameraFarMinusNear = cameraFar - cameraNear;", "float cameraCoef = 2.0 * cameraNear;", "const int samples = 8;", "const float radius = 5.0;", "const bool useNoise = false;", "const float noiseAmount = 0.0003;", "const float diffArea = 0.4;", "const float gDisplace = 0.4;", "float unpackDepth( const in vec4 rgba_depth ) {", "const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );", "float depth = dot( rgba_depth, bit_shift );", "return depth;", "}", "vec2 rand( const vec2 coord ) {", "vec2 noise;", "if ( useNoise ) {", "float nx = dot ( coord, vec2( 12.9898, 78.233 ) );", "float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );", "noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );", "} else {", "float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );", "float gg = fract( coord.t * ( height / 2.0 ) );", "noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;", "}", "return ( noise * 2.0  - 1.0 ) * noiseAmount;", "}", "float readDepth( const in vec2 coord ) {", "return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );", "}", "float compareDepths( const in float depth1, const in float depth2, inout int far ) {", "float garea = 2.0;", "float diff = ( depth1 - depth2 ) * 100.0;", "if ( diff < gDisplace ) {", "garea = diffArea;", "} else {", "far = 1;", "}", "float dd = diff - gDisplace;", "float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );", "return gauss;", "}", "float calcAO( float depth, float dw, float dh ) {", "float dd = radius - depth * radius;", "vec2 vv = vec2( dw, dh );", "vec2 coord1 = vUv + dd * vv;", "vec2 coord2 = vUv - dd * vv;", "float temp1 = 0.0;", "float temp2 = 0.0;", "int far = 0;", "temp1 = compareDepths( depth, readDepth( coord1 ), far );", "if ( far > 0 ) {", "temp2 = compareDepths( readDepth( coord2 ), depth, far );", "temp1 += ( 1.0 - temp1 ) * temp2;", "}", "return temp1;", "}", "void main() {", "vec2 noise = rand( vUv );", "float depth = readDepth( vUv );", "float tt = clamp( depth, aoClamp, 1.0 );", "float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );", "float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );", "float ao = 0.0;", "float dz = 1.0 / float( samples );", "float z = 1.0 - dz / 2.0;", "float l = 0.0;", "for ( int i = 0; i <= samples; i ++ ) {", "float r = sqrt( 1.0 - z );", "float pw = cos( l ) * r;", "float ph = sin( l ) * r;", "ao += calcAO( depth, pw * w, ph * h );", "z = z - dz;", "l = l + DL;", "}", "ao /= float( samples );", "ao = 1.0 - ao;", "vec3 color = texture2D( tDiffuse, vUv ).rgb;", "vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );", "float lum = dot( color.rgb, lumcoeff );", "vec3 luminance = vec3( lum );", "vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );", "if ( onlyAO ) {", "final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );", "}", "gl_FragColor = vec4( final, 1.0 );", "}"].join("\n")
    };
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("6", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "THREE", null);
  (function() {
    THREE.FXAAShader = {
      uniforms: {
        "tDiffuse": {
          type: "t",
          value: null
        },
        "resolution": {
          type: "v2",
          value: new THREE.Vector2(1 / 1024, 1 / 512)
        }
      },
      vertexShader: ["void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
      fragmentShader: ["uniform sampler2D tDiffuse;", "uniform vec2 resolution;", "#define FXAA_REDUCE_MIN   (1.0/128.0)", "#define FXAA_REDUCE_MUL   (1.0/8.0)", "#define FXAA_SPAN_MAX     8.0", "void main() {", "vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;", "vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;", "vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;", "vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;", "vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );", "vec3 rgbM  = rgbaM.xyz;", "vec3 luma = vec3( 0.299, 0.587, 0.114 );", "float lumaNW = dot( rgbNW, luma );", "float lumaNE = dot( rgbNE, luma );", "float lumaSW = dot( rgbSW, luma );", "float lumaSE = dot( rgbSE, luma );", "float lumaM  = dot( rgbM,  luma );", "float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );", "float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );", "vec2 dir;", "dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));", "dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));", "float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );", "float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );", "dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),", "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),", "dir * rcpDirMin)) * resolution;", "vec4 rgbA = (1.0/2.0) * (", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));", "vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +", "texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));", "float lumaB = dot(rgbB, vec4(luma, 0.0));", "if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {", "gl_FragColor = rgbA;", "} else {", "gl_FragColor = rgbB;", "}", "}"].join("\n")
    };
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("7", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "THREE", null);
  (function() {
    THREE.CopyShader = {
      uniforms: {
        "tDiffuse": {
          type: "t",
          value: null
        },
        "opacity": {
          type: "f",
          value: 1.0
        }
      },
      vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
      fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")
    };
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("8", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "THREE", null);
  (function() {
    THREE.ShaderPass = function(shader, textureID) {
      this.textureID = (textureID !== undefined) ? textureID : "tDiffuse";
      this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
      this.material = new THREE.ShaderMaterial({
        defines: shader.defines || {},
        uniforms: this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
      this.renderToScreen = false;
      this.enabled = true;
      this.needsSwap = true;
      this.clear = false;
      this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      this.scene = new THREE.Scene();
      this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
      this.scene.add(this.quad);
    };
    THREE.ShaderPass.prototype = {render: function(renderer, writeBuffer, readBuffer, delta) {
        if (this.uniforms[this.textureID]) {
          this.uniforms[this.textureID].value = readBuffer;
        }
        this.quad.material = this.material;
        if (this.renderToScreen) {
          renderer.render(this.scene, this.camera);
        } else {
          renderer.render(this.scene, this.camera, writeBuffer, this.clear);
        }
      }};
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("9", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "THREE", null);
  (function() {
    THREE.RenderPass = function(scene, camera, overrideMaterial, clearColor, clearAlpha) {
      this.scene = scene;
      this.camera = camera;
      this.overrideMaterial = overrideMaterial;
      this.clearColor = clearColor;
      this.clearAlpha = (clearAlpha !== undefined) ? clearAlpha : 1;
      this.oldClearColor = new THREE.Color();
      this.oldClearAlpha = 1;
      this.enabled = true;
      this.clear = true;
      this.needsSwap = false;
    };
    THREE.RenderPass.prototype = {render: function(renderer, writeBuffer, readBuffer, delta) {
        this.scene.overrideMaterial = this.overrideMaterial;
        if (this.clearColor) {
          this.oldClearColor.copy(renderer.getClearColor());
          this.oldClearAlpha = renderer.getClearAlpha();
          renderer.setClearColor(this.clearColor, this.clearAlpha);
        }
        renderer.render(this.scene, this.camera, readBuffer, this.clear);
        if (this.clearColor) {
          renderer.setClearColor(this.oldClearColor, this.oldClearAlpha);
        }
        this.scene.overrideMaterial = null;
      }};
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("a", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "THREE", null);
  (function() {
    THREE.MaskPass = function(scene, camera) {
      this.scene = scene;
      this.camera = camera;
      this.enabled = true;
      this.clear = true;
      this.needsSwap = false;
      this.inverse = false;
    };
    THREE.MaskPass.prototype = {render: function(renderer, writeBuffer, readBuffer, delta) {
        var context = renderer.context;
        context.colorMask(false, false, false, false);
        context.depthMask(false);
        var writeValue,
            clearValue;
        if (this.inverse) {
          writeValue = 0;
          clearValue = 1;
        } else {
          writeValue = 1;
          clearValue = 0;
        }
        context.enable(context.STENCIL_TEST);
        context.stencilOp(context.REPLACE, context.REPLACE, context.REPLACE);
        context.stencilFunc(context.ALWAYS, writeValue, 0xffffffff);
        context.clearStencil(clearValue);
        renderer.render(this.scene, this.camera, readBuffer, this.clear);
        renderer.render(this.scene, this.camera, writeBuffer, this.clear);
        context.colorMask(true, true, true, true);
        context.depthMask(true);
        context.stencilFunc(context.EQUAL, 1, 0xffffffff);
        context.stencilOp(context.KEEP, context.KEEP, context.KEEP);
      }};
    THREE.ClearMaskPass = function() {
      this.enabled = true;
    };
    THREE.ClearMaskPass.prototype = {render: function(renderer, writeBuffer, readBuffer, delta) {
        var context = renderer.context;
        context.disable(context.STENCIL_TEST);
      }};
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("b", ["5"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "THREE", null);
  (function() {
    THREE.EffectComposer = function(renderer, renderTarget) {
      this.renderer = renderer;
      if (renderTarget === undefined) {
        var pixelRatio = renderer.getPixelRatio();
        var width = Math.floor(renderer.context.canvas.width / pixelRatio) || 1;
        var height = Math.floor(renderer.context.canvas.height / pixelRatio) || 1;
        var parameters = {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter,
          format: THREE.RGBFormat,
          stencilBuffer: false
        };
        renderTarget = new THREE.WebGLRenderTarget(width, height, parameters);
      }
      this.renderTarget1 = renderTarget;
      this.renderTarget2 = renderTarget.clone();
      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;
      this.passes = [];
      if (THREE.CopyShader === undefined)
        console.error("THREE.EffectComposer relies on THREE.CopyShader");
      this.copyPass = new THREE.ShaderPass(THREE.CopyShader);
    };
    THREE.EffectComposer.prototype = {
      swapBuffers: function() {
        var tmp = this.readBuffer;
        this.readBuffer = this.writeBuffer;
        this.writeBuffer = tmp;
      },
      addPass: function(pass) {
        this.passes.push(pass);
      },
      insertPass: function(pass, index) {
        this.passes.splice(index, 0, pass);
      },
      render: function(delta) {
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
        var maskActive = false;
        var pass,
            i,
            il = this.passes.length;
        for (i = 0; i < il; i++) {
          pass = this.passes[i];
          if (!pass.enabled)
            continue;
          pass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);
          if (pass.needsSwap) {
            if (maskActive) {
              var context = this.renderer.context;
              context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);
              this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);
              context.stencilFunc(context.EQUAL, 1, 0xffffffff);
            }
            this.swapBuffers();
          }
          if (pass instanceof THREE.MaskPass) {
            maskActive = true;
          } else if (pass instanceof THREE.ClearMaskPass) {
            maskActive = false;
          }
        }
      },
      reset: function(renderTarget) {
        if (renderTarget === undefined) {
          renderTarget = this.renderTarget1.clone();
          var pixelRatio = this.renderer.getPixelRatio();
          renderTarget.width = Math.floor(this.renderer.context.canvas.width / pixelRatio);
          renderTarget.height = Math.floor(this.renderer.context.canvas.height / pixelRatio);
        }
        this.renderTarget1 = renderTarget;
        this.renderTarget2 = renderTarget.clone();
        this.writeBuffer = this.renderTarget1;
        this.readBuffer = this.renderTarget2;
      },
      setSize: function(width, height) {
        var renderTarget = this.renderTarget1.clone();
        renderTarget.width = width;
        renderTarget.height = height;
        this.reset(renderTarget);
      }
    };
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("c", ["5"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var THREE,
      TroxelControls,
      extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
  THREE = $__require('5');
  TroxelControls = (function(superClass) {
    var reset;
    extend(TroxelControls, superClass);
    function TroxelControls(object, domElement) {
      this.object = object;
      this.domElement = domElement;
      this.enabled = true;
      this.mode = true;
      this.target = new THREE.Vector3();
      this.noZoom = false;
      this.zoomSpeed = 0.95;
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.noRotate = false;
      this.rotateSpeed = 1.0;
      this.noPan = false;
      this.autoRotate = false;
      this.autoRotateSpeed = -4.0;
      this.noKeys = false;
      this.needsRender = false;
      this.EPS = 0.000001;
      this.rotateStart = new THREE.Vector2();
      this.rotateEnd = new THREE.Vector2();
      this.rotateDelta = new THREE.Vector2();
      this.panStart = new THREE.Vector2();
      this.panEnd = new THREE.Vector2();
      this.panDelta = new THREE.Vector2();
      this.panOffset = new THREE.Vector3();
      this.offset = new THREE.Vector3();
      this.dollyStart = new THREE.Vector2();
      this.dollyEnd = new THREE.Vector2();
      this.dollyDelta = new THREE.Vector2();
      this.theta = 0;
      this.phi = 0;
      this.phiDelta = 0;
      this.thetaDelta = 0;
      this.scale = 1;
      this.pan = new THREE.Vector3();
      this.lastPosition = new THREE.Vector3();
      this.lastQuaternion = new THREE.Quaternion();
      this.STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_DOLLY: 4,
        TOUCH_PAN: 5,
        FLY: 6
      };
      this.state = this.STATE.NONE;
      this.target0 = this.target.clone();
      this.position0 = this.object.position.clone();
      this.quat = new THREE.Quaternion().setFromUnitVectors(this.object.up, new THREE.Vector3(0, 1, 0));
      this.quatInverse = this.quat.clone().inverse();
      this.moveVector = new THREE.Vector3();
      this.rotationVector = new THREE.Vector3();
      this.tmpQuaternion = new THREE.Quaternion();
      this.mousefly = false;
      this.domElement.addEventListener('contextmenu', function(e) {
        return e.preventDefault();
      });
      this.domElement.addEventListener('mousedown', (function(_this) {
        return function(e) {
          return _this.onMouseDown(e);
        };
      })(this));
      document.addEventListener('mouseup', (function(_this) {
        return function(e) {
          return _this.onMouseUp(e);
        };
      })(this));
      document.addEventListener('mousemove', (function(_this) {
        return function(e) {
          return _this.onMouseMove(e);
        };
      })(this));
      this.domElement.addEventListener('mousewheel', (function(_this) {
        return function(e) {
          return _this.onMouseWheel(e);
        };
      })(this));
      this.domElement.addEventListener('DOMMouseScroll', (function(_this) {
        return function(e) {
          return _this.onMouseWheel(e);
        };
      })(this));
      this.domElement.addEventListener('touchstart', (function(_this) {
        return function(e) {
          return _this.touchstart(e);
        };
      })(this));
      this.domElement.addEventListener('touchend', (function(_this) {
        return function(e) {
          return _this.touchend(e);
        };
      })(this));
      this.domElement.addEventListener('touchmove', (function(_this) {
        return function(e) {
          return _this.touchmove(e);
        };
      })(this));
      window.addEventListener('keydown', (function(_this) {
        return function(e) {
          return _this.onKeyDown(e);
        };
      })(this));
      window.addEventListener('keyup', (function(_this) {
        return function(e) {
          return _this.onKeyUp(e);
        };
      })(this));
      this.object.lookAt(this.target);
      this.update();
    }
    TroxelControls.prototype.rotateLeft = function(angle) {
      if (angle == null) {
        angle = 2 * Math.PI / 60 / 60 * this.autoRotateSpeed;
      }
      return this.thetaDelta -= angle;
    };
    TroxelControls.prototype.rotateUp = function(angle) {
      if (angle == null) {
        angle = 2 * Math.PI / 60 / 60 * this.autoRotateSpeed;
      }
      return this.phiDelta -= angle;
    };
    TroxelControls.prototype.panLeft = function(distance) {
      var te;
      te = this.object.matrix.elements;
      this.panOffset.set(te[0], te[1], te[2]);
      this.panOffset.multiplyScalar(-distance);
      return this.pan.add(this.panOffset);
    };
    TroxelControls.prototype.panUp = function(distance) {
      var te;
      te = this.object.matrix.elements;
      this.panOffset.set(te[4], te[5], te[6]);
      this.panOffset.multiplyScalar(distance);
      return this.pan.add(this.panOffset);
    };
    TroxelControls.prototype.panXY = function(deltaX, deltaY) {
      var position,
          targetDistance;
      if (this.object instanceof THREE.PerspectiveCamera) {
        position = this.object.position;
        targetDistance = position.clone().sub(this.target).length();
        targetDistance *= Math.tan((this.object.fov / 2) * Math.PI / 180.0);
        this.panLeft(2 * deltaX * targetDistance / this.domElement.clientHeight);
        return this.panUp(2 * deltaY * targetDistance / this.domElement.clientHeight);
      } else {
        return console.warn('WARNING: Controls.js only supports perspective camera type.');
      }
    };
    TroxelControls.prototype.dollyIn = function(dollyScale) {
      if (dollyScale == null) {
        dollyScale = this.zoomSpeed;
      }
      return this.scale /= dollyScale;
    };
    TroxelControls.prototype.dollyOut = function(dollyScale) {
      if (dollyScale == null) {
        dollyScale = this.zoomSpeed;
      }
      return this.scale *= dollyScale;
    };
    TroxelControls.prototype.update = function(stats) {
      var position,
          radius;
      if (this.mode) {
        position = this.object.position;
        this.offset.copy(position).sub(this.target);
        this.offset.applyQuaternion(this.quat);
        this.theta = Math.atan2(this.offset.x, this.offset.z);
        this.phi = Math.atan2(Math.sqrt(this.offset.x * this.offset.x + this.offset.z * this.offset.z), this.offset.y);
        if (this.autoRotate && this.state === this.STATE.NONE) {
          this.rotateLeft(2 * Math.PI / 60 / 60 * this.autoRotateSpeed);
        }
        this.theta += this.thetaDelta;
        this.phi += this.phiDelta;
        this.phi = Math.max(this.EPS, Math.min(Math.PI - this.EPS, this.phi));
        radius = this.offset.length() * this.scale;
        radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));
        this.target.add(this.pan);
        this.offset.x = radius * Math.sin(this.phi) * Math.sin(this.theta);
        this.offset.y = radius * Math.cos(this.phi);
        this.offset.z = radius * Math.sin(this.phi) * Math.cos(this.theta);
        this.offset.applyQuaternion(this.quatInverse);
        position.copy(this.target).add(this.offset);
        this.object.lookAt(this.target);
        this.thetaDelta = 0;
        this.phiDelta = 0;
        this.scale = 1;
        this.pan.set(0, 0, 0);
      } else {
        this.object.translateX(this.moveVector.x * 20);
        this.object.translateY(this.moveVector.y * 20);
        this.object.translateZ(this.moveVector.z * 20);
        this.tmpQuaternion.set(this.rotationVector.x * 0.005, this.rotationVector.y * 0.005, this.rotationVector.z * 0.005, 1).normalize();
        this.object.quaternion.multiply(this.tmpQuaternion);
        this.object.rotation.setFromQuaternion(this.object.quaternion, this.object.rotation.order);
      }
      if (this.lastPosition.distanceToSquared(this.object.position) > this.EPS || 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > this.EPS) {
        this.dispatchEvent({type: 'change'});
        this.lastPosition.copy(this.object.position);
        this.lastQuaternion.copy(this.object.quaternion);
        return this.needsRender = false;
      }
      if (this.needsRender) {
        this.dispatchEvent({type: 'change'});
        return this.needsRender = false;
      }
      if (stats != null) {
        return stats.end();
      }
    };
    reset = function() {
      this.state = this.STATE.NONE;
      this.target.copy(this.target0);
      this.object.position.copy(this.position0);
      this.object.updateProjectionMatrix();
      this.dispatchEvent({type: 'change'});
      return this.update();
    };
    TroxelControls.prototype.onMouseDown = function(e) {
      if (!this.enabled) {
        return;
      }
      e.preventDefault();
      if (this.mode) {
        if (e.button === 0) {
          if (this.noRotate) {
            return;
          }
          this.state = this.STATE.ROTATE;
          this.rotateStart.set(e.clientX, e.clientY);
        } else if (e.button === 1) {
          if (this.noZoom) {
            return;
          }
          this.state = this.STATE.DOLLY;
          this.dollyStart.set(e.clientX, e.clientY);
        } else if (e.button === 2) {
          if (this.noPan) {
            return;
          }
          this.state = this.STATE.PAN;
          this.panStart.set(e.clientX, e.clientY);
        }
      } else {
        this.mousefly = true;
        this.state = this.STATE.FLY;
        if (e.button === 0) {
          this.moveVector.z = -1;
        } else if (e.button === 2) {
          this.moveVector.z = 1;
        }
      }
      if (this.state !== this.STATE.NONE) {
        return this.dispatchEvent({type: 'start'});
      }
    };
    TroxelControls.prototype.onMouseMove = function(e) {
      var h,
          w;
      if (!this.enabled) {
        return;
      }
      e.preventDefault();
      if (this.state === this.STATE.ROTATE) {
        if (this.noRotate) {
          return;
        }
        this.rotateEnd.set(e.clientX, e.clientY);
        this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
        this.rotateLeft(2 * Math.PI * this.rotateDelta.x / this.domElement.clientWidth * this.rotateSpeed);
        this.rotateUp(2 * Math.PI * this.rotateDelta.y / this.domElement.clientHeight * this.rotateSpeed);
        this.rotateStart.copy(this.rotateEnd);
      } else if (this.state === this.STATE.DOLLY) {
        if (this.noZoom) {
          return;
        }
        this.dollyEnd.set(e.clientX, e.clientY);
        this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart);
        if (this.dollyDelta.y > 0) {
          this.dollyIn();
        } else if (this.dollyDelta.y < 0) {
          this.dollyOut();
        }
        this.dollyStart.copy(this.dollyEnd);
      } else if (this.state === this.STATE.PAN) {
        if (this.noPan) {
          return;
        }
        this.panEnd.set(e.clientX, e.clientY);
        this.panDelta.subVectors(this.panEnd, this.panStart);
        this.panXY(this.panDelta.x, this.panDelta.y);
        this.panStart.copy(this.panEnd);
      } else if (this.mousefly) {
        w = this.domElement.clientWidth / 2;
        h = this.domElement.clientHeight / 2;
        this.rotationVector.y = -(e.clientX - w) / w;
        this.rotationVector.x = -(e.clientY - h) / h;
      }
      if (this.state !== this.STATE.NONE && this.mode) {
        return this.update();
      }
    };
    TroxelControls.prototype.onMouseUp = function() {
      if (!this.enabled) {
        return;
      }
      this.moveVector.z = 0;
      this.dispatchEvent({type: 'end'});
      return this.state = this.STATE.NONE;
    };
    TroxelControls.prototype.onMouseWheel = function(e) {
      var delta;
      if (!this.enabled || this.noZoom || this.state !== this.STATE.NONE || !this.mode) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      delta = 0;
      if (e.wheelDelta != null) {
        delta = e.wheelDelta;
      } else if (e.detail != null) {
        delta = -e.detail;
      }
      if (delta > 0) {
        this.dollyOut();
      } else if (delta < 0) {
        this.dollyIn();
      }
      this.update();
      this.dispatchEvent({type: 'start'});
      return this.dispatchEvent({type: 'end'});
    };
    TroxelControls.prototype.onKeyDown = function(e) {
      if (!this.enabled || this.noKeys) {
        return;
      }
      if (this.mode) {
        if (!this.noRotate) {
          switch (e.keyCode) {
            case 87:
              this.rotateUp(-0.05);
              this.update();
              break;
            case 65:
              this.rotateLeft(-0.05);
              this.update();
              break;
            case 83:
              this.rotateUp(0.05);
              this.update();
              break;
            case 68:
              this.rotateLeft(0.05);
              this.update();
          }
        }
        if (!this.noZoom) {
          switch (e.keyCode) {
            case 81:
              this.dollyIn();
              this.update();
              break;
            case 69:
              this.dollyOut();
              this.update();
          }
        }
        if (!this.noPan) {
          switch (e.keyCode) {
            case 38:
              this.panXY(0, 7.0);
              return this.update();
            case 40:
              this.panXY(0, -7.0);
              return this.update();
            case 37:
              this.panXY(7.0, 0);
              return this.update();
            case 39:
              this.panXY(-7.0, 0);
              return this.update();
          }
        }
      } else {
        if (this.mousefly) {
          this.rotationVector.set(0, 0, 0);
          this.mousefly = false;
        }
        switch (e.keyCode) {
          case 87:
            return this.moveVector.z = -1;
          case 83:
            return this.moveVector.z = 1;
          case 65:
            return this.moveVector.x = -1;
          case 68:
            return this.moveVector.x = 1;
          case 82:
            return this.moveVector.y = 1;
          case 70:
            return this.moveVector.y = -1;
          case 38:
            return this.rotationVector.x = -1;
          case 40:
            return this.rotationVector.x = 1;
          case 37:
            return this.rotationVector.y = 1;
          case 39:
            return this.rotationVector.y = -1;
          case 81:
            return this.rotationVector.z = 1;
          case 69:
            return this.rotationVector.z = -1;
        }
      }
    };
    TroxelControls.prototype.onKeyUp = function(e) {
      if (!this.enabled || this.noKeys || this.mode) {
        return;
      }
      switch (e.keyCode) {
        case 87:
          return this.moveVector.z = 0;
        case 83:
          return this.moveVector.z = 0;
        case 65:
          return this.moveVector.x = 0;
        case 68:
          return this.moveVector.x = 0;
        case 82:
          return this.moveVector.y = 0;
        case 70:
          return this.moveVector.y = 0;
        case 38:
          return this.rotationVector.x = 0;
        case 40:
          return this.rotationVector.x = 0;
        case 37:
          return this.rotationVector.y = 0;
        case 39:
          return this.rotationVector.y = 0;
        case 81:
          return this.rotationVector.z = 0;
        case 69:
          return this.rotationVector.z = 0;
      }
    };
    TroxelControls.prototype.touchstart = function(e) {
      var dx,
          dy;
      if (!(this.enabled && this.mode)) {
        return;
      }
      switch (e.touches.length) {
        case 1:
          if (this.noRotate) {
            return;
          }
          this.state = this.STATE.TOUCH_ROTATE;
          this.rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);
          break;
        case 2:
          if (this.noZoom) {
            return;
          }
          this.state = this.STATE.TOUCH_DOLLY;
          dx = e.touches[0].pageX - e.touches[1].pageX;
          dy = e.touches[0].pageY - e.touches[1].pageY;
          this.dollyStart.set(0, Math.sqrt(dx * dx + dy * dy));
          break;
        case 3:
          if (this.noPan) {
            return;
          }
          this.state = this.STATE.TOUCH_PAN;
          this.panStart.set(e.touches[0].pageX, e.touches[0].pageY);
          break;
        default:
          this.state = this.STATE.NONE;
      }
      if (this.state !== this.STATE.NONE) {
        return this.dispatchEvent({type: 'start'});
      }
    };
    TroxelControls.prototype.touchmove = function(e) {
      var dx,
          dy;
      if (!(this.enabled && this.mode)) {
        return;
      }
      e.preventDefault();
      e.stopPropagation();
      switch (e.touches.length) {
        case 1:
          if (this.noRotate || this.state !== this.STATE.TOUCH_ROTATE) {
            return;
          }
          this.rotateEnd.set(e.touches[0].pageX, e.touches[0].pageY);
          this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
          this.rotateLeft(2 * Math.PI * this.rotateDelta.x / this.domElement.clientWidth * this.rotateSpeed);
          this.rotateUp(2 * Math.PI * this.rotateDelta.y / this.domElement.clientHeight * this.rotateSpeed);
          this.rotateStart.copy(this.rotateEnd);
          return this.update();
        case 2:
          if (this.noZoom || this.state !== this.STATE.TOUCH_DOLLY) {
            return;
          }
          dx = e.touches[0].pageX - e.touches[1].pageX;
          dy = e.touches[0].pageY - e.touches[1].pageY;
          this.dollyEnd.set(0, Math.sqrt(dx * dx + dy * dy));
          this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart);
          if (this.dollyDelta.y > 0) {
            this.dollyOut();
          } else if (this.dollyDelta.y < 0) {
            this.dollyIn();
          }
          this.dollyStart.copy(this.dollyEnd);
          return this.update();
        case 3:
          if (this.noPan || this.state !== this.STATE.TOUCH_PAN) {
            return;
          }
          this.panEnd.set(e.touches[0].pageX, e.touches[0].pageY);
          this.panDelta.subVectors(this.panEnd, this.panStart);
          this.panXY(this.panDelta.x, this.panDelta.y);
          this.panStart.copy(this.panEnd);
          return this.update();
        default:
          return this.state = this.STATE.NONE;
      }
    };
    TroxelControls.prototype.touchend = function() {
      if (!(this.enabled && this.mode)) {
        return;
      }
      this.dispatchEvent({type: 'end'});
      return this.state = this.STATE.NONE;
    };
    return TroxelControls;
  })(THREE.EventDispatcher);
  module.exports = TroxelControls;
  return module.exports;
});

(function() {
var define = $__System.amdDefine;
(function(global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  var arr = [];
  var document = window.document;
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var version = "2.2.1",
      jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      },
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      rmsPrefix = /^-ms-/,
      rdashAlpha = /-([\da-z])/gi,
      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    selector: "",
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      return num != null ? (num < 0 ? this[num + this.length] : this[num]) : slice.call(this);
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function(callback) {
      return jQuery.each(this, callback);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor();
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function(obj) {
      var realStringObj = obj && obj.toString();
      return !jQuery.isArray(obj) && (realStringObj - parseFloat(realStringObj) + 1) >= 0;
    },
    isPlainObject: function(obj) {
      if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
        return false;
      }
      return true;
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    },
    globalEval: function(code) {
      var script,
          indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf("use strict") === 1) {
          script = document.createElement("script");
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function(obj, callback) {
      var length,
          i = 0;
      if (isArrayLike(obj)) {
        length = obj.length;
        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = [];
      if (isArrayLike(elems)) {
        length = elems.length;
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function(fn, context) {
      var tmp,
          args,
          proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  }
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArrayLike(obj) {
    var length = !!obj && "length" in obj && obj.length,
        type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle = (function(window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        MAX_NEGATIVE = 1 << 31,
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
              len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        rescape = /'|\\/g,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        unloadHandler = function() {
          setDocument();
        };
    try {
      push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length,
              i = 0;
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }};
    }
    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          nidselect,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          nodeType = context ? context.nodeType : 9;
      results = results || [];
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed) {
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        if (documentIsHTML) {
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            if ((m = match[1])) {
              if (nodeType === 9) {
                if ((elem = context.getElementById(m))) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            if (nodeType !== 1) {
              newContext = context;
              newSelector = selector;
            } else if (context.nodeName.toLowerCase() !== "object") {
              if ((nid = context.getAttribute("id"))) {
                nid = nid.replace(rescape, "\\$&");
              } else {
                context.setAttribute("id", (nid = expando));
              }
              groups = tokenize(selector);
              i = groups.length;
              nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
              while (i--) {
                groups[i] = nidselect + " " + toSelector(groups[i]);
              }
              newSelector = groups.join(",");
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            }
            if (newSelector) {
              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {} finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement("div");
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare,
          parent,
          doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document);
      if ((parent = document.defaultView) && parent.top !== parent) {
        if (parent.addEventListener) {
          parent.addEventListener("unload", unloadHandler, false);
        } else if (parent.attachEvent) {
          parent.attachEvent("onunload", unloadHandler);
        }
      }
      support.attributes = assert(function(div) {
        div.className = "i";
        return !div.getAttribute("className");
      });
      support.getElementsByTagName = assert(function(div) {
        div.appendChild(document.createComment(""));
        return !div.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(document.getElementsByClassName);
      support.getById = assert(function(div) {
        docElem.appendChild(div).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var m = context.getElementById(id);
            return m ? [m] : [];
          }
        };
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
      } else {
        delete Expr.find["ID"];
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while ((elem = results[i++])) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(document.querySelectorAll))) {
        assert(function(div) {
          docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
          if (div.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!div.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!div.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!div.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function(div) {
          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          div.appendChild(input).setAttribute("name", "D");
          if (div.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (!div.querySelectorAll(":enabled").length) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          div.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
        assert(function(div) {
          support.disconnectedMatch = matches.call(div, "div");
          matches.call(div, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while ((b = b.parentNode)) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];
        if (!aup || !bup) {
          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return document;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {dir: "parentNode"},
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {dir: "previousSibling"}
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess,
              unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while ((node = node[dir])) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                node = parent;
                outerCache = node[expando] || (node[expando] = {});
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                if (useCache) {
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {});
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                if (diff === false) {
                  while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || (diff % first === 0 && diff / first >= 0);
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function(selector) {
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;
            while (i--) {
              if ((elem = unmatched[i])) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function(elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": function(elem) {
          return elem.disabled === false;
        },
        "disabled": function(elem) {
          return elem.disabled === true;
        },
        "checked": function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while ((elem = elem[dir])) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function(elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName];
        if (xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return (newCache[2] = oldCache[2]);
              } else {
                uniqueCache[dir] = newCache;
                if ((newCache[2] = matcher(elem, context, xml))) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;
            if (outermost) {
              outermostContext = context === document || context || outermost;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument !== document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context || document, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(div1) {
      return div1.compareDocumentPosition(document.createElement("div")) & 1;
    });
    if (!assert(function(div) {
      div.innerHTML = "<a href='#'></a>";
      return div.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(div) {
      div.innerHTML = "<input/>";
      div.firstChild.setAttribute("value", "");
      return div.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(div) {
      return div.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var dir = function(elem, dir, until) {
    var matched = [],
        truncate = until !== undefined;
    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }
        matched.push(elem);
      }
    }
    return matched;
  };
  var siblings = function(n, elem) {
    var matched = [];
    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }
    return matched;
  };
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = (/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/);
  var risSimple = /^.[^:#\[\.,]*$/;
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function(elem) {
      return (indexOf.call(qualifier, elem) > -1) !== not;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
          len = this.length,
          ret = [],
          self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
      init = jQuery.fn.init = function(selector, context, root) {
        var match,
            elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (jQuery.isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document.getElementById(match[2]);
              if (elem && elem.parentNode) {
                this.length = 1;
                this[0] = elem;
              }
              this.context = document;
              this.selector = selector;
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this.context = this[0] = selector;
          this.length = 1;
          return this;
        } else if (jQuery.isFunction(selector)) {
          return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
          this.selector = selector.selector;
          this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
      };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return siblings(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnotwhite = (/\S+/g);
  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
    var firing,
        memory,
        fired,
        locked,
        list = [],
        queue = [],
        firingIndex = -1,
        fire = function() {
          locked = options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        },
        self = {
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  if (jQuery.isFunction(arg)) {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          remove: function() {
            jQuery.each(arguments, function(_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            locked = queue = [];
            if (!memory) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          fire: function() {
            self.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
    return self;
  };
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
          state = "pending",
          promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            then: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  var fn = jQuery.isFunction(fns[i]) && fns[i];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
            stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(subordinate) {
      var i = 0,
          resolveValues = slice.call(arguments),
          length = resolveValues.length,
          remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
          deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
          updateFunc = function(i, contexts, values) {
            return function(value) {
              contexts[i] = this;
              values[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (values === progressValues) {
                deferred.notifyWith(contexts, values);
              } else if (!(--remaining)) {
                deferred.resolveWith(contexts, values);
              }
            };
          },
          progressValues,
          progressContexts,
          resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  var readyList;
  jQuery.fn.ready = function(fn) {
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    }
  });
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  }
  jQuery.ready.promise = function(obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
        window.setTimeout(jQuery.ready);
      } else {
        document.addEventListener("DOMContentLoaded", completed);
        window.addEventListener("load", completed);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.ready.promise();
  var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
  };
  var acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };
  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.prototype = {
    register: function(owner, initial) {
      var value = initial || {};
      if (owner.nodeType) {
        owner[this.expando] = value;
      } else {
        Object.defineProperty(owner, this.expando, {
          value: value,
          writable: true,
          configurable: true
        });
      }
      return owner[this.expando];
    },
    cache: function(owner) {
      if (!acceptData(owner)) {
        return {};
      }
      var value = owner[this.expando];
      if (!value) {
        value = {};
        if (acceptData(owner)) {
          if (owner.nodeType) {
            owner[this.expando] = value;
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }
      return value;
    },
    set: function(owner, data, value) {
      var prop,
          cache = this.cache(owner);
      if (typeof data === "string") {
        cache[data] = value;
      } else {
        for (prop in data) {
          cache[prop] = data[prop];
        }
      }
      return cache;
    },
    get: function(owner, key) {
      return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
    },
    access: function(owner, key, value) {
      var stored;
      if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
          name,
          camel,
          cache = owner[this.expando];
      if (cache === undefined) {
        return;
      }
      if (key === undefined) {
        this.register(owner);
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [key, camel];
          } else {
            name = camel;
            name = name in cache ? [name] : (name.match(rnotwhite) || []);
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
      if (key === undefined || jQuery.isEmptyObject(cache)) {
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e) {}
        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function(elem, name, data) {
      return dataUser.access(elem, name, data);
    },
    removeData: function(elem, name) {
      dataUser.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);
          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          dataUser.set(this, key);
        });
      }
      return access(this, function(value) {
        var data,
            camelKey;
        if (elem && value === undefined) {
          data = dataUser.get(elem, key) || dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());
          if (data !== undefined) {
            return data;
          }
          camelKey = jQuery.camelCase(key);
          data = dataUser.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        camelKey = jQuery.camelCase(key);
        this.each(function() {
          var data = dataUser.get(this, camelKey);
          dataUser.set(this, camelKey, value);
          if (key.indexOf("-") > -1 && data !== undefined) {
            dataUser.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function() {
            jQuery.dequeue(elem, type);
          };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
          dataPriv.remove(elem, [type + "queue", key]);
        })});
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function() {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHidden = function(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  };
  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale = 1,
        maxIterations = 20,
        currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
    if (initialInUnit && initialInUnit[3] !== unit) {
      unit = unit || initialInUnit[3];
      valueParts = valueParts || [];
      initialInUnit = +initial || 1;
      do {
        scale = scale || ".5";
        initialInUnit = initialInUnit / scale;
        jQuery.style(elem, prop, initialInUnit + unit);
      } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
    }
    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0;
      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  var rtagName = (/<([\w:-]+)/);
  var rscriptType = (/^$|\/(?:java|ecma)script/i);
  var wrapMap = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function getAll(context, tag) {
    var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;
    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }
  var rhtml = /<|&#?\w+;/;
  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        contains,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;
    for (; i < l; i++) {
      elem = elems[i];
      if (elem || elem === 0) {
        if (jQuery.type(elem) === "object") {
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
          j = wrap[0];
          while (j--) {
            tmp = tmp.lastChild;
          }
          jQuery.merge(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
      }
    }
    fragment.textContent = "";
    i = 0;
    while ((elem = nodes[i++])) {
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }
        continue;
      }
      contains = jQuery.contains(elem.ownerDocument, elem);
      tmp = getAll(fragment.appendChild(elem), "script");
      if (contains) {
        setGlobalEval(tmp);
      }
      if (scripts) {
        j = 0;
        while ((elem = tmp[j++])) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }
    return fragment;
  }
  (function() {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  function on(elem, types, selector, data, fn, one) {
    var origFn,
        type;
    if (typeof types === "object") {
      if (typeof selector !== "string") {
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }
      return elem;
    }
    if (data == null && fn == null) {
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        fn = data;
        data = undefined;
      } else {
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }
    if (one === 1) {
      origFn = fn;
      fn = function(event) {
        jQuery().off(event);
        return origFn.apply(this, arguments);
      };
      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }
    return elem.each(function() {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function(event) {
      event = jQuery.event.fix(event);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue = [],
          args = slice.call(arguments),
          handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i,
          matches,
          sel,
          handleObj,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;
      if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
      filter: function(event, original) {
        var eventDoc,
            doc,
            body,
            button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
        }
        return event;
      }
    },
    fix: function(event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i,
          prop,
          copy,
          type = event.type,
          originalEvent = event,
          fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: {noBubble: true},
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }}
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj,
          type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
      rnoInnerhtml = /<script|<style|<link/i,
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptTypeMasked = /^true\/(.*)/,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function cloneCopyEvent(src, dest) {
    var i,
        l,
        type,
        pdataOld,
        pdataCur,
        udataOld,
        udataCur,
        events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  function domManip(collection, args, callback, ignored) {
    args = concat.apply([], args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        isFunction = jQuery.isFunction(value);
    if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
      return collection.each(function(index) {
        var self = collection.eq(index);
        if (isFunction) {
          args[0] = value.call(this, index, self.html());
        }
        domManip(self, args, callback, ignored);
      });
    }
    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;
      if (fragment.childNodes.length === 1) {
        fragment = first;
      }
      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length;
        for (; i < l; i++) {
          node = fragment;
          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true);
            if (hasScripts) {
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }
          callback.call(collection[i], node, i);
        }
        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;
          jQuery.map(scripts, restoreScript);
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src) {
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
              }
            }
          }
        }
      }
    }
    return collection;
  }
  function remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;
    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }
      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }
        node.parentNode.removeChild(node);
      }
    }
    return elem;
  }
  jQuery.extend({
    htmlPrefilter: function(html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    cleanData: function(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if ((data = elem[dataPriv.expando])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            elem[dataPriv.expando] = undefined;
          }
          if (elem[dataUser.expando]) {
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    domManip: domManip,
    detach: function(selector) {
      return remove(this, selector, true);
    },
    remove: function(selector) {
      return remove(this, selector);
    },
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function() {
      var elem,
          i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var ignored = [];
      return domManip(this, arguments, function(elem) {
        var parent = this.parentNode;
        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));
          if (parent) {
            parent.replaceChild(elem, this);
          }
        }
      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var iframe,
      elemdisplay = {
        HTML: "block",
        BODY: "block"
      };
  function actualDisplay(name, doc) {
    var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
        display = jQuery.css(elem[0], "display");
    elem.detach();
    return display;
  }
  function defaultDisplay(nodeName) {
    var doc = document,
        display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === "none" || !display) {
        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
        doc = iframe[0].contentDocument;
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  var rmargin = (/^margin/);
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    var view = elem.ownerDocument.defaultView;
    if (!view || !view.opener) {
      view = window;
    }
    return view.getComputedStyle(elem);
  };
  var swap = function(elem, options, callback, args) {
    var ret,
        name,
        old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var documentElement = document.documentElement;
  (function() {
    var pixelPositionVal,
        boxSizingReliableVal,
        pixelMarginRightVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
    container.appendChild(div);
    function computeStyleTests() {
      div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
      div.innerHTML = "";
      documentElement.appendChild(container);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%";
      reliableMarginLeftVal = divStyle.marginLeft === "2px";
      boxSizingReliableVal = divStyle.width === "4px";
      div.style.marginRight = "50%";
      pixelMarginRightVal = divStyle.marginRight === "4px";
      documentElement.removeChild(container);
    }
    jQuery.extend(support, {
      pixelPosition: function() {
        computeStyleTests();
        return pixelPositionVal;
      },
      boxSizingReliable: function() {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }
        return boxSizingReliableVal;
      },
      pixelMarginRight: function() {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }
        return pixelMarginRightVal;
      },
      reliableMarginLeft: function() {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }
        return reliableMarginLeftVal;
      },
      reliableMarginRight: function() {
        var ret,
            marginDiv = div.appendChild(document.createElement("div"));
        marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
        marginDiv.style.marginRight = marginDiv.style.width = "0";
        div.style.width = "1px";
        documentElement.appendChild(container);
        ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);
        documentElement.removeChild(container);
        div.removeChild(marginDiv);
        return ret;
      }
    });
  })();
  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;
    computed = computed || getStyles(elem);
    ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
    if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
      ret = jQuery.style(elem, name);
    }
    if (computed) {
      if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get: function() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }};
  }
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      cssPrefixes = ["Webkit", "O", "Moz", "ms"],
      emptyStyle = document.createElement("div").style;
  function vendorPropName(name) {
    if (name in emptyStyle) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rcssNum.exec(value);
    return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
        val = 0;
    for (; i < 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles(elem),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (document.msFullscreenElement && window.top !== window) {
      if (elem.getClientRects().length) {
        val = Math.round(elem.getBoundingClientRect()[name] * 100);
      }
    }
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
  }
  function showHide(elements, show) {
    var display,
        elem,
        hidden,
        values = [],
        index = 0,
        length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = dataPriv.get(elem, "olddisplay");
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === "none") {
          elem.style.display = "";
        }
        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);
        if (display !== "none" || !hidden) {
          dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }
    return elements;
  }
  jQuery.extend({
    cssHooks: {opacity: {get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }}},
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {"float": "cssFloat"},
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret,
          type,
          hooks,
          origName = jQuery.camelCase(name),
          style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret);
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number") {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function() {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function(elem, value, extra) {
        var matches,
            styles = extra && getStyles(elem),
            subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);
        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[name] = value;
          value = jQuery.css(elem, name);
        }
        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {marginLeft: 0}, function() {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  });
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
    if (computed) {
      return swap(elem, {"display": "inline-block"}, curCSS, [elem, "marginRight"]);
    }
  });
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
        var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }};
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default: {
      get: function(tween) {
        var result;
        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }};
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
      timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;
  function createFxNow() {
    window.setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }
  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {height: type};
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        tween,
        hooks,
        oldfire,
        display,
        checkDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHidden(elem),
        dataShow = dataPriv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      display = jQuery.css(elem, "display");
      checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
      if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        style.display = "inline-block";
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = dataPriv.access(elem, "fxshow", {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function() {
          jQuery(elem).hide();
        });
      }
      anim.done(function() {
        var prop;
        dataPriv.remove(elem, "fxshow");
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }
    } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
      style.display = display;
    }
  }
  function propFilter(props, specialEasing) {
    var index,
        name,
        easing,
        value,
        hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }),
        tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;
          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length) {
            return remaining;
          } else {
            deferred.resolveWith(elem, [animation]);
            return false;
          }
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        if (jQuery.isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
        }
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {"*": [function(prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]},
    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnotwhite);
      }
      var prop,
          index = 0,
          length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    window.clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = window.setTimeout(next, time);
      hooks.stop = function() {
        window.clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        elem.setAttribute(name, value + "");
        return value;
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      ret = jQuery.find.attr(elem, name);
      return ret == null ? undefined : ret;
    },
    attrHooks: {type: {set: function(elem, value) {
          if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }}},
    removeAttr: function(elem, value) {
      var name,
          propName,
          i = 0,
          attrNames = value && value.match(rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    }
  });
  boolHook = {set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret,
          handle;
      if (!isXML) {
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        return (elem[name] = value);
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      return elem[name];
    },
    propHooks: {tabIndex: {get: function(elem) {
          var tabindex = jQuery.find.attr(elem, "tabindex");
          return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
        }}},
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }};
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  var rclass = /[\t\r\n\f]/g;
  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }
  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }
      if (typeof value === "string" && value) {
        classes = value.match(rnotwhite) || [];
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = jQuery.trim(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }
      if (!arguments.length) {
        return this.attr("class", "");
      }
      if (typeof value === "string" && value) {
        classes = value.match(rnotwhite) || [];
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = jQuery.trim(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }
      return this.each(function() {
        var className,
            i,
            self,
            classNames;
        if (type === "string") {
          i = 0;
          self = jQuery(this);
          classNames = value.match(rnotwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (value === undefined || type === "boolean") {
          className = getClass(this);
          if (className) {
            dataPriv.set(this, "__className__", className);
          }
          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";
      while ((elem = this[i++])) {
        if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({val: function(value) {
      var hooks,
          ret,
          isFunction,
          elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }});
  jQuery.extend({valHooks: {
      option: {get: function(elem) {
          return jQuery.trim(elem.value);
        }},
      select: {
        get: function(elem) {
          var value,
              option,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one" || index < 0,
              values = one ? null : [],
              max = one ? index + 1 : options.length,
              i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }});
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {set: function(elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
        }
      }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
  jQuery.extend(jQuery.event, {
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") > -1) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    simulate: function(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  });
  jQuery.fn.extend({
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }});
  support.focusin = "onfocusin" in window;
  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  var location = window.location;
  var nonce = jQuery.now();
  var rquery = (/\?/);
  jQuery.parseJSON = function(data) {
    return JSON.parse(data + "");
  };
  jQuery.parseXML = function(data) {
    var xml;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      xml = (new window.DOMParser()).parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rhash = /#.*$/,
      rts = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      prefilters = {},
      transports = {},
      allTypes = "*/".concat("*"),
      originAnchor = document.createElement("a");
  originAnchor.href = location.href;
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = (structure === transports);
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": jQuery.parseJSON,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
          cacheURL,
          responseHeadersString,
          responseHeaders,
          timeoutTimer,
          urlAnchor,
          fireGlobals,
          i,
          s = jQuery.ajaxSetup({}, options),
          callbackContext = s.context || s,
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          statusCode = s.statusCode || {},
          requestHeaders = {},
          requestHeadersNames = {},
          state = 0,
          strAbort = "canceled",
          jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (state === 2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase()] = match[2];
                  }
                }
                match = responseHeaders[key.toLowerCase()];
              }
              return match == null ? null : match;
            },
            getAllResponseHeaders: function() {
              return state === 2 ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              var lname = name.toLowerCase();
              if (!state) {
                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (!state) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (state < 2) {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                } else {
                  jqXHR.always(map[jqXHR.status]);
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a");
        try {
          urlAnchor.href = s.url;
          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          s.crossDomain = true;
        }
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      for (i in {
        success: 1,
        error: 1,
        complete: 1
      }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (state === 2) {
          return jqXHR;
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
            contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function() {
      return this.parent().each(function() {
        if (!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  jQuery.expr.filters.hidden = function(elem) {
    return !jQuery.expr.filters.visible(elem);
  };
  jQuery.expr.filters.visible = function(elem) {
    return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
  };
  var r20 = /%20/g,
      rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
        s = [],
        add = function(key, value) {
          value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&").replace(r20, "+");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function() {
        var type = this.type;
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function(i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };
  var xhrSuccessStatus = {
    0: 200,
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback,
        errorCallback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete(xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {binary: xhr.response} : {text: xhr.responseText}, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          errorCallback = xhr.onerror = callback("error");
          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                window.setTimeout(function() {
                  if (callback) {
                    errorCallback();
                  }
                });
              }
            };
          }
          callback = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"},
    contents: {script: /\b(?:java|ecma)script\b/},
    converters: {"text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }}
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script,
          callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function(evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName);
        } else {
          window[callbackName] = overwritten;
        }
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  support.createHTMLDocument = (function() {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  })();
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || (support.createHTMLDocument ? document.implementation.createHTMLDocument("") : document);
    var parsed = rsingleTag.exec(data),
        scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  var _load = jQuery.fn.load;
  jQuery.fn.load = function(url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");
    if (off > -1) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).always(callback && function(jqXHR, status) {
        self.each(function() {
          callback.apply(self, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.filters.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {setOffset: function(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }};
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function(i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var docElem,
          win,
          elem = this[0],
          box = {
            top: 0,
            left: 0
          },
          doc = elem && elem.ownerDocument;
      if (!doc) {
        return;
      }
      docElem = doc.documentElement;
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }
      box = elem.getBoundingClientRect();
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    },
    position: function() {
      if (!this[0]) {
        return;
      }
      var offsetParent,
          offset,
          elem = this[0],
          parentOffset = {
            top: 0,
            left: 0
          };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent;
        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || documentElement;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.extend({
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    },
    size: function() {
      return this.length;
    }
  });
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof define === "function" && define.amd) {
    define("d", [], function() {
      return jQuery;
    }), define("jquery", ["d"], function(m) {
      return m;
    });
  }
  var _jQuery = window.jQuery,
      _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
}));

})();
$__System.registerDynamic("e", ["5", "4", "6", "7", "8", "9", "a", "b", "c", "d"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $,
      Renderer,
      THREE,
      TroxelControls;
  THREE = $__require('5');
  $__require('4');
  $__require('6');
  $__require('7');
  $__require('8');
  $__require('9');
  $__require('a');
  $__require('b');
  TroxelControls = $__require('c');
  $ = $__require('d');
  Renderer = (function() {
    function Renderer(io, embedded, domContainer, renderMode, renderWireframes, antialias, ssao, renderControls) {
      var ds,
          du;
      this.embedded = embedded != null ? embedded : false;
      this.domContainer = domContainer != null ? domContainer : $('#WebGlContainer');
      this.renderMode = renderMode != null ? renderMode : 0;
      this.renderWireframes = renderWireframes != null ? renderWireframes : 0;
      if (antialias == null) {
        antialias = true;
      }
      this.ssao = ssao != null ? ssao : false;
      if (renderControls == null) {
        renderControls = true;
      }
      this.width = this.domContainer.width();
      this.height = this.domContainer.height();
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(45, this.width / this.height, 1, 100000);
      this.controls = new TroxelControls(this.camera, this.domContainer[0]);
      this.controls.mode = renderControls;
      this.controls.addEventListener('change', (function(_this) {
        return function() {
          return _this.render();
        };
      })(this));
      this.reload(io.voxels, io.x, io.y, io.z, false, true);
      this.ambientLight = new THREE.AmbientLight(0x606060);
      this.scene.add(this.ambientLight);
      this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
      this.directionalLight.position.set(-0.5, -0.5, 1).normalize();
      this.scene.add(this.directionalLight);
      this.pointLight = new THREE.PointLight(0xffffff, 0.6, 100000);
      this.camera.add(this.pointLight);
      this.scene.add(this.camera);
      this.renderer = new THREE.WebGLRenderer({antialias: antialias});
      this.renderer.setClearColor(0x888888);
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.setSize(this.width, this.height);
      this.domContainer.empty().append(this.renderer.domElement);
      window.test = this;
      if (this.ssao) {
        this.composer = new THREE.EffectComposer(this.renderer);
        this.composer.addPass(new THREE.RenderPass(this.scene, this.camera));
        this.ssaoPass = new THREE.ShaderPass(THREE.SSAOShader);
        this.depthRenderTarget = new THREE.WebGLRenderTarget(this.width, this.height, {
          minFilter: THREE.LinearFilter,
          magFilter: THREE.LinearFilter
        });
        this.ssaoPass.uniforms['tDepth'].value = this.depthRenderTarget;
        this.ssaoPass.uniforms['size'].value.set(this.width, this.height);
        this.ssaoPass.uniforms['cameraNear'].value = this.camera.near;
        this.ssaoPass.uniforms['cameraFar'].value = this.camera.far;
        this.ssaoPass.uniforms['onlyAO'].value = false;
        this.ssaoPass.uniforms['aoClamp'].value = 0.5;
        this.ssaoPass.uniforms['lumInfluence'].value = 0.25;
        this.composer.addPass(this.ssaoPass);
        this.fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
        this.fxaaPass.uniforms['resolution'].value.set(1 / this.width, 1 / this.height);
        this.fxaaPass.renderToScreen = true;
        this.composer.addPass(this.fxaaPass);
        ds = THREE.ShaderLib['depthRGBA'];
        du = THREE.UniformsUtils.clone(ds.uniforms);
        this.depthMaterial = new THREE.ShaderMaterial({
          fragmentShader: ds.fragmentShader,
          vertexShader: ds.vertexShader,
          uniforms: du,
          blending: THREE.NoBlending
        });
      }
      window.addEventListener('resize', (function(_this) {
        return function(e) {
          return _this.onWindowResize(e);
        };
      })(this));
      if (this.embedded) {
        this.animate();
      }
    }
    Renderer.prototype.getMaterial = function(color, a, t, s) {
      var material;
      switch (this.renderMode) {
        case 0:
        case 1:
          break;
        case 2:
          color = {
            250: 0xff00ff,
            16: 0x101010,
            48: 0x303030,
            80: 0x505050,
            12: 0x707070,
            144: 0x909090,
            176: 0xb0b0b0,
            208: 0xd0d0d0,
            240: 0xf0f0f0,
            255: 0xffffff
          }[a];
          break;
        case 3:
          color = [0xffffff, 0x808080, 0x404040, 0xff0000, 0xffff00, null, null, 0xff00ff][t];
          break;
        case 4:
          color = [0x800000, 0x008000, 0x000080, 0x808000, 0x800080, null, null, 0xff00ff][s];
      }
      material = new THREE.MeshPhongMaterial({
        color: color,
        ambient: color
      });
      if (this.renderMode === 0) {
        if (t === 3 || t === 4) {
          material.emissive = material.color.multiplyScalar(0.5);
        }
        if (s === 1) {
          material.specular = material.color.multiplyScalar(0.5);
        }
        if (t === 1 || t === 2 || t === 4) {
          material.transparent = true;
          material.opacity = a / 255;
        }
      } else {
        material.shininess = 0.1;
      }
      return material;
    };
    Renderer.prototype.reload = function(voxels, x1, y1, z1, resize, init) {
      var a,
          color,
          geometry,
          hex,
          i,
          j,
          k,
          linemat,
          mat,
          matIndex,
          materials,
          matrix,
          nx,
          ny,
          nz,
          px,
          py,
          pz,
          ref,
          ref1,
          ref10,
          ref11,
          ref12,
          ref13,
          ref14,
          ref15,
          ref16,
          ref17,
          ref18,
          ref19,
          ref2,
          ref20,
          ref21,
          ref22,
          ref23,
          ref24,
          ref25,
          ref26,
          ref27,
          ref28,
          ref29,
          ref3,
          ref30,
          ref31,
          ref32,
          ref33,
          ref34,
          ref35,
          ref36,
          ref37,
          ref38,
          ref39,
          ref4,
          ref40,
          ref41,
          ref42,
          ref5,
          ref6,
          ref7,
          ref8,
          ref9,
          reverseMaterialIndex,
          vox,
          wcolor,
          wireGeo,
          x,
          y,
          z;
      this.voxels = voxels;
      this.x = x1;
      this.y = y1;
      this.z = z1;
      if (resize == null) {
        resize = false;
      }
      if (init == null) {
        init = false;
      }
      if (resize || init) {
        if (this.embedded) {
          a = Math.max(this.x, this.z);
          this.camera.position.x = 85 * a + 65 * this.y;
          this.camera.position.y = 50 * this.y;
          this.camera.position.z = 25 * a;
        } else {
          this.camera.position.x = 65 * this.y + 35 * this.x + 55 * this.z;
          this.camera.position.y = 50 * this.y;
          this.camera.position.z = 25 * this.x;
        }
        this.controls.target = new THREE.Vector3(this.z * 25, this.y * 25, this.x * 25);
      }
      if (!init) {
        this.scene.remove(this.mesh);
        this.mesh.geometry.dispose();
        if (this.wireframe != null) {
          this.scene.remove(this.wireframe);
          this.wireframe.geometry.dispose();
        }
      }
      matrix = new THREE.Matrix4();
      color = new THREE.Color();
      px = new THREE.PlaneGeometry(50, 50);
      px.applyMatrix(matrix.makeRotationY(Math.PI / 2));
      px.applyMatrix(matrix.makeTranslation(25, 0, 0));
      nx = new THREE.PlaneGeometry(50, 50);
      nx.applyMatrix(matrix.makeRotationY(-Math.PI / 2));
      nx.applyMatrix(matrix.makeTranslation(-25, 0, 0));
      py = new THREE.PlaneGeometry(50, 50);
      py.applyMatrix(matrix.makeRotationX(-Math.PI / 2));
      py.applyMatrix(matrix.makeTranslation(0, 25, 0));
      ny = new THREE.PlaneGeometry(50, 50);
      ny.applyMatrix(matrix.makeRotationX(Math.PI / 2));
      ny.applyMatrix(matrix.makeTranslation(0, -25, 0));
      pz = new THREE.PlaneGeometry(50, 50);
      pz.applyMatrix(matrix.makeTranslation(0, 0, 25));
      nz = new THREE.PlaneGeometry(50, 50);
      nz.applyMatrix(matrix.makeRotationY(Math.PI));
      nz.applyMatrix(matrix.makeTranslation(0, 0, -25));
      geometry = new THREE.Geometry();
      materials = [];
      reverseMaterialIndex = [];
      this.wireframe = null;
      if (this.renderWireframes > 0) {
        wireGeo = new THREE.Geometry();
      }
      for (z = i = 0, ref = this.z; i < ref; z = i += 1) {
        if (this.voxels[z] != null) {
          for (y = j = 0, ref1 = this.y; j < ref1; y = j += 1) {
            if (((ref2 = this.voxels[z]) != null ? ref2[y] : void 0) != null) {
              for (x = k = 0, ref3 = this.x; k < ref3; x = k += 1) {
                if (!(((ref4 = this.voxels[z]) != null ? (ref5 = ref4[y]) != null ? ref5[x] : void 0 : void 0) != null)) {
                  continue;
                }
                vox = this.voxels[z][y][x];
                color.setRGB(vox.r / 255, vox.g / 255, vox.b / 255);
                hex = color.getHex();
                mat = vox.a + 256 * vox.t + 2048 * vox.s;
                if (((ref6 = reverseMaterialIndex[hex]) != null ? ref6[mat] : void 0) != null) {
                  matIndex = reverseMaterialIndex[hex][mat];
                } else {
                  matIndex = materials.length;
                  if (reverseMaterialIndex[hex] == null) {
                    reverseMaterialIndex[hex] = [];
                  }
                  reverseMaterialIndex[hex][mat] = matIndex;
                  materials.push(this.getMaterial(color, vox.a, vox.t, vox.s));
                }
                matrix.makeTranslation(z * 50 + 25, y * 50 + 25, x * 50 + 25);
                if ((((ref7 = this.voxels[z + 1]) != null ? (ref8 = ref7[y]) != null ? ref8[x] : void 0 : void 0) == null) || (((ref9 = this.voxels[z + 1][y][x].t) === 1 || ref9 === 2 || ref9 === 4) && ((ref10 = vox.t) !== 1 && ref10 !== 2 && ref10 !== 4))) {
                  geometry.merge(px, matrix, matIndex);
                }
                if ((((ref11 = this.voxels[z - 1]) != null ? (ref12 = ref11[y]) != null ? ref12[x] : void 0 : void 0) == null) || (((ref13 = this.voxels[z - 1][y][x].t) === 1 || ref13 === 2 || ref13 === 4) && ((ref14 = vox.t) !== 1 && ref14 !== 2 && ref14 !== 4))) {
                  geometry.merge(nx, matrix, matIndex);
                }
                if ((((ref15 = this.voxels[z]) != null ? (ref16 = ref15[y + 1]) != null ? ref16[x] : void 0 : void 0) == null) || (((ref17 = this.voxels[z][y + 1][x].t) === 1 || ref17 === 2 || ref17 === 4) && ((ref18 = vox.t) !== 1 && ref18 !== 2 && ref18 !== 4))) {
                  geometry.merge(py, matrix, matIndex);
                }
                if ((((ref19 = this.voxels[z]) != null ? (ref20 = ref19[y - 1]) != null ? ref20[x] : void 0 : void 0) == null) || (((ref21 = this.voxels[z][y - 1][x].t) === 1 || ref21 === 2 || ref21 === 4) && ((ref22 = vox.t) !== 1 && ref22 !== 2 && ref22 !== 4))) {
                  geometry.merge(ny, matrix, matIndex);
                }
                if ((((ref23 = this.voxels[z]) != null ? (ref24 = ref23[y]) != null ? ref24[x + 1] : void 0 : void 0) == null) || (((ref25 = this.voxels[z][y][x + 1].t) === 1 || ref25 === 2 || ref25 === 4) && ((ref26 = vox.t) !== 1 && ref26 !== 2 && ref26 !== 4))) {
                  geometry.merge(pz, matrix, matIndex);
                }
                if ((((ref27 = this.voxels[z]) != null ? (ref28 = ref27[y]) != null ? ref28[x - 1] : void 0 : void 0) == null) || (((ref29 = this.voxels[z][y][x - 1].t) === 1 || ref29 === 2 || ref29 === 4) && ((ref30 = vox.t) !== 1 && ref30 !== 2 && ref30 !== 4))) {
                  geometry.merge(nz, matrix, matIndex);
                }
                if (this.renderWireframes > 0) {
                  wcolor = (function() {
                    switch (this.renderWireframes) {
                      case 2:
                        return new THREE.Color(vox.r / 255, vox.g / 255, vox.b / 255);
                      case 3:
                        return new THREE.Color({
                          250: 0xff00ff,
                          16: 0x101010,
                          48: 0x303030,
                          80: 0x505050,
                          12: 0x707070,
                          144: 0x909090,
                          176: 0xb0b0b0,
                          208: 0xd0d0d0,
                          240: 0xf0f0f0,
                          255: 0xffffff
                        }[vox.a]);
                      case 4:
                        return new THREE.Color([0xffffff, 0x808080, 0x404040, 0xff0000, 0xffff00, null, null, 0xff00ff][vox.t]);
                      case 5:
                        return new THREE.Color([0x800000, 0x008000, 0x000080, 0x808000, 0x800080, null, null, 0xff00ff][vox.s]);
                      case 6:
                        if (vox.linter != null) {
                          return new THREE.Color(vox.linter);
                        } else {
                          return false;
                        }
                        break;
                      default:
                        return new THREE.Color(0x333333);
                    }
                  }).call(this);
                  if ((((ref31 = this.voxels[z + 1]) != null ? (ref32 = ref31[y]) != null ? ref32[x] : void 0 : void 0) == null) && wcolor) {
                    wireGeo.vertices.push(new THREE.Vector3(50 * z + 50, 50 * y, 50 * x), new THREE.Vector3(50 * z + 50, 50 * y, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y + 50, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y + 50, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y + 50, 50 * x), new THREE.Vector3(50 * z + 50, 50 * y + 50, 50 * x), new THREE.Vector3(50 * z + 50, 50 * y, 50 * x));
                    wireGeo.colors.push(wcolor, wcolor, wcolor, wcolor, wcolor, wcolor, wcolor, wcolor);
                  }
                  if ((((ref33 = this.voxels[z - 1]) != null ? (ref34 = ref33[y]) != null ? ref34[x] : void 0 : void 0) == null) && wcolor) {
                    wireGeo.vertices.push(new THREE.Vector3(50 * z, 50 * y, 50 * x), new THREE.Vector3(50 * z, 50 * y, 50 * x + 50), new THREE.Vector3(50 * z, 50 * y, 50 * x + 50), new THREE.Vector3(50 * z, 50 * y + 50, 50 * x + 50), new THREE.Vector3(50 * z, 50 * y + 50, 50 * x + 50), new THREE.Vector3(50 * z, 50 * y + 50, 50 * x), new THREE.Vector3(50 * z, 50 * y + 50, 50 * x), new THREE.Vector3(50 * z, 50 * y, 50 * x));
                    wireGeo.colors.push(wcolor, wcolor, wcolor, wcolor, wcolor, wcolor, wcolor, wcolor);
                  }
                  if ((((ref35 = this.voxels[z]) != null ? (ref36 = ref35[y + 1]) != null ? ref36[x] : void 0 : void 0) == null) && wcolor) {
                    wireGeo.vertices.push(new THREE.Vector3(50 * z, 50 * y + 50, 50 * x), new THREE.Vector3(50 * z, 50 * y + 50, 50 * x + 50), new THREE.Vector3(50 * z, 50 * y + 50, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y + 50, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y + 50, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y + 50, 50 * x), new THREE.Vector3(50 * z + 50, 50 * y + 50, 50 * x), new THREE.Vector3(50 * z, 50 * y + 50, 50 * x));
                    wireGeo.colors.push(wcolor, wcolor, wcolor, wcolor, wcolor, wcolor, wcolor, wcolor);
                  }
                  if ((((ref37 = this.voxels[z]) != null ? (ref38 = ref37[y - 1]) != null ? ref38[x] : void 0 : void 0) == null) && wcolor) {
                    wireGeo.vertices.push(new THREE.Vector3(50 * z, 50 * y, 50 * x), new THREE.Vector3(50 * z, 50 * y, 50 * x + 50), new THREE.Vector3(50 * z, 50 * y, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y, 50 * x), new THREE.Vector3(50 * z + 50, 50 * y, 50 * x), new THREE.Vector3(50 * z, 50 * y, 50 * x));
                    wireGeo.colors.push(wcolor, wcolor, wcolor, wcolor, wcolor, wcolor, wcolor, wcolor);
                  }
                  if ((((ref39 = this.voxels[z]) != null ? (ref40 = ref39[y]) != null ? ref40[x + 1] : void 0 : void 0) == null) && wcolor) {
                    wireGeo.vertices.push(new THREE.Vector3(50 * z, 50 * y, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y + 50, 50 * x + 50), new THREE.Vector3(50 * z + 50, 50 * y + 50, 50 * x + 50), new THREE.Vector3(50 * z, 50 * y + 50, 50 * x + 50), new THREE.Vector3(50 * z, 50 * y + 50, 50 * x + 50), new THREE.Vector3(50 * z, 50 * y, 50 * x + 50));
                    wireGeo.colors.push(wcolor, wcolor, wcolor, wcolor, wcolor, wcolor, wcolor, wcolor);
                  }
                  if ((((ref41 = this.voxels[z]) != null ? (ref42 = ref41[y]) != null ? ref42[x - 1] : void 0 : void 0) == null) && wcolor) {
                    wireGeo.vertices.push(new THREE.Vector3(50 * z, 50 * y, 50 * x), new THREE.Vector3(50 * z + 50, 50 * y, 50 * x), new THREE.Vector3(50 * z + 50, 50 * y, 50 * x), new THREE.Vector3(50 * z + 50, 50 * y + 50, 50 * x), new THREE.Vector3(50 * z + 50, 50 * y + 50, 50 * x), new THREE.Vector3(50 * z, 50 * y + 50, 50 * x), new THREE.Vector3(50 * z, 50 * y + 50, 50 * x), new THREE.Vector3(50 * z, 50 * y, 50 * x));
                    wireGeo.colors.push(wcolor, wcolor, wcolor, wcolor, wcolor, wcolor, wcolor, wcolor);
                  }
                }
              }
            }
          }
        }
      }
      this.mesh = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(materials));
      if (this.renderWireframes > 0) {
        linemat = new THREE.LineBasicMaterial({
          vertexColors: THREE.VertexColors,
          linewidth: 2
        });
        this.wireframe = new THREE.Line(wireGeo, linemat, THREE.LinePieces);
        this.scene.add(this.wireframe);
      }
      this.scene.add(this.mesh);
      if (!init) {
        return this.controls.needsRender = true;
      }
    };
    Renderer.prototype.animate = function() {
      requestAnimationFrame((function(_this) {
        return function() {
          return _this.animate();
        };
      })(this));
      if (!this.embedded) {
        this.stats.begin();
      }
      return this.controls.update(this.stats);
    };
    Renderer.prototype.render = function(exportPng) {
      if (this.ssao) {
        this.scene.overrideMaterial = this.depthMaterial;
        this.renderer.render(this.scene, this.camera, this.depthRenderTarget, true);
        this.scene.overrideMaterial = null;
        this.composer.render();
      } else {
        this.renderer.render(this.scene, this.camera);
      }
      if (!this.embedded) {
        this.stats.end();
      }
      if (exportPng) {
        return window.open(this.renderer.domElement.toDataURL(), 'Exported png');
      }
    };
    Renderer.prototype.onWindowResize = function() {
      this.width = this.domContainer.width();
      this.height = this.domContainer.height();
      this.camera.aspect = this.width / this.height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.width, this.height);
      if (this.ssao) {
        this.ssaoPass.uniforms['size'].value.set(this.width, this.height);
        this.fxaaPass.uniforms['resolution'].value.set(1 / this.width, 1 / this.height);
        this.composer.setSize(this.width, this.height);
      }
      return this.controls.needsRender = true;
    };
    return Renderer;
  })();
  module.exports = Renderer;
  return module.exports;
});

$__System.registerDynamic("5", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "THREE", null);
  (function() {
    var THREE = this["THREE"];
    var THREE = {REVISION: '71'};
    if (typeof module === 'object') {
      module.exports = THREE;
    }
    if (Math.sign === undefined) {
      Math.sign = function(x) {
        return (x < 0) ? -1 : (x > 0) ? 1 : +x;
      };
    }
    THREE.log = function() {
      console.log.apply(console, arguments);
    };
    THREE.warn = function() {
      console.warn.apply(console, arguments);
    };
    THREE.error = function() {
      console.error.apply(console, arguments);
    };
    THREE.MOUSE = {
      LEFT: 0,
      MIDDLE: 1,
      RIGHT: 2
    };
    THREE.CullFaceNone = 0;
    THREE.CullFaceBack = 1;
    THREE.CullFaceFront = 2;
    THREE.CullFaceFrontBack = 3;
    THREE.FrontFaceDirectionCW = 0;
    THREE.FrontFaceDirectionCCW = 1;
    THREE.BasicShadowMap = 0;
    THREE.PCFShadowMap = 1;
    THREE.PCFSoftShadowMap = 2;
    THREE.FrontSide = 0;
    THREE.BackSide = 1;
    THREE.DoubleSide = 2;
    THREE.NoShading = 0;
    THREE.FlatShading = 1;
    THREE.SmoothShading = 2;
    THREE.NoColors = 0;
    THREE.FaceColors = 1;
    THREE.VertexColors = 2;
    THREE.NoBlending = 0;
    THREE.NormalBlending = 1;
    THREE.AdditiveBlending = 2;
    THREE.SubtractiveBlending = 3;
    THREE.MultiplyBlending = 4;
    THREE.CustomBlending = 5;
    THREE.AddEquation = 100;
    THREE.SubtractEquation = 101;
    THREE.ReverseSubtractEquation = 102;
    THREE.MinEquation = 103;
    THREE.MaxEquation = 104;
    THREE.ZeroFactor = 200;
    THREE.OneFactor = 201;
    THREE.SrcColorFactor = 202;
    THREE.OneMinusSrcColorFactor = 203;
    THREE.SrcAlphaFactor = 204;
    THREE.OneMinusSrcAlphaFactor = 205;
    THREE.DstAlphaFactor = 206;
    THREE.OneMinusDstAlphaFactor = 207;
    THREE.DstColorFactor = 208;
    THREE.OneMinusDstColorFactor = 209;
    THREE.SrcAlphaSaturateFactor = 210;
    THREE.MultiplyOperation = 0;
    THREE.MixOperation = 1;
    THREE.AddOperation = 2;
    THREE.UVMapping = 300;
    THREE.CubeReflectionMapping = 301;
    THREE.CubeRefractionMapping = 302;
    THREE.EquirectangularReflectionMapping = 303;
    THREE.EquirectangularRefractionMapping = 304;
    THREE.SphericalReflectionMapping = 305;
    THREE.RepeatWrapping = 1000;
    THREE.ClampToEdgeWrapping = 1001;
    THREE.MirroredRepeatWrapping = 1002;
    THREE.NearestFilter = 1003;
    THREE.NearestMipMapNearestFilter = 1004;
    THREE.NearestMipMapLinearFilter = 1005;
    THREE.LinearFilter = 1006;
    THREE.LinearMipMapNearestFilter = 1007;
    THREE.LinearMipMapLinearFilter = 1008;
    THREE.UnsignedByteType = 1009;
    THREE.ByteType = 1010;
    THREE.ShortType = 1011;
    THREE.UnsignedShortType = 1012;
    THREE.IntType = 1013;
    THREE.UnsignedIntType = 1014;
    THREE.FloatType = 1015;
    THREE.HalfFloatType = 1025;
    THREE.UnsignedShort4444Type = 1016;
    THREE.UnsignedShort5551Type = 1017;
    THREE.UnsignedShort565Type = 1018;
    THREE.AlphaFormat = 1019;
    THREE.RGBFormat = 1020;
    THREE.RGBAFormat = 1021;
    THREE.LuminanceFormat = 1022;
    THREE.LuminanceAlphaFormat = 1023;
    THREE.RGBEFormat = THREE.RGBAFormat;
    THREE.RGB_S3TC_DXT1_Format = 2001;
    THREE.RGBA_S3TC_DXT1_Format = 2002;
    THREE.RGBA_S3TC_DXT3_Format = 2003;
    THREE.RGBA_S3TC_DXT5_Format = 2004;
    THREE.RGB_PVRTC_4BPPV1_Format = 2100;
    THREE.RGB_PVRTC_2BPPV1_Format = 2101;
    THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
    THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
    THREE.Projector = function() {
      THREE.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');
      this.projectVector = function(vector, camera) {
        THREE.warn('THREE.Projector: .projectVector() is now vector.project().');
        vector.project(camera);
      };
      this.unprojectVector = function(vector, camera) {
        THREE.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
        vector.unproject(camera);
      };
      this.pickingRay = function(vector, camera) {
        THREE.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
      };
    };
    THREE.CanvasRenderer = function() {
      THREE.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');
      this.domElement = document.createElement('canvas');
      this.clear = function() {};
      this.render = function() {};
      this.setClearColor = function() {};
      this.setSize = function() {};
    };
    THREE.Color = function(color) {
      if (arguments.length === 3) {
        return this.setRGB(arguments[0], arguments[1], arguments[2]);
      }
      return this.set(color);
    };
    THREE.Color.prototype = {
      constructor: THREE.Color,
      r: 1,
      g: 1,
      b: 1,
      set: function(value) {
        if (value instanceof THREE.Color) {
          this.copy(value);
        } else if (typeof value === 'number') {
          this.setHex(value);
        } else if (typeof value === 'string') {
          this.setStyle(value);
        }
        return this;
      },
      setHex: function(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
      },
      setRGB: function(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
      },
      setHSL: function(h, s, l) {
        if (s === 0) {
          this.r = this.g = this.b = l;
        } else {
          var hue2rgb = function(p, q, t) {
            if (t < 0)
              t += 1;
            if (t > 1)
              t -= 1;
            if (t < 1 / 6)
              return p + (q - p) * 6 * t;
            if (t < 1 / 2)
              return q;
            if (t < 2 / 3)
              return p + (q - p) * 6 * (2 / 3 - t);
            return p;
          };
          var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
          var q = (2 * l) - p;
          this.r = hue2rgb(q, p, h + 1 / 3);
          this.g = hue2rgb(q, p, h);
          this.b = hue2rgb(q, p, h - 1 / 3);
        }
        return this;
      },
      setStyle: function(style) {
        if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(style)) {
          var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(style);
          this.r = Math.min(255, parseInt(color[1], 10)) / 255;
          this.g = Math.min(255, parseInt(color[2], 10)) / 255;
          this.b = Math.min(255, parseInt(color[3], 10)) / 255;
          return this;
        }
        if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(style)) {
          var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(style);
          this.r = Math.min(100, parseInt(color[1], 10)) / 100;
          this.g = Math.min(100, parseInt(color[2], 10)) / 100;
          this.b = Math.min(100, parseInt(color[3], 10)) / 100;
          return this;
        }
        if (/^\#([0-9a-f]{6})$/i.test(style)) {
          var color = /^\#([0-9a-f]{6})$/i.exec(style);
          this.setHex(parseInt(color[1], 16));
          return this;
        }
        if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(style)) {
          var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(style);
          this.setHex(parseInt(color[1] + color[1] + color[2] + color[2] + color[3] + color[3], 16));
          return this;
        }
        if (/^(\w+)$/i.test(style)) {
          this.setHex(THREE.ColorKeywords[style]);
          return this;
        }
      },
      copy: function(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
      },
      copyGammaToLinear: function(color, gammaFactor) {
        if (gammaFactor === undefined)
          gammaFactor = 2.0;
        this.r = Math.pow(color.r, gammaFactor);
        this.g = Math.pow(color.g, gammaFactor);
        this.b = Math.pow(color.b, gammaFactor);
        return this;
      },
      copyLinearToGamma: function(color, gammaFactor) {
        if (gammaFactor === undefined)
          gammaFactor = 2.0;
        var safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;
        this.r = Math.pow(color.r, safeInverse);
        this.g = Math.pow(color.g, safeInverse);
        this.b = Math.pow(color.b, safeInverse);
        return this;
      },
      convertGammaToLinear: function() {
        var r = this.r,
            g = this.g,
            b = this.b;
        this.r = r * r;
        this.g = g * g;
        this.b = b * b;
        return this;
      },
      convertLinearToGamma: function() {
        this.r = Math.sqrt(this.r);
        this.g = Math.sqrt(this.g);
        this.b = Math.sqrt(this.b);
        return this;
      },
      getHex: function() {
        return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
      },
      getHexString: function() {
        return ('000000' + this.getHex().toString(16)).slice(-6);
      },
      getHSL: function(optionalTarget) {
        var hsl = optionalTarget || {
          h: 0,
          s: 0,
          l: 0
        };
        var r = this.r,
            g = this.g,
            b = this.b;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var hue,
            saturation;
        var lightness = (min + max) / 2.0;
        if (min === max) {
          hue = 0;
          saturation = 0;
        } else {
          var delta = max - min;
          saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
          switch (max) {
            case r:
              hue = (g - b) / delta + (g < b ? 6 : 0);
              break;
            case g:
              hue = (b - r) / delta + 2;
              break;
            case b:
              hue = (r - g) / delta + 4;
              break;
          }
          hue /= 6;
        }
        hsl.h = hue;
        hsl.s = saturation;
        hsl.l = lightness;
        return hsl;
      },
      getStyle: function() {
        return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
      },
      offsetHSL: function(h, s, l) {
        var hsl = this.getHSL();
        hsl.h += h;
        hsl.s += s;
        hsl.l += l;
        this.setHSL(hsl.h, hsl.s, hsl.l);
        return this;
      },
      add: function(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
      },
      addColors: function(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
      },
      addScalar: function(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
      },
      multiply: function(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
      },
      multiplyScalar: function(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
      },
      lerp: function(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
      },
      equals: function(c) {
        return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
      },
      fromArray: function(array) {
        this.r = array[0];
        this.g = array[1];
        this.b = array[2];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
      },
      clone: function() {
        return new THREE.Color().setRGB(this.r, this.g, this.b);
      }
    };
    THREE.ColorKeywords = {
      'aliceblue': 0xF0F8FF,
      'antiquewhite': 0xFAEBD7,
      'aqua': 0x00FFFF,
      'aquamarine': 0x7FFFD4,
      'azure': 0xF0FFFF,
      'beige': 0xF5F5DC,
      'bisque': 0xFFE4C4,
      'black': 0x000000,
      'blanchedalmond': 0xFFEBCD,
      'blue': 0x0000FF,
      'blueviolet': 0x8A2BE2,
      'brown': 0xA52A2A,
      'burlywood': 0xDEB887,
      'cadetblue': 0x5F9EA0,
      'chartreuse': 0x7FFF00,
      'chocolate': 0xD2691E,
      'coral': 0xFF7F50,
      'cornflowerblue': 0x6495ED,
      'cornsilk': 0xFFF8DC,
      'crimson': 0xDC143C,
      'cyan': 0x00FFFF,
      'darkblue': 0x00008B,
      'darkcyan': 0x008B8B,
      'darkgoldenrod': 0xB8860B,
      'darkgray': 0xA9A9A9,
      'darkgreen': 0x006400,
      'darkgrey': 0xA9A9A9,
      'darkkhaki': 0xBDB76B,
      'darkmagenta': 0x8B008B,
      'darkolivegreen': 0x556B2F,
      'darkorange': 0xFF8C00,
      'darkorchid': 0x9932CC,
      'darkred': 0x8B0000,
      'darksalmon': 0xE9967A,
      'darkseagreen': 0x8FBC8F,
      'darkslateblue': 0x483D8B,
      'darkslategray': 0x2F4F4F,
      'darkslategrey': 0x2F4F4F,
      'darkturquoise': 0x00CED1,
      'darkviolet': 0x9400D3,
      'deeppink': 0xFF1493,
      'deepskyblue': 0x00BFFF,
      'dimgray': 0x696969,
      'dimgrey': 0x696969,
      'dodgerblue': 0x1E90FF,
      'firebrick': 0xB22222,
      'floralwhite': 0xFFFAF0,
      'forestgreen': 0x228B22,
      'fuchsia': 0xFF00FF,
      'gainsboro': 0xDCDCDC,
      'ghostwhite': 0xF8F8FF,
      'gold': 0xFFD700,
      'goldenrod': 0xDAA520,
      'gray': 0x808080,
      'green': 0x008000,
      'greenyellow': 0xADFF2F,
      'grey': 0x808080,
      'honeydew': 0xF0FFF0,
      'hotpink': 0xFF69B4,
      'indianred': 0xCD5C5C,
      'indigo': 0x4B0082,
      'ivory': 0xFFFFF0,
      'khaki': 0xF0E68C,
      'lavender': 0xE6E6FA,
      'lavenderblush': 0xFFF0F5,
      'lawngreen': 0x7CFC00,
      'lemonchiffon': 0xFFFACD,
      'lightblue': 0xADD8E6,
      'lightcoral': 0xF08080,
      'lightcyan': 0xE0FFFF,
      'lightgoldenrodyellow': 0xFAFAD2,
      'lightgray': 0xD3D3D3,
      'lightgreen': 0x90EE90,
      'lightgrey': 0xD3D3D3,
      'lightpink': 0xFFB6C1,
      'lightsalmon': 0xFFA07A,
      'lightseagreen': 0x20B2AA,
      'lightskyblue': 0x87CEFA,
      'lightslategray': 0x778899,
      'lightslategrey': 0x778899,
      'lightsteelblue': 0xB0C4DE,
      'lightyellow': 0xFFFFE0,
      'lime': 0x00FF00,
      'limegreen': 0x32CD32,
      'linen': 0xFAF0E6,
      'magenta': 0xFF00FF,
      'maroon': 0x800000,
      'mediumaquamarine': 0x66CDAA,
      'mediumblue': 0x0000CD,
      'mediumorchid': 0xBA55D3,
      'mediumpurple': 0x9370DB,
      'mediumseagreen': 0x3CB371,
      'mediumslateblue': 0x7B68EE,
      'mediumspringgreen': 0x00FA9A,
      'mediumturquoise': 0x48D1CC,
      'mediumvioletred': 0xC71585,
      'midnightblue': 0x191970,
      'mintcream': 0xF5FFFA,
      'mistyrose': 0xFFE4E1,
      'moccasin': 0xFFE4B5,
      'navajowhite': 0xFFDEAD,
      'navy': 0x000080,
      'oldlace': 0xFDF5E6,
      'olive': 0x808000,
      'olivedrab': 0x6B8E23,
      'orange': 0xFFA500,
      'orangered': 0xFF4500,
      'orchid': 0xDA70D6,
      'palegoldenrod': 0xEEE8AA,
      'palegreen': 0x98FB98,
      'paleturquoise': 0xAFEEEE,
      'palevioletred': 0xDB7093,
      'papayawhip': 0xFFEFD5,
      'peachpuff': 0xFFDAB9,
      'peru': 0xCD853F,
      'pink': 0xFFC0CB,
      'plum': 0xDDA0DD,
      'powderblue': 0xB0E0E6,
      'purple': 0x800080,
      'red': 0xFF0000,
      'rosybrown': 0xBC8F8F,
      'royalblue': 0x4169E1,
      'saddlebrown': 0x8B4513,
      'salmon': 0xFA8072,
      'sandybrown': 0xF4A460,
      'seagreen': 0x2E8B57,
      'seashell': 0xFFF5EE,
      'sienna': 0xA0522D,
      'silver': 0xC0C0C0,
      'skyblue': 0x87CEEB,
      'slateblue': 0x6A5ACD,
      'slategray': 0x708090,
      'slategrey': 0x708090,
      'snow': 0xFFFAFA,
      'springgreen': 0x00FF7F,
      'steelblue': 0x4682B4,
      'tan': 0xD2B48C,
      'teal': 0x008080,
      'thistle': 0xD8BFD8,
      'tomato': 0xFF6347,
      'turquoise': 0x40E0D0,
      'violet': 0xEE82EE,
      'wheat': 0xF5DEB3,
      'white': 0xFFFFFF,
      'whitesmoke': 0xF5F5F5,
      'yellow': 0xFFFF00,
      'yellowgreen': 0x9ACD32
    };
    THREE.Quaternion = function(x, y, z, w) {
      this._x = x || 0;
      this._y = y || 0;
      this._z = z || 0;
      this._w = (w !== undefined) ? w : 1;
    };
    THREE.Quaternion.prototype = {
      constructor: THREE.Quaternion,
      _x: 0,
      _y: 0,
      _z: 0,
      _w: 0,
      get x() {
        return this._x;
      },
      set x(value) {
        this._x = value;
        this.onChangeCallback();
      },
      get y() {
        return this._y;
      },
      set y(value) {
        this._y = value;
        this.onChangeCallback();
      },
      get z() {
        return this._z;
      },
      set z(value) {
        this._z = value;
        this.onChangeCallback();
      },
      get w() {
        return this._w;
      },
      set w(value) {
        this._w = value;
        this.onChangeCallback();
      },
      set: function(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this.onChangeCallback();
        return this;
      },
      copy: function(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this.onChangeCallback();
        return this;
      },
      setFromEuler: function(euler, update) {
        if (euler instanceof THREE.Euler === false) {
          throw new Error('THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var c1 = Math.cos(euler._x / 2);
        var c2 = Math.cos(euler._y / 2);
        var c3 = Math.cos(euler._z / 2);
        var s1 = Math.sin(euler._x / 2);
        var s2 = Math.sin(euler._y / 2);
        var s3 = Math.sin(euler._z / 2);
        if (euler.order === 'XYZ') {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (euler.order === 'YXZ') {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (euler.order === 'ZXY') {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (euler.order === 'ZYX') {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        } else if (euler.order === 'YZX') {
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
        } else if (euler.order === 'XZY') {
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
        }
        if (update !== false)
          this.onChangeCallback();
        return this;
      },
      setFromAxisAngle: function(axis, angle) {
        var halfAngle = angle / 2,
            s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this.onChangeCallback();
        return this;
      },
      setFromRotationMatrix: function(m) {
        var te = m.elements,
            m11 = te[0],
            m12 = te[4],
            m13 = te[8],
            m21 = te[1],
            m22 = te[5],
            m23 = te[9],
            m31 = te[2],
            m32 = te[6],
            m33 = te[10],
            trace = m11 + m22 + m33,
            s;
        if (trace > 0) {
          s = 0.5 / Math.sqrt(trace + 1.0);
          this._w = 0.25 / s;
          this._x = (m32 - m23) * s;
          this._y = (m13 - m31) * s;
          this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
          this._w = (m32 - m23) / s;
          this._x = 0.25 * s;
          this._y = (m12 + m21) / s;
          this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
          s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
          this._w = (m13 - m31) / s;
          this._x = (m12 + m21) / s;
          this._y = 0.25 * s;
          this._z = (m23 + m32) / s;
        } else {
          s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
          this._w = (m21 - m12) / s;
          this._x = (m13 + m31) / s;
          this._y = (m23 + m32) / s;
          this._z = 0.25 * s;
        }
        this.onChangeCallback();
        return this;
      },
      setFromUnitVectors: function() {
        var v1,
            r;
        var EPS = 0.000001;
        return function(vFrom, vTo) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          r = vFrom.dot(vTo) + 1;
          if (r < EPS) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
              v1.set(-vFrom.y, vFrom.x, 0);
            } else {
              v1.set(0, -vFrom.z, vFrom.y);
            }
          } else {
            v1.crossVectors(vFrom, vTo);
          }
          this._x = v1.x;
          this._y = v1.y;
          this._z = v1.z;
          this._w = r;
          this.normalize();
          return this;
        };
      }(),
      inverse: function() {
        this.conjugate().normalize();
        return this;
      },
      conjugate: function() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this.onChangeCallback();
        return this;
      },
      dot: function(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
      },
      lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      },
      length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      },
      normalize: function() {
        var l = this.length();
        if (l === 0) {
          this._x = 0;
          this._y = 0;
          this._z = 0;
          this._w = 1;
        } else {
          l = 1 / l;
          this._x = this._x * l;
          this._y = this._y * l;
          this._z = this._z * l;
          this._w = this._w * l;
        }
        this.onChangeCallback();
        return this;
      },
      multiply: function(q, p) {
        if (p !== undefined) {
          THREE.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
          return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
      },
      multiplyQuaternions: function(a, b) {
        var qax = a._x,
            qay = a._y,
            qaz = a._z,
            qaw = a._w;
        var qbx = b._x,
            qby = b._y,
            qbz = b._z,
            qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this.onChangeCallback();
        return this;
      },
      multiplyVector3: function(vector) {
        THREE.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
        return vector.applyQuaternion(this);
      },
      slerp: function(qb, t) {
        if (t === 0)
          return this;
        if (t === 1)
          return this.copy(qb);
        var x = this._x,
            y = this._y,
            z = this._z,
            w = this._w;
        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
          this._w = -qb._w;
          this._x = -qb._x;
          this._y = -qb._y;
          this._z = -qb._z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }
        if (cosHalfTheta >= 1.0) {
          this._w = w;
          this._x = x;
          this._y = y;
          this._z = z;
          return this;
        }
        var halfTheta = Math.acos(cosHalfTheta);
        var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
        if (Math.abs(sinHalfTheta) < 0.001) {
          this._w = 0.5 * (w + this._w);
          this._x = 0.5 * (x + this._x);
          this._y = 0.5 * (y + this._y);
          this._z = 0.5 * (z + this._z);
          return this;
        }
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
            ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = (w * ratioA + this._w * ratioB);
        this._x = (x * ratioA + this._x * ratioB);
        this._y = (y * ratioA + this._y * ratioB);
        this._z = (z * ratioA + this._z * ratioB);
        this.onChangeCallback();
        return this;
      },
      equals: function(quaternion) {
        return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this.onChangeCallback();
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
      },
      onChange: function(callback) {
        this.onChangeCallback = callback;
        return this;
      },
      onChangeCallback: function() {},
      clone: function() {
        return new THREE.Quaternion(this._x, this._y, this._z, this._w);
      }
    };
    THREE.Quaternion.slerp = function(qa, qb, qm, t) {
      return qm.copy(qa).slerp(qb, t);
    };
    THREE.Vector2 = function(x, y) {
      this.x = x || 0;
      this.y = y || 0;
    };
    THREE.Vector2.prototype = {
      constructor: THREE.Vector2,
      set: function(x, y) {
        this.x = x;
        this.y = y;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      },
      add: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
      },
      addScalar: function(s) {
        this.x += s;
        this.y += s;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      },
      sub: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
      },
      subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      },
      multiply: function(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      },
      multiplyScalar: function(s) {
        this.x *= s;
        this.y *= s;
        return this;
      },
      divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      },
      divideScalar: function(scalar) {
        if (scalar !== 0) {
          var invScalar = 1 / scalar;
          this.x *= invScalar;
          this.y *= invScalar;
        } else {
          this.x = 0;
          this.y = 0;
        }
        return this;
      },
      min: function(v) {
        if (this.x > v.x) {
          this.x = v.x;
        }
        if (this.y > v.y) {
          this.y = v.y;
        }
        return this;
      },
      max: function(v) {
        if (this.x < v.x) {
          this.x = v.x;
        }
        if (this.y < v.y) {
          this.y = v.y;
        }
        return this;
      },
      clamp: function(min, max) {
        if (this.x < min.x) {
          this.x = min.x;
        } else if (this.x > max.x) {
          this.x = max.x;
        }
        if (this.y < min.y) {
          this.y = min.y;
        } else if (this.y > max.y) {
          this.y = max.y;
        }
        return this;
      },
      clampScalar: (function() {
        var min,
            max;
        return function(minVal, maxVal) {
          if (min === undefined) {
            min = new THREE.Vector2();
            max = new THREE.Vector2();
          }
          min.set(minVal, minVal);
          max.set(maxVal, maxVal);
          return this.clamp(min, max);
        };
      })(),
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      },
      roundToZero: function() {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      normalize: function() {
        return this.divideScalar(this.length());
      },
      distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
      },
      distanceToSquared: function(v) {
        var dx = this.x - v.x,
            dy = this.y - v.y;
        return dx * dx + dy * dy;
      },
      setLength: function(l) {
        var oldLength = this.length();
        if (oldLength !== 0 && l !== oldLength) {
          this.multiplyScalar(l / oldLength);
        }
        return this;
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
      },
      equals: function(v) {
        return ((v.x === this.x) && (v.y === this.y));
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
      },
      fromAttribute: function(attribute, index, offset) {
        if (offset === undefined)
          offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        return this;
      },
      clone: function() {
        return new THREE.Vector2(this.x, this.y);
      }
    };
    THREE.Vector3 = function(x, y, z) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
    };
    THREE.Vector3.prototype = {
      constructor: THREE.Vector3,
      set: function(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setZ: function(z) {
        this.z = z;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
      },
      add: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      },
      addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
      },
      sub: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      },
      subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
      },
      multiply: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
          return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
      },
      multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      },
      multiplyVectors: function(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
      },
      applyEuler: function() {
        var quaternion;
        return function(euler) {
          if (euler instanceof THREE.Euler === false) {
            THREE.error('THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.');
          }
          if (quaternion === undefined)
            quaternion = new THREE.Quaternion();
          this.applyQuaternion(quaternion.setFromEuler(euler));
          return this;
        };
      }(),
      applyAxisAngle: function() {
        var quaternion;
        return function(axis, angle) {
          if (quaternion === undefined)
            quaternion = new THREE.Quaternion();
          this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
          return this;
        };
      }(),
      applyMatrix3: function(m) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
      },
      applyMatrix4: function(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
        return this;
      },
      applyProjection: function(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
        return this;
      },
      applyQuaternion: function(q) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var qx = q.x;
        var qy = q.y;
        var qz = q.z;
        var qw = q.w;
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
      },
      project: function() {
        var matrix;
        return function(camera) {
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          matrix.multiplyMatrices(camera.projectionMatrix, matrix.getInverse(camera.matrixWorld));
          return this.applyProjection(matrix);
        };
      }(),
      unproject: function() {
        var matrix;
        return function(camera) {
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
          return this.applyProjection(matrix);
        };
      }(),
      transformDirection: function(m) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        this.normalize();
        return this;
      },
      divide: function(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
      },
      divideScalar: function(scalar) {
        if (scalar !== 0) {
          var invScalar = 1 / scalar;
          this.x *= invScalar;
          this.y *= invScalar;
          this.z *= invScalar;
        } else {
          this.x = 0;
          this.y = 0;
          this.z = 0;
        }
        return this;
      },
      min: function(v) {
        if (this.x > v.x) {
          this.x = v.x;
        }
        if (this.y > v.y) {
          this.y = v.y;
        }
        if (this.z > v.z) {
          this.z = v.z;
        }
        return this;
      },
      max: function(v) {
        if (this.x < v.x) {
          this.x = v.x;
        }
        if (this.y < v.y) {
          this.y = v.y;
        }
        if (this.z < v.z) {
          this.z = v.z;
        }
        return this;
      },
      clamp: function(min, max) {
        if (this.x < min.x) {
          this.x = min.x;
        } else if (this.x > max.x) {
          this.x = max.x;
        }
        if (this.y < min.y) {
          this.y = min.y;
        } else if (this.y > max.y) {
          this.y = max.y;
        }
        if (this.z < min.z) {
          this.z = min.z;
        } else if (this.z > max.z) {
          this.z = max.z;
        }
        return this;
      },
      clampScalar: (function() {
        var min,
            max;
        return function(minVal, maxVal) {
          if (min === undefined) {
            min = new THREE.Vector3();
            max = new THREE.Vector3();
          }
          min.set(minVal, minVal, minVal);
          max.set(maxVal, maxVal, maxVal);
          return this.clamp(min, max);
        };
      })(),
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      },
      roundToZero: function() {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      },
      lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      },
      normalize: function() {
        return this.divideScalar(this.length());
      },
      setLength: function(l) {
        var oldLength = this.length();
        if (oldLength !== 0 && l !== oldLength) {
          this.multiplyScalar(l / oldLength);
        }
        return this;
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
      },
      cross: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
          return this.crossVectors(v, w);
        }
        var x = this.x,
            y = this.y,
            z = this.z;
        this.x = y * v.z - z * v.y;
        this.y = z * v.x - x * v.z;
        this.z = x * v.y - y * v.x;
        return this;
      },
      crossVectors: function(a, b) {
        var ax = a.x,
            ay = a.y,
            az = a.z;
        var bx = b.x,
            by = b.y,
            bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      },
      projectOnVector: function() {
        var v1,
            dot;
        return function(vector) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          v1.copy(vector).normalize();
          dot = this.dot(v1);
          return this.copy(v1).multiplyScalar(dot);
        };
      }(),
      projectOnPlane: function() {
        var v1;
        return function(planeNormal) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          v1.copy(this).projectOnVector(planeNormal);
          return this.sub(v1);
        };
      }(),
      reflect: function() {
        var v1;
        return function(normal) {
          if (v1 === undefined)
            v1 = new THREE.Vector3();
          return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
        };
      }(),
      angleTo: function(v) {
        var theta = this.dot(v) / (this.length() * v.length());
        return Math.acos(THREE.Math.clamp(theta, -1, 1));
      },
      distanceTo: function(v) {
        return Math.sqrt(this.distanceToSquared(v));
      },
      distanceToSquared: function(v) {
        var dx = this.x - v.x;
        var dy = this.y - v.y;
        var dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
      },
      setEulerFromRotationMatrix: function(m, order) {
        THREE.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
      },
      setEulerFromQuaternion: function(q, order) {
        THREE.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
      },
      getPositionFromMatrix: function(m) {
        THREE.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
        return this.setFromMatrixPosition(m);
      },
      getScaleFromMatrix: function(m) {
        THREE.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
        return this.setFromMatrixScale(m);
      },
      getColumnFromMatrix: function(index, matrix) {
        THREE.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
        return this.setFromMatrixColumn(index, matrix);
      },
      setFromMatrixPosition: function(m) {
        this.x = m.elements[12];
        this.y = m.elements[13];
        this.z = m.elements[14];
        return this;
      },
      setFromMatrixScale: function(m) {
        var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();
        var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();
        var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      },
      setFromMatrixColumn: function(index, matrix) {
        var offset = index * 4;
        var me = matrix.elements;
        this.x = me[offset];
        this.y = me[offset + 1];
        this.z = me[offset + 2];
        return this;
      },
      equals: function(v) {
        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
      },
      fromAttribute: function(attribute, index, offset) {
        if (offset === undefined)
          offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        return this;
      },
      clone: function() {
        return new THREE.Vector3(this.x, this.y, this.z);
      }
    };
    THREE.Vector4 = function(x, y, z, w) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.w = (w !== undefined) ? w : 1;
    };
    THREE.Vector4.prototype = {
      constructor: THREE.Vector4,
      set: function(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      },
      setX: function(x) {
        this.x = x;
        return this;
      },
      setY: function(y) {
        this.y = y;
        return this;
      },
      setZ: function(z) {
        this.z = z;
        return this;
      },
      setW: function(w) {
        this.w = w;
        return this;
      },
      setComponent: function(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          case 3:
            this.w = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      getComponent: function(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error('index is out of range: ' + index);
        }
      },
      copy: function(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = (v.w !== undefined) ? v.w : 1;
        return this;
      },
      add: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
      },
      addScalar: function(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
      },
      addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
      },
      sub: function(v, w) {
        if (w !== undefined) {
          THREE.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
      },
      subScalar: function(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
      },
      subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
      },
      multiplyScalar: function(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
      },
      applyMatrix4: function(m) {
        var x = this.x;
        var y = this.y;
        var z = this.z;
        var w = this.w;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
      },
      divideScalar: function(scalar) {
        if (scalar !== 0) {
          var invScalar = 1 / scalar;
          this.x *= invScalar;
          this.y *= invScalar;
          this.z *= invScalar;
          this.w *= invScalar;
        } else {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 1;
        }
        return this;
      },
      setAxisAngleFromQuaternion: function(q) {
        this.w = 2 * Math.acos(q.w);
        var s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
          this.x = 1;
          this.y = 0;
          this.z = 0;
        } else {
          this.x = q.x / s;
          this.y = q.y / s;
          this.z = q.z / s;
        }
        return this;
      },
      setAxisAngleFromRotationMatrix: function(m) {
        var angle,
            x,
            y,
            z,
            epsilon = 0.01,
            epsilon2 = 0.1,
            te = m.elements,
            m11 = te[0],
            m12 = te[4],
            m13 = te[8],
            m21 = te[1],
            m22 = te[5],
            m23 = te[9],
            m31 = te[2],
            m32 = te[6],
            m33 = te[10];
        if ((Math.abs(m12 - m21) < epsilon) && (Math.abs(m13 - m31) < epsilon) && (Math.abs(m23 - m32) < epsilon)) {
          if ((Math.abs(m12 + m21) < epsilon2) && (Math.abs(m13 + m31) < epsilon2) && (Math.abs(m23 + m32) < epsilon2) && (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
            this.set(1, 0, 0, 0);
            return this;
          }
          angle = Math.PI;
          var xx = (m11 + 1) / 2;
          var yy = (m22 + 1) / 2;
          var zz = (m33 + 1) / 2;
          var xy = (m12 + m21) / 4;
          var xz = (m13 + m31) / 4;
          var yz = (m23 + m32) / 4;
          if ((xx > yy) && (xx > zz)) {
            if (xx < epsilon) {
              x = 0;
              y = 0.707106781;
              z = 0.707106781;
            } else {
              x = Math.sqrt(xx);
              y = xy / x;
              z = xz / x;
            }
          } else if (yy > zz) {
            if (yy < epsilon) {
              x = 0.707106781;
              y = 0;
              z = 0.707106781;
            } else {
              y = Math.sqrt(yy);
              x = xy / y;
              z = yz / y;
            }
          } else {
            if (zz < epsilon) {
              x = 0.707106781;
              y = 0.707106781;
              z = 0;
            } else {
              z = Math.sqrt(zz);
              x = xz / z;
              y = yz / z;
            }
          }
          this.set(x, y, z, angle);
          return this;
        }
        var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s) < 0.001)
          s = 1;
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
      },
      min: function(v) {
        if (this.x > v.x) {
          this.x = v.x;
        }
        if (this.y > v.y) {
          this.y = v.y;
        }
        if (this.z > v.z) {
          this.z = v.z;
        }
        if (this.w > v.w) {
          this.w = v.w;
        }
        return this;
      },
      max: function(v) {
        if (this.x < v.x) {
          this.x = v.x;
        }
        if (this.y < v.y) {
          this.y = v.y;
        }
        if (this.z < v.z) {
          this.z = v.z;
        }
        if (this.w < v.w) {
          this.w = v.w;
        }
        return this;
      },
      clamp: function(min, max) {
        if (this.x < min.x) {
          this.x = min.x;
        } else if (this.x > max.x) {
          this.x = max.x;
        }
        if (this.y < min.y) {
          this.y = min.y;
        } else if (this.y > max.y) {
          this.y = max.y;
        }
        if (this.z < min.z) {
          this.z = min.z;
        } else if (this.z > max.z) {
          this.z = max.z;
        }
        if (this.w < min.w) {
          this.w = min.w;
        } else if (this.w > max.w) {
          this.w = max.w;
        }
        return this;
      },
      clampScalar: (function() {
        var min,
            max;
        return function(minVal, maxVal) {
          if (min === undefined) {
            min = new THREE.Vector4();
            max = new THREE.Vector4();
          }
          min.set(minVal, minVal, minVal, minVal);
          max.set(maxVal, maxVal, maxVal, maxVal);
          return this.clamp(min, max);
        };
      })(),
      floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
      },
      ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
      },
      round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
      },
      roundToZero: function() {
        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
      },
      negate: function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      },
      dot: function(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      },
      lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      },
      length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      },
      lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      },
      normalize: function() {
        return this.divideScalar(this.length());
      },
      setLength: function(l) {
        var oldLength = this.length();
        if (oldLength !== 0 && l !== oldLength) {
          this.multiplyScalar(l / oldLength);
        }
        return this;
      },
      lerp: function(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
      },
      lerpVectors: function(v1, v2, alpha) {
        this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
        return this;
      },
      equals: function(v) {
        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
      },
      fromArray: function(array, offset) {
        if (offset === undefined)
          offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
      },
      fromAttribute: function(attribute, index, offset) {
        if (offset === undefined)
          offset = 0;
        index = index * attribute.itemSize + offset;
        this.x = attribute.array[index];
        this.y = attribute.array[index + 1];
        this.z = attribute.array[index + 2];
        this.w = attribute.array[index + 3];
        return this;
      },
      clone: function() {
        return new THREE.Vector4(this.x, this.y, this.z, this.w);
      }
    };
    THREE.Euler = function(x, y, z, order) {
      this._x = x || 0;
      this._y = y || 0;
      this._z = z || 0;
      this._order = order || THREE.Euler.DefaultOrder;
    };
    THREE.Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
    THREE.Euler.DefaultOrder = 'XYZ';
    THREE.Euler.prototype = {
      constructor: THREE.Euler,
      _x: 0,
      _y: 0,
      _z: 0,
      _order: THREE.Euler.DefaultOrder,
      get x() {
        return this._x;
      },
      set x(value) {
        this._x = value;
        this.onChangeCallback();
      },
      get y() {
        return this._y;
      },
      set y(value) {
        this._y = value;
        this.onChangeCallback();
      },
      get z() {
        return this._z;
      },
      set z(value) {
        this._z = value;
        this.onChangeCallback();
      },
      get order() {
        return this._order;
      },
      set order(value) {
        this._order = value;
        this.onChangeCallback();
      },
      set: function(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this.onChangeCallback();
        return this;
      },
      copy: function(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this.onChangeCallback();
        return this;
      },
      setFromRotationMatrix: function(m, order, update) {
        var clamp = THREE.Math.clamp;
        var te = m.elements;
        var m11 = te[0],
            m12 = te[4],
            m13 = te[8];
        var m21 = te[1],
            m22 = te[5],
            m23 = te[9];
        var m31 = te[2],
            m32 = te[6],
            m33 = te[10];
        order = order || this._order;
        if (order === 'XYZ') {
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.99999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
        } else if (order === 'YXZ') {
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.99999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
        } else if (order === 'ZXY') {
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.99999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
        } else if (order === 'ZYX') {
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.99999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
        } else if (order === 'YZX') {
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.99999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
        } else if (order === 'XZY') {
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.99999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
        } else {
          THREE.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order);
        }
        this._order = order;
        if (update !== false)
          this.onChangeCallback();
        return this;
      },
      setFromQuaternion: function() {
        var matrix;
        return function(q, order, update) {
          if (matrix === undefined)
            matrix = new THREE.Matrix4();
          matrix.makeRotationFromQuaternion(q);
          this.setFromRotationMatrix(matrix, order, update);
          return this;
        };
      }(),
      setFromVector3: function(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
      },
      reorder: function() {
        var q = new THREE.Quaternion();
        return function(newOrder) {
          q.setFromEuler(this);
          this.setFromQuaternion(q, newOrder);
        };
      }(),
      equals: function(euler) {
        return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
      },
      fromArray: function(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined)
          this._order = array[3];
        this.onChangeCallback();
        return this;
      },
      toArray: function(array, offset) {
        if (array === undefined)
          array = [];
        if (offset === undefined)
          offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
      },
      toVector3: function(optionalResult) {
        if (optionalResult) {
          return optionalResult.set(this._x, this._y, this._z);
        } else {
          return new THREE.Vector3(this._x, this._y, this._z);
        }
      },
      onChange: function(callback) {
        this.onChangeCallback = callback;
        return this;
      },
      onChangeCallback: function() {},
      clone: function() {
        return new THREE.Euler(this._x, this._y, this._z, this._order);
      }
    };
    THREE.Line3 = function(start, end) {
      this.start = (start !== undefined) ? start : new THREE.Vector3();
      this.end = (end !== undefined) ? end : new THREE.Vector3();
    };
    THREE.Line3.prototype = {
      constructor: THREE.Line3,
      set: function(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
      },
      copy: function(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
      },
      center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.start, this.end).multiplyScalar(0.5);
      },
      delta: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors(this.end, this.start);
      },
      distanceSq: function() {
        return this.start.distanceToSquared(this.end);
      },
      distance: function() {
        return this.start.distanceTo(this.end);
      },
      at: function(t, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return this.delta(result).multiplyScalar(t).add(this.start);
      },
      closestPointToPointParameter: function() {
        var startP = new THREE.Vector3();
        var startEnd = new THREE.Vector3();
        return function(point, clampToLine) {
          startP.subVectors(point, this.start);
          startEnd.subVectors(this.end, this.start);
          var startEnd2 = startEnd.dot(startEnd);
          var startEnd_startP = startEnd.dot(startP);
          var t = startEnd_startP / startEnd2;
          if (clampToLine) {
            t = THREE.Math.clamp(t, 0, 1);
          }
          return t;
        };
      }(),
      closestPointToPoint: function(point, clampToLine, optionalTarget) {
        var t = this.closestPointToPointParameter(point, clampToLine);
        var result = optionalTarget || new THREE.Vector3();
        return this.delta(result).multiplyScalar(t).add(this.start);
      },
      applyMatrix4: function(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
      },
      equals: function(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
      },
      clone: function() {
        return new THREE.Line3().copy(this);
      }
    };
    THREE.Box2 = function(min, max) {
      this.min = (min !== undefined) ? min : new THREE.Vector2(Infinity, Infinity);
      this.max = (max !== undefined) ? max : new THREE.Vector2(-Infinity, -Infinity);
    };
    THREE.Box2.prototype = {
      constructor: THREE.Box2,
      set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      },
      setFromPoints: function(points) {
        this.makeEmpty();
        for (var i = 0,
            il = points.length; i < il; i++) {
          this.expandByPoint(points[i]);
        }
        return this;
      },
      setFromCenterAndSize: function() {
        var v1 = new THREE.Vector2();
        return function(center, size) {
          var halfSize = v1.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        };
      }(),
      copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      },
      makeEmpty: function() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
      },
      empty: function() {
        return (this.max.x < this.min.x) || (this.max.y < this.min.y);
      },
      center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      size: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.subVectors(this.max, this.min);
      },
      expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      },
      expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      },
      expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      },
      containsPoint: function(point) {
        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y) {
          return false;
        }
        return true;
      },
      containsBox: function(box) {
        if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) && (this.min.y <= box.min.y) && (box.max.y <= this.max.y)) {
          return true;
        }
        return false;
      },
      getParameter: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
      },
      isIntersectionBox: function(box) {
        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y) {
          return false;
        }
        return true;
      },
      clampPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector2();
        return result.copy(point).clamp(this.min, this.max);
      },
      distanceToPoint: function() {
        var v1 = new THREE.Vector2();
        return function(point) {
          var clampedPoint = v1.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        };
      }(),
      intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      },
      union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      },
      translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      },
      equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      },
      clone: function() {
        return new THREE.Box2().copy(this);
      }
    };
    THREE.Box3 = function(min, max) {
      this.min = (min !== undefined) ? min : new THREE.Vector3(Infinity, Infinity, Infinity);
      this.max = (max !== undefined) ? max : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
    };
    THREE.Box3.prototype = {
      constructor: THREE.Box3,
      set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      },
      setFromPoints: function(points) {
        this.makeEmpty();
        for (var i = 0,
            il = points.length; i < il; i++) {
          this.expandByPoint(points[i]);
        }
        return this;
      },
      setFromCenterAndSize: function() {
        var v1 = new THREE.Vector3();
        return function(center, size) {
          var halfSize = v1.copy(size).multiplyScalar(0.5);
          this.min.copy(center).sub(halfSize);
          this.max.copy(center).add(halfSize);
          return this;
        };
      }(),
      setFromObject: function() {
        var v1 = new THREE.Vector3();
        return function(object) {
          var scope = this;
          object.updateMatrixWorld(true);
          this.makeEmpty();
          object.traverse(function(node) {
            var geometry = node.geometry;
            if (geometry !== undefined) {
              if (geometry instanceof THREE.Geometry) {
                var vertices = geometry.vertices;
                for (var i = 0,
                    il = vertices.length; i < il; i++) {
                  v1.copy(vertices[i]);
                  v1.applyMatrix4(node.matrixWorld);
                  scope.expandByPoint(v1);
                }
              } else if (geometry instanceof THREE.BufferGeometry && geometry.attributes['position'] !== undefined) {
                var positions = geometry.attributes['position'].array;
                for (var i = 0,
                    il = positions.length; i < il; i += 3) {
                  v1.set(positions[i], positions[i + 1], positions[i + 2]);
                  v1.applyMatrix4(node.matrixWorld);
                  scope.expandByPoint(v1);
                }
              }
            }
          });
          return this;
        };
      }(),
      copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      },
      makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
      },
      empty: function() {
        return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
      },
      center: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.min, this.max).multiplyScalar(0.5);
      },
      size: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.subVectors(this.max, this.min);
      },
      expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      },
      expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      },
      expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      },
      containsPoint: function(point) {
        if (point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z) {
          return false;
        }
        return true;
      },
      containsBox: function(box) {
        if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) && (this.min.y <= box.min.y) && (box.max.y <= this.max.y) && (this.min.z <= box.min.z) && (box.max.z <= this.max.z)) {
          return true;
        }
        return false;
      },
      getParameter: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
      },
      isIntersectionBox: function(box) {
        if (box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z) {
          return false;
        }
        return true;
      },
      clampPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(point).clamp(this.min, this.max);
      },
      distanceToPoint: function() {
        var v1 = new THREE.Vector3();
        return function(point) {
          var clampedPoint = v1.copy(point).clamp(this.min, this.max);
          return clampedPoint.sub(point).length();
        };
      }(),
      getBoundingSphere: function() {
        var v1 = new THREE.Vector3();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Sphere();
          result.center = this.center();
          result.radius = this.size(v1).length() * 0.5;
          return result;
        };
      }(),
      intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      },
      union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      },
      applyMatrix4: function() {
        var points = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
        return function(matrix) {
          points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
          points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
          points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
          points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
          points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
          points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
          points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
          points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
          this.makeEmpty();
          this.setFromPoints(points);
          return this;
        };
      }(),
      translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      },
      equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      },
      clone: function() {
        return new THREE.Box3().copy(this);
      }
    };
    THREE.Matrix3 = function() {
      this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      if (arguments.length > 0) {
        THREE.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
      }
    };
    THREE.Matrix3.prototype = {
      constructor: THREE.Matrix3,
      set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this.elements;
        te[0] = n11;
        te[3] = n12;
        te[6] = n13;
        te[1] = n21;
        te[4] = n22;
        te[7] = n23;
        te[2] = n31;
        te[5] = n32;
        te[8] = n33;
        return this;
      },
      identity: function() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      },
      copy: function(m) {
        var me = m.elements;
        this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
        return this;
      },
      multiplyVector3: function(vector) {
        THREE.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
        return vector.applyMatrix3(this);
      },
      multiplyVector3Array: function(a) {
        THREE.warn('THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
        return this.applyToVector3Array(a);
      },
      applyToVector3Array: function() {
        var v1 = new THREE.Vector3();
        return function(array, offset, length) {
          if (offset === undefined)
            offset = 0;
          if (length === undefined)
            length = array.length;
          for (var i = 0,
              j = offset; i < length; i += 3, j += 3) {
            v1.x = array[j];
            v1.y = array[j + 1];
            v1.z = array[j + 2];
            v1.applyMatrix3(this);
            array[j] = v1.x;
            array[j + 1] = v1.y;
            array[j + 2] = v1.z;
          }
          return array;
        };
      }(),
      multiplyScalar: function(s) {
        var te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
      },
      determinant: function() {
        var te = this.elements;
        var a = te[0],
            b = te[1],
            c = te[2],
            d = te[3],
            e = te[4],
            f = te[5],
            g = te[6],
            h = te[7],
            i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
      },
      getInverse: function(matrix, throwOnInvertible) {
        var me = matrix.elements;
        var te = this.elements;
        te[0] = me[10] * me[5] - me[6] * me[9];
        te[1] = -me[10] * me[1] + me[2] * me[9];
        te[2] = me[6] * me[1] - me[2] * me[5];
        te[3] = -me[10] * me[4] + me[6] * me[8];
        te[4] = me[10] * me[0] - me[2] * me[8];
        te[5] = -me[6] * me[0] + me[2] * me[4];
        te[6] = me[9] * me[4] - me[5] * me[8];
        te[7] = -me[9] * me[0] + me[1] * me[8];
        te[8] = me[5] * me[0] - me[1] * me[4];
        var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];
        if (det === 0) {
          var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
          if (throwOnInvertible || false) {
            throw new Error(msg);
          } else {
            THREE.warn(msg);
          }
          this.identity();
          return this;
        }
        this.multiplyScalar(1.0 / det);
        return this;
      },
      transpose: function() {
        var tmp,
            m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
      },
      flattenToArrayOffset: function(array, offset) {
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
      },
      getNormalMatrix: function(m) {
        this.getInverse(m).transpose();
        return this;
      },
      transposeIntoArray: function(r) {
        var m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
      },
      fromArray: function(array) {
        this.elements.set(array);
        return this;
      },
      toArray: function() {
        var te = this.elements;
        return [te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8]];
      },
      clone: function() {
        return new THREE.Matrix3().fromArray(this.elements);
      }
    };
    THREE.Matrix4 = function() {
      this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      if (arguments.length > 0) {
        THREE.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
      }
    };
    THREE.Matrix4.prototype = {
      constructor: THREE.Matrix4,
      set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
      },
      identity: function() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      },
      copy: function(m) {
        this.elements.set(m.elements);
        return this;
      },
      extractPosition: function(m) {
        THREE.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
        return this.copyPosition(m);
      },
      copyPosition: function(m) {
        var te = this.elements;
        var me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
      },
      extractBasis: function(xAxis, yAxis, zAxis) {
        var te = this.elements;
        xAxis.set(te[0], te[1], te[2]);
        yAxis.set(te[4], te[5], te[6]);
        zAxis.set(te[8], te[9], te[10]);
        return this;
      },
      makeBasis: function(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
      },
      extractRotation: function() {
        var v1 = new THREE.Vector3();
        return function(m) {
          var te = this.elements;
          var me = m.elements;
          var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();
          var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();
          var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();
          te[0] = me[0] * scaleX;
          te[1] = me[1] * scaleX;
          te[2] = me[2] * scaleX;
          te[4] = me[4] * scaleY;
          te[5] = me[5] * scaleY;
          te[6] = me[6] * scaleY;
          te[8] = me[8] * scaleZ;
          te[9] = me[9] * scaleZ;
          te[10] = me[10] * scaleZ;
          return this;
        };
      }(),
      makeRotationFromEuler: function(euler) {
        if (euler instanceof THREE.Euler === false) {
          THREE.error('THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        }
        var te = this.elements;
        var x = euler.x,
            y = euler.y,
            z = euler.z;
        var a = Math.cos(x),
            b = Math.sin(x);
        var c = Math.cos(y),
            d = Math.sin(y);
        var e = Math.cos(z),
            f = Math.sin(z);
        if (euler.order === 'XYZ') {
          var ae = a * e,
              af = a * f,
              be = b * e,
              bf = b * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
        } else if (euler.order === 'YXZ') {
          var ce = c * e,
              cf = c * f,
              de = d * e,
              df = d * f;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
        } else if (euler.order === 'ZXY') {
          var ce = c * e,
              cf = c * f,
              de = d * e,
              df = d * f;
          te[0] = ce - df * b;
          te[4] = -a * f;
          te[8] = de + cf * b;
          te[1] = cf + de * b;
          te[5] = a * e;
          te[9] = df - ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
        } else if (euler.order === 'ZYX') {
          var ae = a * e,
              af = a * f,
              be = b * e,
              bf = b * f;
          te[0] = c * e;
          te[4] = be * d - af;
          te[8] = ae * d + bf;
          te[1] = c * f;
          te[5] = bf * d + ae;
          te[9] = af * d - be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
        } else if (euler.order === 'YZX') {
          var ac = a * c,
              ad = a * d,
              bc = b * c,
              bd = b * d;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
        } else if (euler.order === 'XZY') {
          var ac = a * c,
              ad = a * d,
              bc = b * c,
              bd = b * d;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d * e;
          te[1] = ac * f + bd;
          te[5] = a * e;
          te[9] = ad * f - bc;
          te[2] = bc * f - ad;
          te[6] = b * e;
          te[10] = bd * f + ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      },
      setRotationFromQuaternion: function(q) {
        THREE.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
        return this.makeRotationFromQuaternion(q);
      },
      makeRotationFromQuaternion: function(q) {
        var te = this.elements;
        var x = q.x,
            y = q.y,
            z = q.z,
            w = q.w;
        var x2 = x + x,
            y2 = y + y,
            z2 = z + z;
        var xx = x * x2,
            xy = x * y2,
            xz = x * z2;
        var yy = y * y2,
            yz = y * z2,
            zz = z * z2;
        var wx = w * x2,
            wy = w * y2,
            wz = w * z2;
        te[0] = 1 - (yy + zz);
        te[4] = xy - wz;
        te[8] = xz + wy;
        te[1] = xy + wz;
        te[5] = 1 - (xx + zz);
        te[9] = yz - wx;
        te[2] = xz - wy;
        te[6] = yz + wx;
        te[10] = 1 - (xx + yy);
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      },
      lookAt: function() {
        var x = new THREE.Vector3();
        var y = new THREE.Vector3();
        var z = new THREE.Vector3();
        return function(eye, target, up) {
          var te = this.elements;
          z.subVectors(eye, target).normalize();
          if (z.length() === 0) {
            z.z = 1;
          }
          x.crossVectors(up, z).normalize();
          if (x.length() === 0) {
            z.x += 0.0001;
            x.crossVectors(up, z).normalize();
          }
          y.crossVectors(z, x);
          te[0] = x.x;
          te[4] = y.x;
          te[8] = z.x;
          te[1] = x.y;
          te[5] = y.y;
          te[9] = z.y;
          te[2] = x.z;
          te[6] = y.z;
          te[10] = z.z;
          return this;
        };
      }(),
      multiply: function(m, n) {
        if (n !== undefined) {
          THREE.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
          return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
      },
      multiplyMatrices: function(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0],
            a12 = ae[4],
            a13 = ae[8],
            a14 = ae[12];
        var a21 = ae[1],
            a22 = ae[5],
            a23 = ae[9],
            a24 = ae[13];
        var a31 = ae[2],
            a32 = ae[6],
            a33 = ae[10],
            a34 = ae[14];
        var a41 = ae[3],
            a42 = ae[7],
            a43 = ae[11],
            a44 = ae[15];
        var b11 = be[0],
            b12 = be[4],
            b13 = be[8],
            b14 = be[12];
        var b21 = be[1],
            b22 = be[5],
            b23 = be[9],
            b24 = be[13];
        var b31 = be[2],
            b32 = be[6],
            b33 = be[10],
            b34 = be[14];
        var b41 = be[3],
            b42 = be[7],
            b43 = be[11],
            b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      },
      multiplyToArray: function(a, b, r) {
        var te = this.elements;
        this.multiplyMatrices(a, b);
        r[0] = te[0];
        r[1] = te[1];
        r[2] = te[2];
        r[3] = te[3];
        r[4] = te[4];
        r[5] = te[5];
        r[6] = te[6];
        r[7] = te[7];
        r[8] = te[8];
        r[9] = te[9];
        r[10] = te[10];
        r[11] = te[11];
        r[12] = te[12];
        r[13] = te[13];
        r[14] = te[14];
        r[15] = te[15];
        return this;
      },
      multiplyScalar: function(s) {
        var te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
      },
      multiplyVector3: function(vector) {
        THREE.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
        return vector.applyProjection(this);
      },
      multiplyVector4: function(vector) {
        THREE.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
      },
      multiplyVector3Array: function(a) {
        THREE.warn('THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.');
        return this.applyToVector3Array(a);
      },
      applyToVector3Array: function() {
        var v1 = new THREE.Vector3();
        return function(array, offset, length) {
          if (offset === undefined)
            offset = 0;
          if (length === undefined)
            length = array.length;
          for (var i = 0,
              j = offset; i < length; i += 3, j += 3) {
            v1.x = array[j];
            v1.y = array[j + 1];
            v1.z = array[j + 2];
            v1.applyMatrix4(this);
            array[j] = v1.x;
            array[j + 1] = v1.y;
            array[j + 2] = v1.z;
          }
          return array;
        };
      }(),
      rotateAxis: function(v) {
        THREE.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
        v.transformDirection(this);
      },
      crossVector: function(vector) {
        THREE.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
        return vector.applyMatrix4(this);
      },
      determinant: function() {
        var te = this.elements;
        var n11 = te[0],
            n12 = te[4],
            n13 = te[8],
            n14 = te[12];
        var n21 = te[1],
            n22 = te[5],
            n23 = te[9],
            n24 = te[13];
        var n31 = te[2],
            n32 = te[6],
            n33 = te[10],
            n34 = te[14];
        var n41 = te[3],
            n42 = te[7],
            n43 = te[11],
            n44 = te[15];
        return (n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31));
      },
      transpose: function() {
        var te = this.elements;
        var tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
      },
      flattenToArrayOffset: function(array, offset) {
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
      },
      getPosition: function() {
        var v1 = new THREE.Vector3();
        return function() {
          THREE.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
          var te = this.elements;
          return v1.set(te[12], te[13], te[14]);
        };
      }(),
      setPosition: function(v) {
        var te = this.elements;
        te[12] = v.x;
        te[13] = v.y;
        te[14] = v.z;
        return this;
      },
      getInverse: function(m, throwOnInvertible) {
        var te = this.elements;
        var me = m.elements;
        var n11 = me[0],
            n12 = me[4],
            n13 = me[8],
            n14 = me[12];
        var n21 = me[1],
            n22 = me[5],
            n23 = me[9],
            n24 = me[13];
        var n31 = me[2],
            n32 = me[6],
            n33 = me[10],
            n34 = me[14];
        var n41 = me[3],
            n42 = me[7],
            n43 = me[11],
            n44 = me[15];
        te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
        te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
        te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
        te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
        te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
        te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
        te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
        te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
        te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
        te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
        te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
        te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
        te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
        te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
        te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
        var det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];
        if (det == 0) {
          var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
          if (throwOnInvertible || false) {
            throw new Error(msg);
          } else {
            THREE.warn(msg);
          }
          this.identity();
          return this;
        }
        this.multiplyScalar(1 / det);
        return this;
      },
      translate: function(v) {
        THREE.error('THREE.Matrix4: .translate() has been removed.');
      },
      rotateX: function(angle) {
        THREE.error('THREE.Matrix4: .rotateX() has been removed.');
      },
      rotateY: function(angle) {
        THREE.error('THREE.Matrix4: .rotateY() has been removed.');
      },
      rotateZ: function(angle) {
        THREE.error('THREE.Matrix4: .rotateZ() has been removed.');
      },
      rotateByAxis: function(axis, angle) {
        THREE.error('THREE.Matrix4: .rotateByAxis() has been removed.');
      },
      scale: function(v) {
        var te = this.elements;
        var x = v.x,
            y = v.y,
            z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
      },
      getMaxScaleOnAxis: function() {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));
      },
      makeTranslation: function(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
      },
      makeRotationX: function(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationY: function(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationZ: function(theta) {
        var c = Math.cos(theta),
            s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      },
      makeRotationAxis: function(axis, angle) {
        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x,
            y = axis.y,
            z = axis.z;
        var tx = t * x,
            ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
      },
      makeScale: function(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
      },
      compose: function(position, quaternion, scale) {
        this.makeRotationFromQuaternion(quaternion);
        this.scale(scale);
        this.setPosition(position);
        return this;
      },
      decompose: function() {
        var vector = new THREE.Vector3();
        var matrix = new THREE.Matrix4();
        return function(position, quaternion, scale) {
          var te = this.elements;
          var sx = vector.set(te[0], te[1], te[2]).length();
          var sy = vector.set(te[4], te[5], te[6]).length();
          var sz = vector.set(te[8], te[9], te[10]).length();
          var det = this.determinant();
          if (det < 0) {
            sx = -sx;
          }
          position.x = te[12];
          position.y = te[13];
          position.z = te[14];
          matrix.elements.set(this.elements);
          var invSX = 1 / sx;
          var invSY = 1 / sy;
          var invSZ = 1 / sz;
          matrix.elements[0] *= invSX;
          matrix.elements[1] *= invSX;
          matrix.elements[2] *= invSX;
          matrix.elements[4] *= invSY;
          matrix.elements[5] *= invSY;
          matrix.elements[6] *= invSY;
          matrix.elements[8] *= invSZ;
          matrix.elements[9] *= invSZ;
          matrix.elements[10] *= invSZ;
          quaternion.setFromRotationMatrix(matrix);
          scale.x = sx;
          scale.y = sy;
          scale.z = sz;
          return this;
        };
      }(),
      makeFrustum: function(left, right, bottom, top, near, far) {
        var te = this.elements;
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c = -(far + near) / (far - near);
        var d = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
      },
      makePerspective: function(fov, aspect, near, far) {
        var ymax = near * Math.tan(THREE.Math.degToRad(fov * 0.5));
        var ymin = -ymax;
        var xmin = ymin * aspect;
        var xmax = ymax * aspect;
        return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
      },
      makeOrthographic: function(left, right, top, bottom, near, far) {
        var te = this.elements;
        var w = right - left;
        var h = top - bottom;
        var p = far - near;
        var x = (right + left) / w;
        var y = (top + bottom) / h;
        var z = (far + near) / p;
        te[0] = 2 / w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 / h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 / p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
      },
      fromArray: function(array) {
        this.elements.set(array);
        return this;
      },
      toArray: function() {
        var te = this.elements;
        return [te[0], te[1], te[2], te[3], te[4], te[5], te[6], te[7], te[8], te[9], te[10], te[11], te[12], te[13], te[14], te[15]];
      },
      clone: function() {
        return new THREE.Matrix4().fromArray(this.elements);
      }
    };
    THREE.Ray = function(origin, direction) {
      this.origin = (origin !== undefined) ? origin : new THREE.Vector3();
      this.direction = (direction !== undefined) ? direction : new THREE.Vector3();
    };
    THREE.Ray.prototype = {
      constructor: THREE.Ray,
      set: function(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
      },
      copy: function(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
      },
      at: function(t, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.direction).multiplyScalar(t).add(this.origin);
      },
      recast: function() {
        var v1 = new THREE.Vector3();
        return function(t) {
          this.origin.copy(this.at(t, v1));
          return this;
        };
      }(),
      closestPointToPoint: function(point, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        result.subVectors(point, this.origin);
        var directionDistance = result.dot(this.direction);
        if (directionDistance < 0) {
          return result.copy(this.origin);
        }
        return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      },
      distanceToPoint: function() {
        var v1 = new THREE.Vector3();
        return function(point) {
          var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
          if (directionDistance < 0) {
            return this.origin.distanceTo(point);
          }
          v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
          return v1.distanceTo(point);
        };
      }(),
      distanceSqToSegment: function() {
        var segCenter = new THREE.Vector3();
        var segDir = new THREE.Vector3();
        var diff = new THREE.Vector3();
        return function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
          segCenter.copy(v0).add(v1).multiplyScalar(0.5);
          segDir.copy(v1).sub(v0).normalize();
          diff.copy(this.origin).sub(segCenter);
          var segExtent = v0.distanceTo(v1) * 0.5;
          var a01 = -this.direction.dot(segDir);
          var b0 = diff.dot(this.direction);
          var b1 = -diff.dot(segDir);
          var c = diff.lengthSq();
          var det = Math.abs(1 - a01 * a01);
          var s0,
              s1,
              sqrDist,
              extDet;
          if (det > 0) {
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
              if (s1 >= -extDet) {
                if (s1 <= extDet) {
                  var invDet = 1 / det;
                  s0 *= invDet;
                  s1 *= invDet;
                  sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                } else {
                  s1 = segExtent;
                  s0 = Math.max(0, -(a01 * s1 + b0));
                  sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
              } else {
                s1 = -segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c;
              } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            }
          } else {
            s1 = (a01 > 0) ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
          if (optionalPointOnRay) {
            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
          }
          if (optionalPointOnSegment) {
            optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
          }
          return sqrDist;
        };
      }(),
      isIntersectionSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) <= sphere.radius;
      },
      intersectSphere: function() {
        var v1 = new THREE.Vector3();
        return function(sphere, optionalTarget) {
          v1.subVectors(sphere.center, this.origin);
          var tca = v1.dot(this.direction);
          var d2 = v1.dot(v1) - tca * tca;
          var radius2 = sphere.radius * sphere.radius;
          if (d2 > radius2)
            return null;
          var thc = Math.sqrt(radius2 - d2);
          var t0 = tca - thc;
          var t1 = tca + thc;
          if (t0 < 0 && t1 < 0)
            return null;
          if (t0 < 0)
            return this.at(t1, optionalTarget);
          return this.at(t0, optionalTarget);
        };
      }(),
      isIntersectionPlane: function(plane) {
        var distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
          return true;
        }
        var denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
          return true;
        }
        return false;
      },
      distanceToPlane: function(plane) {
        var denominator = plane.normal.dot(this.direction);
        if (denominator == 0) {
          if (plane.distanceToPoint(this.origin) == 0) {
            return 0;
          }
          return null;
        }
        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t >= 0 ? t : null;
      },
      intersectPlane: function(plane, optionalTarget) {
        var t = this.distanceToPlane(plane);
        if (t === null) {
          return null;
        }
        return this.at(t, optionalTarget);
      },
      isIntersectionBox: function() {
        var v = new THREE.Vector3();
        return function(box) {
          return this.intersectBox(box, v) !== null;
        };
      }(),
      intersectBox: function(box, optionalTarget) {
        var tmin,
            tmax,
            tymin,
            tymax,
            tzmin,
            tzmax;
        var invdirx = 1 / this.direction.x,
            invdiry = 1 / this.direction.y,
            invdirz = 1 / this.direction.z;
        var origin = this.origin;
        if (invdirx >= 0) {
          tmin = (box.min.x - origin.x) * invdirx;
          tmax = (box.max.x - origin.x) * invdirx;
        } else {
          tmin = (box.max.x - origin.x) * invdirx;
          tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
          tymin = (box.min.y - origin.y) * invdiry;
          tymax = (box.max.y - origin.y) * invdiry;
        } else {
          tymin = (box.max.y - origin.y) * invdiry;
          tymax = (box.min.y - origin.y) * invdiry;
        }
        if ((tmin > tymax) || (tymin > tmax))
          return null;
        if (tymin > tmin || tmin !== tmin)
          tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
          tmax = tymax;
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if ((tmin > tzmax) || (tzmin > tmax))
          return null;
        if (tzmin > tmin || tmin !== tmin)
          tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
          tmax = tzmax;
        if (tmax < 0)
          return null;
        return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
      },
      intersectTriangle: function() {
        var diff = new THREE.Vector3();
        var edge1 = new THREE.Vector3();
        var edge2 = new THREE.Vector3();
        var normal = new THREE.Vector3();
        return function(a, b, c, backfaceCulling, optionalTarget) {
          edge1.subVectors(b, a);
          edge2.subVectors(c, a);
          normal.crossVectors(edge1, edge2);
          var DdN = this.direction.dot(normal);
          var sign;
          if (DdN > 0) {
            if (backfaceCulling)
              return null;
            sign = 1;
          } else if (DdN < 0) {
            sign = -1;
            DdN = -DdN;
          } else {
            return null;
          }
          diff.subVectors(this.origin, a);
          var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
          if (DdQxE2 < 0) {
            return null;
          }
          var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
          if (DdE1xQ < 0) {
            return null;
          }
          if (DdQxE2 + DdE1xQ > DdN) {
            return null;
          }
          var QdN = -sign * diff.dot(normal);
          if (QdN < 0) {
            return null;
          }
          return this.at(QdN / DdN, optionalTarget);
        };
      }(),
      applyMatrix4: function(matrix4) {
        this.direction.add(this.origin).applyMatrix4(matrix4);
        this.origin.applyMatrix4(matrix4);
        this.direction.sub(this.origin);
        this.direction.normalize();
        return this;
      },
      equals: function(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
      },
      clone: function() {
        return new THREE.Ray().copy(this);
      }
    };
    THREE.Sphere = function(center, radius) {
      this.center = (center !== undefined) ? center : new THREE.Vector3();
      this.radius = (radius !== undefined) ? radius : 0;
    };
    THREE.Sphere.prototype = {
      constructor: THREE.Sphere,
      set: function(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
      },
      setFromPoints: function() {
        var box = new THREE.Box3();
        return function(points, optionalCenter) {
          var center = this.center;
          if (optionalCenter !== undefined) {
            center.copy(optionalCenter);
          } else {
            box.setFromPoints(points).center(center);
          }
          var maxRadiusSq = 0;
          for (var i = 0,
              il = points.length; i < il; i++) {
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
          }
          this.radius = Math.sqrt(maxRadiusSq);
          return this;
        };
      }(),
      copy: function(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
      },
      empty: function() {
        return (this.radius <= 0);
      },
      containsPoint: function(point) {
        return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
      },
      distanceToPoint: function(point) {
        return (point.distanceTo(this.center) - this.radius);
      },
      intersectsSphere: function(sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
      },
      clampPoint: function(point, optionalTarget) {
        var deltaLengthSq = this.center.distanceToSquared(point);
        var result = optionalTarget || new THREE.Vector3();
        result.copy(point);
        if (deltaLengthSq > (this.radius * this.radius)) {
          result.sub(this.center).normalize();
          result.multiplyScalar(this.radius).add(this.center);
        }
        return result;
      },
      getBoundingBox: function(optionalTarget) {
        var box = optionalTarget || new THREE.Box3();
        box.set(this.center, this.center);
        box.expandByScalar(this.radius);
        return box;
      },
      applyMatrix4: function(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
      },
      translate: function(offset) {
        this.center.add(offset);
        return this;
      },
      equals: function(sphere) {
        return sphere.center.equals(this.center) && (sphere.radius === this.radius);
      },
      clone: function() {
        return new THREE.Sphere().copy(this);
      }
    };
    THREE.Frustum = function(p0, p1, p2, p3, p4, p5) {
      this.planes = [(p0 !== undefined) ? p0 : new THREE.Plane(), (p1 !== undefined) ? p1 : new THREE.Plane(), (p2 !== undefined) ? p2 : new THREE.Plane(), (p3 !== undefined) ? p3 : new THREE.Plane(), (p4 !== undefined) ? p4 : new THREE.Plane(), (p5 !== undefined) ? p5 : new THREE.Plane()];
    };
    THREE.Frustum.prototype = {
      constructor: THREE.Frustum,
      set: function(p0, p1, p2, p3, p4, p5) {
        var planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
      },
      copy: function(frustum) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          planes[i].copy(frustum.planes[i]);
        }
        return this;
      },
      setFromMatrix: function(m) {
        var planes = this.planes;
        var me = m.elements;
        var me0 = me[0],
            me1 = me[1],
            me2 = me[2],
            me3 = me[3];
        var me4 = me[4],
            me5 = me[5],
            me6 = me[6],
            me7 = me[7];
        var me8 = me[8],
            me9 = me[9],
            me10 = me[10],
            me11 = me[11];
        var me12 = me[12],
            me13 = me[13],
            me14 = me[14],
            me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
      },
      intersectsObject: function() {
        var sphere = new THREE.Sphere();
        return function(object) {
          var geometry = object.geometry;
          if (geometry.boundingSphere === null)
            geometry.computeBoundingSphere();
          sphere.copy(geometry.boundingSphere);
          sphere.applyMatrix4(object.matrixWorld);
          return this.intersectsSphere(sphere);
        };
      }(),
      intersectsSphere: function(sphere) {
        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;
        for (var i = 0; i < 6; i++) {
          var distance = planes[i].distanceToPoint(center);
          if (distance < negRadius) {
            return false;
          }
        }
        return true;
      },
      intersectsBox: function() {
        var p1 = new THREE.Vector3(),
            p2 = new THREE.Vector3();
        return function(box) {
          var planes = this.planes;
          for (var i = 0; i < 6; i++) {
            var plane = planes[i];
            p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
            p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
            p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
            p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            var d1 = plane.distanceToPoint(p1);
            var d2 = plane.distanceToPoint(p2);
            if (d1 < 0 && d2 < 0) {
              return false;
            }
          }
          return true;
        };
      }(),
      containsPoint: function(point) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          if (planes[i].distanceToPoint(point) < 0) {
            return false;
          }
        }
        return true;
      },
      clone: function() {
        return new THREE.Frustum().copy(this);
      }
    };
    THREE.Plane = function(normal, constant) {
      this.normal = (normal !== undefined) ? normal : new THREE.Vector3(1, 0, 0);
      this.constant = (constant !== undefined) ? constant : 0;
    };
    THREE.Plane.prototype = {
      constructor: THREE.Plane,
      set: function(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
      },
      setComponents: function(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
      },
      setFromNormalAndCoplanarPoint: function(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
      },
      setFromCoplanarPoints: function() {
        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        return function(a, b, c) {
          var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
          this.setFromNormalAndCoplanarPoint(normal, a);
          return this;
        };
      }(),
      copy: function(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
      },
      normalize: function() {
        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
      },
      negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this;
      },
      distanceToPoint: function(point) {
        return this.normal.dot(point) + this.constant;
      },
      distanceToSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
      },
      projectPoint: function(point, optionalTarget) {
        return this.orthoPoint(point, optionalTarget).sub(point).negate();
      },
      orthoPoint: function(point, optionalTarget) {
        var perpendicularMagnitude = this.distanceToPoint(point);
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
      },
      isIntersectionLine: function(line) {
        var startSign = this.distanceToPoint(line.start);
        var endSign = this.distanceToPoint(line.end);
        return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
      },
      intersectLine: function() {
        var v1 = new THREE.Vector3();
        return function(line, optionalTarget) {
          var result = optionalTarget || new THREE.Vector3();
          var direction = line.delta(v1);
          var denominator = this.normal.dot(direction);
          if (denominator == 0) {
            if (this.distanceToPoint(line.start) == 0) {
              return result.copy(line.start);
            }
            return undefined;
          }
          var t = -(line.start.dot(this.normal) + this.constant) / denominator;
          if (t < 0 || t > 1) {
            return undefined;
          }
          return result.copy(direction).multiplyScalar(t).add(line.start);
        };
      }(),
      coplanarPoint: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.copy(this.normal).multiplyScalar(-this.constant);
      },
      applyMatrix4: function() {
        var v1 = new THREE.Vector3();
        var v2 = new THREE.Vector3();
        var m1 = new THREE.Matrix3();
        return function(matrix, optionalNormalMatrix) {
          var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
          var newNormal = v1.copy(this.normal).applyMatrix3(normalMatrix);
          var newCoplanarPoint = this.coplanarPoint(v2);
          newCoplanarPoint.applyMatrix4(matrix);
          this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);
          return this;
        };
      }(),
      translate: function(offset) {
        this.constant = this.constant - offset.dot(this.normal);
        return this;
      },
      equals: function(plane) {
        return plane.normal.equals(this.normal) && (plane.constant == this.constant);
      },
      clone: function() {
        return new THREE.Plane().copy(this);
      }
    };
    THREE.Math = {
      generateUUID: function() {
        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
        var uuid = new Array(36);
        var rnd = 0,
            r;
        return function() {
          for (var i = 0; i < 36; i++) {
            if (i == 8 || i == 13 || i == 18 || i == 23) {
              uuid[i] = '-';
            } else if (i == 14) {
              uuid[i] = '4';
            } else {
              if (rnd <= 0x02)
                rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;
              r = rnd & 0xf;
              rnd = rnd >> 4;
              uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
            }
          }
          return uuid.join('');
        };
      }(),
      clamp: function(x, a, b) {
        return (x < a) ? a : ((x > b) ? b : x);
      },
      clampBottom: function(x, a) {
        return x < a ? a : x;
      },
      mapLinear: function(x, a1, a2, b1, b2) {
        return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
      },
      smoothstep: function(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * (3 - 2 * x);
      },
      smootherstep: function(x, min, max) {
        if (x <= min)
          return 0;
        if (x >= max)
          return 1;
        x = (x - min) / (max - min);
        return x * x * x * (x * (x * 6 - 15) + 10);
      },
      random16: function() {
        return (65280 * Math.random() + 255 * Math.random()) / 65535;
      },
      randInt: function(low, high) {
        return Math.floor(this.randFloat(low, high));
      },
      randFloat: function(low, high) {
        return low + Math.random() * (high - low);
      },
      randFloatSpread: function(range) {
        return range * (0.5 - Math.random());
      },
      degToRad: function() {
        var degreeToRadiansFactor = Math.PI / 180;
        return function(degrees) {
          return degrees * degreeToRadiansFactor;
        };
      }(),
      radToDeg: function() {
        var radianToDegreesFactor = 180 / Math.PI;
        return function(radians) {
          return radians * radianToDegreesFactor;
        };
      }(),
      isPowerOfTwo: function(value) {
        return (value & (value - 1)) === 0 && value !== 0;
      },
      nextPowerOfTwo: function(value) {
        value--;
        value |= value >> 1;
        value |= value >> 2;
        value |= value >> 4;
        value |= value >> 8;
        value |= value >> 16;
        value++;
        return value;
      }
    };
    THREE.Spline = function(points) {
      this.points = points;
      var c = [],
          v3 = {
            x: 0,
            y: 0,
            z: 0
          },
          point,
          intPoint,
          weight,
          w2,
          w3,
          pa,
          pb,
          pc,
          pd;
      this.initFromArray = function(a) {
        this.points = [];
        for (var i = 0; i < a.length; i++) {
          this.points[i] = {
            x: a[i][0],
            y: a[i][1],
            z: a[i][2]
          };
        }
      };
      this.getPoint = function(k) {
        point = (this.points.length - 1) * k;
        intPoint = Math.floor(point);
        weight = point - intPoint;
        c[0] = intPoint === 0 ? intPoint : intPoint - 1;
        c[1] = intPoint;
        c[2] = intPoint > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
        c[3] = intPoint > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;
        pa = this.points[c[0]];
        pb = this.points[c[1]];
        pc = this.points[c[2]];
        pd = this.points[c[3]];
        w2 = weight * weight;
        w3 = weight * w2;
        v3.x = interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
        v3.y = interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
        v3.z = interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
        return v3;
      };
      this.getControlPointsArray = function() {
        var i,
            p,
            l = this.points.length,
            coords = [];
        for (i = 0; i < l; i++) {
          p = this.points[i];
          coords[i] = [p.x, p.y, p.z];
        }
        return coords;
      };
      this.getLength = function(nSubDivisions) {
        var i,
            index,
            nSamples,
            position,
            point = 0,
            intPoint = 0,
            oldIntPoint = 0,
            oldPosition = new THREE.Vector3(),
            tmpVec = new THREE.Vector3(),
            chunkLengths = [],
            totalLength = 0;
        chunkLengths[0] = 0;
        if (!nSubDivisions)
          nSubDivisions = 100;
        nSamples = this.points.length * nSubDivisions;
        oldPosition.copy(this.points[0]);
        for (i = 1; i < nSamples; i++) {
          index = i / nSamples;
          position = this.getPoint(index);
          tmpVec.copy(position);
          totalLength += tmpVec.distanceTo(oldPosition);
          oldPosition.copy(position);
          point = (this.points.length - 1) * index;
          intPoint = Math.floor(point);
          if (intPoint != oldIntPoint) {
            chunkLengths[intPoint] = totalLength;
            oldIntPoint = intPoint;
          }
        }
        chunkLengths[chunkLengths.length] = totalLength;
        return {
          chunks: chunkLengths,
          total: totalLength
        };
      };
      this.reparametrizeByArcLength = function(samplingCoef) {
        var i,
            j,
            index,
            indexCurrent,
            indexNext,
            realDistance,
            sampling,
            position,
            newpoints = [],
            tmpVec = new THREE.Vector3(),
            sl = this.getLength();
        newpoints.push(tmpVec.copy(this.points[0]).clone());
        for (i = 1; i < this.points.length; i++) {
          realDistance = sl.chunks[i] - sl.chunks[i - 1];
          sampling = Math.ceil(samplingCoef * realDistance / sl.total);
          indexCurrent = (i - 1) / (this.points.length - 1);
          indexNext = i / (this.points.length - 1);
          for (j = 1; j < sampling - 1; j++) {
            index = indexCurrent + j * (1 / sampling) * (indexNext - indexCurrent);
            position = this.getPoint(index);
            newpoints.push(tmpVec.copy(position).clone());
          }
          newpoints.push(tmpVec.copy(this.points[i]).clone());
        }
        this.points = newpoints;
      };
      function interpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5,
            v1 = (p3 - p1) * 0.5;
        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
      ;
    };
    THREE.Triangle = function(a, b, c) {
      this.a = (a !== undefined) ? a : new THREE.Vector3();
      this.b = (b !== undefined) ? b : new THREE.Vector3();
      this.c = (c !== undefined) ? c : new THREE.Vector3();
    };
    THREE.Triangle.normal = function() {
      var v0 = new THREE.Vector3();
      return function(a, b, c, optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        result.subVectors(c, b);
        v0.subVectors(a, b);
        result.cross(v0);
        var resultLengthSq = result.lengthSq();
        if (resultLengthSq > 0) {
          return result.multiplyScalar(1 / Math.sqrt(resultLengthSq));
        }
        return result.set(0, 0, 0);
      };
    }();
    THREE.Triangle.barycoordFromPoint = function() {
      var v0 = new THREE.Vector3();
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      return function(point, a, b, c, optionalTarget) {
        v0.subVectors(c, a);
        v1.subVectors(b, a);
        v2.subVectors(point, a);
        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);
        var denom = (dot00 * dot11 - dot01 * dot01);
        var result = optionalTarget || new THREE.Vector3();
        if (denom == 0) {
          return result.set(-2, -1, -1);
        }
        var invDenom = 1 / denom;
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return result.set(1 - u - v, v, u);
      };
    }();
    THREE.Triangle.containsPoint = function() {
      var v1 = new THREE.Vector3();
      return function(point, a, b, c) {
        var result = THREE.Triangle.barycoordFromPoint(point, a, b, c, v1);
        return (result.x >= 0) && (result.y >= 0) && ((result.x + result.y) <= 1);
      };
    }();
    THREE.Triangle.prototype = {
      constructor: THREE.Triangle,
      set: function(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
      },
      setFromPointsAndIndices: function(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
      },
      copy: function(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
      },
      area: function() {
        var v0 = new THREE.Vector3();
        var v1 = new THREE.Vector3();
        return function() {
          v0.subVectors(this.c, this.b);
          v1.subVectors(this.a, this.b);
          return v0.cross(v1).length() * 0.5;
        };
      }(),
      midpoint: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        return result.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      },
      normal: function(optionalTarget) {
        return THREE.Triangle.normal(this.a, this.b, this.c, optionalTarget);
      },
      plane: function(optionalTarget) {
        var result = optionalTarget || new THREE.Plane();
        return result.setFromCoplanarPoints(this.a, this.b, this.c);
      },
      barycoordFromPoint: function(point, optionalTarget) {
        return THREE.Triangle.barycoordFromPoint(point, this.a, this.b, this.c, optionalTarget);
      },
      containsPoint: function(point) {
        return THREE.Triangle.containsPoint(point, this.a, this.b, this.c);
      },
      equals: function(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
      },
      clone: function() {
        return new THREE.Triangle().copy(this);
      }
    };
    THREE.Clock = function(autoStart) {
      this.autoStart = (autoStart !== undefined) ? autoStart : true;
      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    };
    THREE.Clock.prototype = {
      constructor: THREE.Clock,
      start: function() {
        this.startTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();
        this.oldTime = this.startTime;
        this.running = true;
      },
      stop: function() {
        this.getElapsedTime();
        this.running = false;
      },
      getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime;
      },
      getDelta: function() {
        var diff = 0;
        if (this.autoStart && !this.running) {
          this.start();
        }
        if (this.running) {
          var newTime = self.performance !== undefined && self.performance.now !== undefined ? self.performance.now() : Date.now();
          diff = 0.001 * (newTime - this.oldTime);
          this.oldTime = newTime;
          this.elapsedTime += diff;
        }
        return diff;
      }
    };
    THREE.EventDispatcher = function() {};
    THREE.EventDispatcher.prototype = {
      constructor: THREE.EventDispatcher,
      apply: function(object) {
        object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
      },
      addEventListener: function(type, listener) {
        if (this._listeners === undefined)
          this._listeners = {};
        var listeners = this._listeners;
        if (listeners[type] === undefined) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      },
      hasEventListener: function(type, listener) {
        if (this._listeners === undefined)
          return false;
        var listeners = this._listeners;
        if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1) {
          return true;
        }
        return false;
      },
      removeEventListener: function(type, listener) {
        if (this._listeners === undefined)
          return;
        var listeners = this._listeners;
        var listenerArray = listeners[type];
        if (listenerArray !== undefined) {
          var index = listenerArray.indexOf(listener);
          if (index !== -1) {
            listenerArray.splice(index, 1);
          }
        }
      },
      dispatchEvent: function(event) {
        if (this._listeners === undefined)
          return;
        var listeners = this._listeners;
        var listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
          event.target = this;
          var array = [];
          var length = listenerArray.length;
          for (var i = 0; i < length; i++) {
            array[i] = listenerArray[i];
          }
          for (var i = 0; i < length; i++) {
            array[i].call(this, event);
          }
        }
      }
    };
    (function(THREE) {
      THREE.Raycaster = function(origin, direction, near, far) {
        this.ray = new THREE.Ray(origin, direction);
        this.near = near || 0;
        this.far = far || Infinity;
        this.params = {
          Sprite: {},
          Mesh: {},
          PointCloud: {threshold: 1},
          LOD: {},
          Line: {}
        };
      };
      var descSort = function(a, b) {
        return a.distance - b.distance;
      };
      var intersectObject = function(object, raycaster, intersects, recursive) {
        object.raycast(raycaster, intersects);
        if (recursive === true) {
          var children = object.children;
          for (var i = 0,
              l = children.length; i < l; i++) {
            intersectObject(children[i], raycaster, intersects, true);
          }
        }
      };
      THREE.Raycaster.prototype = {
        constructor: THREE.Raycaster,
        precision: 0.0001,
        linePrecision: 1,
        set: function(origin, direction) {
          this.ray.set(origin, direction);
        },
        setFromCamera: function(coords, camera) {
          if (camera instanceof THREE.PerspectiveCamera) {
            this.ray.origin.copy(camera.position);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(camera.position).normalize();
          } else if (camera instanceof THREE.OrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, -1).unproject(camera);
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
          } else {
            THREE.error('THREE.Raycaster: Unsupported camera type.');
          }
        },
        intersectObject: function(object, recursive) {
          var intersects = [];
          intersectObject(object, this, intersects, recursive);
          intersects.sort(descSort);
          return intersects;
        },
        intersectObjects: function(objects, recursive) {
          var intersects = [];
          if (objects instanceof Array === false) {
            THREE.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
            return intersects;
          }
          for (var i = 0,
              l = objects.length; i < l; i++) {
            intersectObject(objects[i], this, intersects, recursive);
          }
          intersects.sort(descSort);
          return intersects;
        }
      };
    }(THREE));
    THREE.Object3D = function() {
      Object.defineProperty(this, 'id', {value: THREE.Object3DIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'Object3D';
      this.parent = undefined;
      this.children = [];
      this.up = THREE.Object3D.DefaultUp.clone();
      var position = new THREE.Vector3();
      var rotation = new THREE.Euler();
      var quaternion = new THREE.Quaternion();
      var scale = new THREE.Vector3(1, 1, 1);
      var onRotationChange = function() {
        quaternion.setFromEuler(rotation, false);
      };
      var onQuaternionChange = function() {
        rotation.setFromQuaternion(quaternion, undefined, false);
      };
      rotation.onChange(onRotationChange);
      quaternion.onChange(onQuaternionChange);
      Object.defineProperties(this, {
        position: {
          enumerable: true,
          value: position
        },
        rotation: {
          enumerable: true,
          value: rotation
        },
        quaternion: {
          enumerable: true,
          value: quaternion
        },
        scale: {
          enumerable: true,
          value: scale
        }
      });
      this.rotationAutoUpdate = true;
      this.matrix = new THREE.Matrix4();
      this.matrixWorld = new THREE.Matrix4();
      this.matrixAutoUpdate = true;
      this.matrixWorldNeedsUpdate = false;
      this.visible = true;
      this.castShadow = false;
      this.receiveShadow = false;
      this.frustumCulled = true;
      this.renderOrder = 0;
      this.userData = {};
    };
    THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
    THREE.Object3D.prototype = {
      constructor: THREE.Object3D,
      get eulerOrder() {
        THREE.warn('THREE.Object3D: .eulerOrder has been moved to .rotation.order.');
        return this.rotation.order;
      },
      set eulerOrder(value) {
        THREE.warn('THREE.Object3D: .eulerOrder has been moved to .rotation.order.');
        this.rotation.order = value;
      },
      get useQuaternion() {
        THREE.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
      },
      set useQuaternion(value) {
        THREE.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
      },
      applyMatrix: function(matrix) {
        this.matrix.multiplyMatrices(matrix, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      },
      setRotationFromAxisAngle: function(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
      },
      setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
      },
      setRotationFromMatrix: function(m) {
        this.quaternion.setFromRotationMatrix(m);
      },
      setRotationFromQuaternion: function(q) {
        this.quaternion.copy(q);
      },
      rotateOnAxis: function() {
        var q1 = new THREE.Quaternion();
        return function(axis, angle) {
          q1.setFromAxisAngle(axis, angle);
          this.quaternion.multiply(q1);
          return this;
        };
      }(),
      rotateX: function() {
        var v1 = new THREE.Vector3(1, 0, 0);
        return function(angle) {
          return this.rotateOnAxis(v1, angle);
        };
      }(),
      rotateY: function() {
        var v1 = new THREE.Vector3(0, 1, 0);
        return function(angle) {
          return this.rotateOnAxis(v1, angle);
        };
      }(),
      rotateZ: function() {
        var v1 = new THREE.Vector3(0, 0, 1);
        return function(angle) {
          return this.rotateOnAxis(v1, angle);
        };
      }(),
      translateOnAxis: function() {
        var v1 = new THREE.Vector3();
        return function(axis, distance) {
          v1.copy(axis).applyQuaternion(this.quaternion);
          this.position.add(v1.multiplyScalar(distance));
          return this;
        };
      }(),
      translate: function(distance, axis) {
        THREE.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
        return this.translateOnAxis(axis, distance);
      },
      translateX: function() {
        var v1 = new THREE.Vector3(1, 0, 0);
        return function(distance) {
          return this.translateOnAxis(v1, distance);
        };
      }(),
      translateY: function() {
        var v1 = new THREE.Vector3(0, 1, 0);
        return function(distance) {
          return this.translateOnAxis(v1, distance);
        };
      }(),
      translateZ: function() {
        var v1 = new THREE.Vector3(0, 0, 1);
        return function(distance) {
          return this.translateOnAxis(v1, distance);
        };
      }(),
      localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
      },
      worldToLocal: function() {
        var m1 = new THREE.Matrix4();
        return function(vector) {
          return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
        };
      }(),
      lookAt: function() {
        var m1 = new THREE.Matrix4();
        return function(vector) {
          m1.lookAt(vector, this.position, this.up);
          this.quaternion.setFromRotationMatrix(m1);
        };
      }(),
      add: function(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.add(arguments[i]);
          }
          return this;
        }
        ;
        if (object === this) {
          THREE.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
          return this;
        }
        if (object instanceof THREE.Object3D) {
          if (object.parent !== undefined) {
            object.parent.remove(object);
          }
          object.parent = this;
          object.dispatchEvent({type: 'added'});
          this.children.push(object);
        } else {
          THREE.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
      },
      remove: function(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.remove(arguments[i]);
          }
        }
        ;
        var index = this.children.indexOf(object);
        if (index !== -1) {
          object.parent = undefined;
          object.dispatchEvent({type: 'removed'});
          this.children.splice(index, 1);
        }
      },
      getChildByName: function(name) {
        THREE.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
        return this.getObjectByName(name);
      },
      getObjectById: function(id) {
        return this.getObjectByProperty('id', id);
      },
      getObjectByName: function(name) {
        return this.getObjectByProperty('name', name);
      },
      getObjectByProperty: function(name, value) {
        if (this[name] === value)
          return this;
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          var child = this.children[i];
          var object = child.getObjectByProperty(name, value);
          if (object !== undefined) {
            return object;
          }
        }
        return undefined;
      },
      getWorldPosition: function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        this.updateMatrixWorld(true);
        return result.setFromMatrixPosition(this.matrixWorld);
      },
      getWorldQuaternion: function() {
        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Quaternion();
          this.updateMatrixWorld(true);
          this.matrixWorld.decompose(position, result, scale);
          return result;
        };
      }(),
      getWorldRotation: function() {
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Euler();
          this.getWorldQuaternion(quaternion);
          return result.setFromQuaternion(quaternion, this.rotation.order, false);
        };
      }(),
      getWorldScale: function() {
        var position = new THREE.Vector3();
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Vector3();
          this.updateMatrixWorld(true);
          this.matrixWorld.decompose(position, quaternion, result);
          return result;
        };
      }(),
      getWorldDirection: function() {
        var quaternion = new THREE.Quaternion();
        return function(optionalTarget) {
          var result = optionalTarget || new THREE.Vector3();
          this.getWorldQuaternion(quaternion);
          return result.set(0, 0, 1).applyQuaternion(quaternion);
        };
      }(),
      raycast: function() {},
      traverse: function(callback) {
        callback(this);
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          this.children[i].traverse(callback);
        }
      },
      traverseVisible: function(callback) {
        if (this.visible === false)
          return;
        callback(this);
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          this.children[i].traverseVisible(callback);
        }
      },
      traverseAncestors: function(callback) {
        if (this.parent) {
          callback(this.parent);
          this.parent.traverseAncestors(callback);
        }
      },
      updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      },
      updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate === true)
          this.updateMatrix();
        if (this.matrixWorldNeedsUpdate === true || force === true) {
          if (this.parent === undefined) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          this.children[i].updateMatrixWorld(force);
        }
      },
      toJSON: function() {
        var output = {metadata: {
            version: 4.3,
            type: 'Object',
            generator: 'ObjectExporter'
          }};
        var geometries = {};
        var parseGeometry = function(geometry) {
          if (output.geometries === undefined) {
            output.geometries = [];
          }
          if (geometries[geometry.uuid] === undefined) {
            var json = geometry.toJSON();
            delete json.metadata;
            geometries[geometry.uuid] = json;
            output.geometries.push(json);
          }
          return geometry.uuid;
        };
        var materials = {};
        var parseMaterial = function(material) {
          if (output.materials === undefined) {
            output.materials = [];
          }
          if (materials[material.uuid] === undefined) {
            var json = material.toJSON();
            delete json.metadata;
            materials[material.uuid] = json;
            output.materials.push(json);
          }
          return material.uuid;
        };
        var parseObject = function(object) {
          var data = {};
          data.uuid = object.uuid;
          data.type = object.type;
          if (object.name !== '')
            data.name = object.name;
          if (JSON.stringify(object.userData) !== '{}')
            data.userData = object.userData;
          if (object.visible !== true)
            data.visible = object.visible;
          if (object instanceof THREE.PerspectiveCamera) {
            data.fov = object.fov;
            data.aspect = object.aspect;
            data.near = object.near;
            data.far = object.far;
          } else if (object instanceof THREE.OrthographicCamera) {
            data.left = object.left;
            data.right = object.right;
            data.top = object.top;
            data.bottom = object.bottom;
            data.near = object.near;
            data.far = object.far;
          } else if (object instanceof THREE.AmbientLight) {
            data.color = object.color.getHex();
          } else if (object instanceof THREE.DirectionalLight) {
            data.color = object.color.getHex();
            data.intensity = object.intensity;
          } else if (object instanceof THREE.PointLight) {
            data.color = object.color.getHex();
            data.intensity = object.intensity;
            data.distance = object.distance;
            data.decay = object.decay;
          } else if (object instanceof THREE.SpotLight) {
            data.color = object.color.getHex();
            data.intensity = object.intensity;
            data.distance = object.distance;
            data.angle = object.angle;
            data.exponent = object.exponent;
            data.decay = object.decay;
          } else if (object instanceof THREE.HemisphereLight) {
            data.color = object.color.getHex();
            data.groundColor = object.groundColor.getHex();
          } else if (object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud) {
            data.geometry = parseGeometry(object.geometry);
            data.material = parseMaterial(object.material);
            if (object instanceof THREE.Line)
              data.mode = object.mode;
          } else if (object instanceof THREE.Sprite) {
            data.material = parseMaterial(object.material);
          }
          data.matrix = object.matrix.toArray();
          if (object.children.length > 0) {
            data.children = [];
            for (var i = 0; i < object.children.length; i++) {
              data.children.push(parseObject(object.children[i]));
            }
          }
          return data;
        };
        output.object = parseObject(this);
        return output;
      },
      clone: function(object, recursive) {
        if (object === undefined)
          object = new THREE.Object3D();
        if (recursive === undefined)
          recursive = true;
        object.name = this.name;
        object.up.copy(this.up);
        object.position.copy(this.position);
        object.quaternion.copy(this.quaternion);
        object.scale.copy(this.scale);
        object.rotationAutoUpdate = this.rotationAutoUpdate;
        object.matrix.copy(this.matrix);
        object.matrixWorld.copy(this.matrixWorld);
        object.matrixAutoUpdate = this.matrixAutoUpdate;
        object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
        object.visible = this.visible;
        object.castShadow = this.castShadow;
        object.receiveShadow = this.receiveShadow;
        object.frustumCulled = this.frustumCulled;
        object.userData = JSON.parse(JSON.stringify(this.userData));
        if (recursive === true) {
          for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            object.add(child.clone());
          }
        }
        return object;
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
    THREE.Object3DIdCount = 0;
    THREE.Face3 = function(a, b, c, normal, color, materialIndex) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
      this.vertexNormals = normal instanceof Array ? normal : [];
      this.color = color instanceof THREE.Color ? color : new THREE.Color();
      this.vertexColors = color instanceof Array ? color : [];
      this.vertexTangents = [];
      this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    };
    THREE.Face3.prototype = {
      constructor: THREE.Face3,
      clone: function() {
        var face = new THREE.Face3(this.a, this.b, this.c);
        face.normal.copy(this.normal);
        face.color.copy(this.color);
        face.materialIndex = this.materialIndex;
        for (var i = 0,
            il = this.vertexNormals.length; i < il; i++) {
          face.vertexNormals[i] = this.vertexNormals[i].clone();
        }
        for (var i = 0,
            il = this.vertexColors.length; i < il; i++) {
          face.vertexColors[i] = this.vertexColors[i].clone();
        }
        for (var i = 0,
            il = this.vertexTangents.length; i < il; i++) {
          face.vertexTangents[i] = this.vertexTangents[i].clone();
        }
        return face;
      }
    };
    THREE.Face4 = function(a, b, c, d, normal, color, materialIndex) {
      THREE.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
      return new THREE.Face3(a, b, c, normal, color, materialIndex);
    };
    THREE.BufferAttribute = function(array, itemSize) {
      this.array = array;
      this.itemSize = itemSize;
      this.needsUpdate = false;
    };
    THREE.BufferAttribute.prototype = {
      constructor: THREE.BufferAttribute,
      get length() {
        return this.array.length;
      },
      copyAt: function(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (var i = 0,
            l = this.itemSize; i < l; i++) {
          this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
      },
      set: function(value, offset) {
        if (offset === undefined)
          offset = 0;
        this.array.set(value, offset);
        return this;
      },
      setX: function(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
      },
      setY: function(index, y) {
        this.array[index * this.itemSize + 1] = y;
        return this;
      },
      setZ: function(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
      },
      setXY: function(index, x, y) {
        index *= this.itemSize;
        this.array[index] = x;
        this.array[index + 1] = y;
        return this;
      },
      setXYZ: function(index, x, y, z) {
        index *= this.itemSize;
        this.array[index] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
      },
      setXYZW: function(index, x, y, z, w) {
        index *= this.itemSize;
        this.array[index] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
      },
      clone: function() {
        return new THREE.BufferAttribute(new this.array.constructor(this.array), this.itemSize);
      }
    };
    THREE.Int8Attribute = function(data, itemSize) {
      THREE.warn('THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Uint8Attribute = function(data, itemSize) {
      THREE.warn('THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Uint8ClampedAttribute = function(data, itemSize) {
      THREE.warn('THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Int16Attribute = function(data, itemSize) {
      THREE.warn('THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Uint16Attribute = function(data, itemSize) {
      THREE.warn('THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Int32Attribute = function(data, itemSize) {
      THREE.warn('THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Uint32Attribute = function(data, itemSize) {
      THREE.warn('THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Float32Attribute = function(data, itemSize) {
      THREE.warn('THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.Float64Attribute = function(data, itemSize) {
      THREE.warn('THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.');
      return new THREE.BufferAttribute(data, itemSize);
    };
    THREE.DynamicBufferAttribute = function(array, itemSize) {
      THREE.BufferAttribute.call(this, array, itemSize);
      this.updateRange = {
        offset: 0,
        count: -1
      };
    };
    THREE.DynamicBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);
    THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;
    THREE.DynamicBufferAttribute.prototype.clone = function() {
      return new THREE.DynamicBufferAttribute(new this.array.constructor(this.array), this.itemSize);
    };
    THREE.BufferGeometry = function() {
      Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'BufferGeometry';
      this.attributes = {};
      this.attributesKeys = [];
      this.drawcalls = [];
      this.offsets = this.drawcalls;
      this.boundingBox = null;
      this.boundingSphere = null;
    };
    THREE.BufferGeometry.prototype = {
      constructor: THREE.BufferGeometry,
      addAttribute: function(name, attribute) {
        if (attribute instanceof THREE.BufferAttribute === false) {
          THREE.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
          this.attributes[name] = {
            array: arguments[1],
            itemSize: arguments[2]
          };
          return;
        }
        this.attributes[name] = attribute;
        this.attributesKeys = Object.keys(this.attributes);
      },
      getAttribute: function(name) {
        return this.attributes[name];
      },
      addDrawCall: function(start, count, indexOffset) {
        this.drawcalls.push({
          start: start,
          count: count,
          index: indexOffset !== undefined ? indexOffset : 0
        });
      },
      applyMatrix: function(matrix) {
        var position = this.attributes.position;
        if (position !== undefined) {
          matrix.applyToVector3Array(position.array);
          position.needsUpdate = true;
        }
        var normal = this.attributes.normal;
        if (normal !== undefined) {
          var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
          normalMatrix.applyToVector3Array(normal.array);
          normal.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
      },
      center: function() {
        this.computeBoundingBox();
        var offset = this.boundingBox.center().negate();
        this.applyMatrix(new THREE.Matrix4().setPosition(offset));
        return offset;
      },
      fromGeometry: function(geometry, settings) {
        settings = settings || {'vertexColors': THREE.NoColors};
        var vertices = geometry.vertices;
        var faces = geometry.faces;
        var faceVertexUvs = geometry.faceVertexUvs;
        var vertexColors = settings.vertexColors;
        var hasFaceVertexUv = faceVertexUvs[0].length > 0;
        var hasFaceVertexNormals = faces[0].vertexNormals.length == 3;
        var positions = new Float32Array(faces.length * 3 * 3);
        this.addAttribute('position', new THREE.BufferAttribute(positions, 3));
        var normals = new Float32Array(faces.length * 3 * 3);
        this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
        if (vertexColors !== THREE.NoColors) {
          var colors = new Float32Array(faces.length * 3 * 3);
          this.addAttribute('color', new THREE.BufferAttribute(colors, 3));
        }
        if (hasFaceVertexUv === true) {
          var uvs = new Float32Array(faces.length * 3 * 2);
          this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
        }
        for (var i = 0,
            i2 = 0,
            i3 = 0; i < faces.length; i++, i2 += 6, i3 += 9) {
          var face = faces[i];
          var a = vertices[face.a];
          var b = vertices[face.b];
          var c = vertices[face.c];
          positions[i3] = a.x;
          positions[i3 + 1] = a.y;
          positions[i3 + 2] = a.z;
          positions[i3 + 3] = b.x;
          positions[i3 + 4] = b.y;
          positions[i3 + 5] = b.z;
          positions[i3 + 6] = c.x;
          positions[i3 + 7] = c.y;
          positions[i3 + 8] = c.z;
          if (hasFaceVertexNormals === true) {
            var na = face.vertexNormals[0];
            var nb = face.vertexNormals[1];
            var nc = face.vertexNormals[2];
            normals[i3] = na.x;
            normals[i3 + 1] = na.y;
            normals[i3 + 2] = na.z;
            normals[i3 + 3] = nb.x;
            normals[i3 + 4] = nb.y;
            normals[i3 + 5] = nb.z;
            normals[i3 + 6] = nc.x;
            normals[i3 + 7] = nc.y;
            normals[i3 + 8] = nc.z;
          } else {
            var n = face.normal;
            normals[i3] = n.x;
            normals[i3 + 1] = n.y;
            normals[i3 + 2] = n.z;
            normals[i3 + 3] = n.x;
            normals[i3 + 4] = n.y;
            normals[i3 + 5] = n.z;
            normals[i3 + 6] = n.x;
            normals[i3 + 7] = n.y;
            normals[i3 + 8] = n.z;
          }
          if (vertexColors === THREE.FaceColors) {
            var fc = face.color;
            colors[i3] = fc.r;
            colors[i3 + 1] = fc.g;
            colors[i3 + 2] = fc.b;
            colors[i3 + 3] = fc.r;
            colors[i3 + 4] = fc.g;
            colors[i3 + 5] = fc.b;
            colors[i3 + 6] = fc.r;
            colors[i3 + 7] = fc.g;
            colors[i3 + 8] = fc.b;
          } else if (vertexColors === THREE.VertexColors) {
            var vca = face.vertexColors[0];
            var vcb = face.vertexColors[1];
            var vcc = face.vertexColors[2];
            colors[i3] = vca.r;
            colors[i3 + 1] = vca.g;
            colors[i3 + 2] = vca.b;
            colors[i3 + 3] = vcb.r;
            colors[i3 + 4] = vcb.g;
            colors[i3 + 5] = vcb.b;
            colors[i3 + 6] = vcc.r;
            colors[i3 + 7] = vcc.g;
            colors[i3 + 8] = vcc.b;
          }
          if (hasFaceVertexUv === true) {
            var uva = faceVertexUvs[0][i][0];
            var uvb = faceVertexUvs[0][i][1];
            var uvc = faceVertexUvs[0][i][2];
            uvs[i2] = uva.x;
            uvs[i2 + 1] = uva.y;
            uvs[i2 + 2] = uvb.x;
            uvs[i2 + 3] = uvb.y;
            uvs[i2 + 4] = uvc.x;
            uvs[i2 + 5] = uvc.y;
          }
        }
        this.computeBoundingSphere();
        return this;
      },
      computeBoundingBox: function() {
        var vector = new THREE.Vector3();
        return function() {
          if (this.boundingBox === null) {
            this.boundingBox = new THREE.Box3();
          }
          var positions = this.attributes.position.array;
          if (positions) {
            var bb = this.boundingBox;
            bb.makeEmpty();
            for (var i = 0,
                il = positions.length; i < il; i += 3) {
              vector.set(positions[i], positions[i + 1], positions[i + 2]);
              bb.expandByPoint(vector);
            }
          }
          if (positions === undefined || positions.length === 0) {
            this.boundingBox.min.set(0, 0, 0);
            this.boundingBox.max.set(0, 0, 0);
          }
          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            THREE.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.');
          }
        };
      }(),
      computeBoundingSphere: function() {
        var box = new THREE.Box3();
        var vector = new THREE.Vector3();
        return function() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new THREE.Sphere();
          }
          var positions = this.attributes.position.array;
          if (positions) {
            box.makeEmpty();
            var center = this.boundingSphere.center;
            for (var i = 0,
                il = positions.length; i < il; i += 3) {
              vector.set(positions[i], positions[i + 1], positions[i + 2]);
              box.expandByPoint(vector);
            }
            box.center(center);
            var maxRadiusSq = 0;
            for (var i = 0,
                il = positions.length; i < il; i += 3) {
              vector.set(positions[i], positions[i + 1], positions[i + 2]);
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) {
              THREE.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.');
            }
          }
        };
      }(),
      computeFaceNormals: function() {},
      computeVertexNormals: function() {
        var attributes = this.attributes;
        if (attributes.position) {
          var positions = attributes.position.array;
          if (attributes.normal === undefined) {
            this.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(positions.length), 3));
          } else {
            var normals = attributes.normal.array;
            for (var i = 0,
                il = normals.length; i < il; i++) {
              normals[i] = 0;
            }
          }
          var normals = attributes.normal.array;
          var vA,
              vB,
              vC,
              pA = new THREE.Vector3(),
              pB = new THREE.Vector3(),
              pC = new THREE.Vector3(),
              cb = new THREE.Vector3(),
              ab = new THREE.Vector3();
          if (attributes.index) {
            var indices = attributes.index.array;
            var offsets = (this.offsets.length > 0 ? this.offsets : [{
              start: 0,
              count: indices.length,
              index: 0
            }]);
            for (var j = 0,
                jl = offsets.length; j < jl; ++j) {
              var start = offsets[j].start;
              var count = offsets[j].count;
              var index = offsets[j].index;
              for (var i = start,
                  il = start + count; i < il; i += 3) {
                vA = (index + indices[i]) * 3;
                vB = (index + indices[i + 1]) * 3;
                vC = (index + indices[i + 2]) * 3;
                pA.fromArray(positions, vA);
                pB.fromArray(positions, vB);
                pC.fromArray(positions, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normals[vA] += cb.x;
                normals[vA + 1] += cb.y;
                normals[vA + 2] += cb.z;
                normals[vB] += cb.x;
                normals[vB + 1] += cb.y;
                normals[vB + 2] += cb.z;
                normals[vC] += cb.x;
                normals[vC + 1] += cb.y;
                normals[vC + 2] += cb.z;
              }
            }
          } else {
            for (var i = 0,
                il = positions.length; i < il; i += 9) {
              pA.fromArray(positions, i);
              pB.fromArray(positions, i + 3);
              pC.fromArray(positions, i + 6);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normals[i] = cb.x;
              normals[i + 1] = cb.y;
              normals[i + 2] = cb.z;
              normals[i + 3] = cb.x;
              normals[i + 4] = cb.y;
              normals[i + 5] = cb.z;
              normals[i + 6] = cb.x;
              normals[i + 7] = cb.y;
              normals[i + 8] = cb.z;
            }
          }
          this.normalizeNormals();
          attributes.normal.needsUpdate = true;
        }
      },
      computeTangents: function() {
        if (this.attributes.index === undefined || this.attributes.position === undefined || this.attributes.normal === undefined || this.attributes.uv === undefined) {
          THREE.warn('THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()');
          return;
        }
        var indices = this.attributes.index.array;
        var positions = this.attributes.position.array;
        var normals = this.attributes.normal.array;
        var uvs = this.attributes.uv.array;
        var nVertices = positions.length / 3;
        if (this.attributes.tangent === undefined) {
          this.addAttribute('tangent', new THREE.BufferAttribute(new Float32Array(4 * nVertices), 4));
        }
        var tangents = this.attributes.tangent.array;
        var tan1 = [],
            tan2 = [];
        for (var k = 0; k < nVertices; k++) {
          tan1[k] = new THREE.Vector3();
          tan2[k] = new THREE.Vector3();
        }
        var vA = new THREE.Vector3(),
            vB = new THREE.Vector3(),
            vC = new THREE.Vector3(),
            uvA = new THREE.Vector2(),
            uvB = new THREE.Vector2(),
            uvC = new THREE.Vector2(),
            x1,
            x2,
            y1,
            y2,
            z1,
            z2,
            s1,
            s2,
            t1,
            t2,
            r;
        var sdir = new THREE.Vector3(),
            tdir = new THREE.Vector3();
        function handleTriangle(a, b, c) {
          vA.fromArray(positions, a * 3);
          vB.fromArray(positions, b * 3);
          vC.fromArray(positions, c * 3);
          uvA.fromArray(uvs, a * 2);
          uvB.fromArray(uvs, b * 2);
          uvC.fromArray(uvs, c * 2);
          x1 = vB.x - vA.x;
          x2 = vC.x - vA.x;
          y1 = vB.y - vA.y;
          y2 = vC.y - vA.y;
          z1 = vB.z - vA.z;
          z2 = vC.z - vA.z;
          s1 = uvB.x - uvA.x;
          s2 = uvC.x - uvA.x;
          t1 = uvB.y - uvA.y;
          t2 = uvC.y - uvA.y;
          r = 1.0 / (s1 * t2 - s2 * t1);
          sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
          tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
          tan1[a].add(sdir);
          tan1[b].add(sdir);
          tan1[c].add(sdir);
          tan2[a].add(tdir);
          tan2[b].add(tdir);
          tan2[c].add(tdir);
        }
        var i,
            il;
        var j,
            jl;
        var iA,
            iB,
            iC;
        if (this.drawcalls.length === 0) {
          this.addDrawCall(0, indices.length, 0);
        }
        var drawcalls = this.drawcalls;
        for (j = 0, jl = drawcalls.length; j < jl; ++j) {
          var start = drawcalls[j].start;
          var count = drawcalls[j].count;
          var index = drawcalls[j].index;
          for (i = start, il = start + count; i < il; i += 3) {
            iA = index + indices[i];
            iB = index + indices[i + 1];
            iC = index + indices[i + 2];
            handleTriangle(iA, iB, iC);
          }
        }
        var tmp = new THREE.Vector3(),
            tmp2 = new THREE.Vector3();
        var n = new THREE.Vector3(),
            n2 = new THREE.Vector3();
        var w,
            t,
            test;
        function handleVertex(v) {
          n.fromArray(normals, v * 3);
          n2.copy(n);
          t = tan1[v];
          tmp.copy(t);
          tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
          tmp2.crossVectors(n2, t);
          test = tmp2.dot(tan2[v]);
          w = (test < 0.0) ? -1.0 : 1.0;
          tangents[v * 4] = tmp.x;
          tangents[v * 4 + 1] = tmp.y;
          tangents[v * 4 + 2] = tmp.z;
          tangents[v * 4 + 3] = w;
        }
        for (j = 0, jl = drawcalls.length; j < jl; ++j) {
          var start = drawcalls[j].start;
          var count = drawcalls[j].count;
          var index = drawcalls[j].index;
          for (i = start, il = start + count; i < il; i += 3) {
            iA = index + indices[i];
            iB = index + indices[i + 1];
            iC = index + indices[i + 2];
            handleVertex(iA);
            handleVertex(iB);
            handleVertex(iC);
          }
        }
      },
      computeOffsets: function(size) {
        if (size === undefined)
          size = 65535;
        var indices = this.attributes.index.array;
        var vertices = this.attributes.position.array;
        var facesCount = (indices.length / 3);
        var sortedIndices = new Uint16Array(indices.length);
        var indexPtr = 0;
        var vertexPtr = 0;
        var offsets = [{
          start: 0,
          count: 0,
          index: 0
        }];
        var offset = offsets[0];
        var duplicatedVertices = 0;
        var newVerticeMaps = 0;
        var faceVertices = new Int32Array(6);
        var vertexMap = new Int32Array(vertices.length);
        var revVertexMap = new Int32Array(vertices.length);
        for (var j = 0; j < vertices.length; j++) {
          vertexMap[j] = -1;
          revVertexMap[j] = -1;
        }
        for (var findex = 0; findex < facesCount; findex++) {
          newVerticeMaps = 0;
          for (var vo = 0; vo < 3; vo++) {
            var vid = indices[findex * 3 + vo];
            if (vertexMap[vid] == -1) {
              faceVertices[vo * 2] = vid;
              faceVertices[vo * 2 + 1] = -1;
              newVerticeMaps++;
            } else if (vertexMap[vid] < offset.index) {
              faceVertices[vo * 2] = vid;
              faceVertices[vo * 2 + 1] = -1;
              duplicatedVertices++;
            } else {
              faceVertices[vo * 2] = vid;
              faceVertices[vo * 2 + 1] = vertexMap[vid];
            }
          }
          var faceMax = vertexPtr + newVerticeMaps;
          if (faceMax > (offset.index + size)) {
            var new_offset = {
              start: indexPtr,
              count: 0,
              index: vertexPtr
            };
            offsets.push(new_offset);
            offset = new_offset;
            for (var v = 0; v < 6; v += 2) {
              var new_vid = faceVertices[v + 1];
              if (new_vid > -1 && new_vid < offset.index)
                faceVertices[v + 1] = -1;
            }
          }
          for (var v = 0; v < 6; v += 2) {
            var vid = faceVertices[v];
            var new_vid = faceVertices[v + 1];
            if (new_vid === -1)
              new_vid = vertexPtr++;
            vertexMap[vid] = new_vid;
            revVertexMap[new_vid] = vid;
            sortedIndices[indexPtr++] = new_vid - offset.index;
            offset.count++;
          }
        }
        this.reorderBuffers(sortedIndices, revVertexMap, vertexPtr);
        this.offsets = offsets;
        this.drawcalls = offsets;
        return offsets;
      },
      merge: function(geometry, offset) {
        if (geometry instanceof THREE.BufferGeometry === false) {
          THREE.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
          return;
        }
        if (offset === undefined)
          offset = 0;
        var attributes = this.attributes;
        for (var key in attributes) {
          if (geometry.attributes[key] === undefined)
            continue;
          var attribute1 = attributes[key];
          var attributeArray1 = attribute1.array;
          var attribute2 = geometry.attributes[key];
          var attributeArray2 = attribute2.array;
          var attributeSize = attribute2.itemSize;
          for (var i = 0,
              j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
            attributeArray1[j] = attributeArray2[i];
          }
        }
        return this;
      },
      normalizeNormals: function() {
        var normals = this.attributes.normal.array;
        var x,
            y,
            z,
            n;
        for (var i = 0,
            il = normals.length; i < il; i += 3) {
          x = normals[i];
          y = normals[i + 1];
          z = normals[i + 2];
          n = 1.0 / Math.sqrt(x * x + y * y + z * z);
          normals[i] *= n;
          normals[i + 1] *= n;
          normals[i + 2] *= n;
        }
      },
      reorderBuffers: function(indexBuffer, indexMap, vertexCount) {
        var sortedAttributes = {};
        for (var attr in this.attributes) {
          if (attr == 'index')
            continue;
          var sourceArray = this.attributes[attr].array;
          sortedAttributes[attr] = new sourceArray.constructor(this.attributes[attr].itemSize * vertexCount);
        }
        for (var new_vid = 0; new_vid < vertexCount; new_vid++) {
          var vid = indexMap[new_vid];
          for (var attr in this.attributes) {
            if (attr == 'index')
              continue;
            var attrArray = this.attributes[attr].array;
            var attrSize = this.attributes[attr].itemSize;
            var sortedAttr = sortedAttributes[attr];
            for (var k = 0; k < attrSize; k++)
              sortedAttr[new_vid * attrSize + k] = attrArray[vid * attrSize + k];
          }
        }
        this.attributes['index'].array = indexBuffer;
        for (var attr in this.attributes) {
          if (attr == 'index')
            continue;
          this.attributes[attr].array = sortedAttributes[attr];
          this.attributes[attr].numItems = this.attributes[attr].itemSize * vertexCount;
        }
      },
      toJSON: function() {
        var output = {
          metadata: {
            version: 4.0,
            type: 'BufferGeometry',
            generator: 'BufferGeometryExporter'
          },
          uuid: this.uuid,
          type: this.type,
          data: {attributes: {}}
        };
        var attributes = this.attributes;
        var offsets = this.offsets;
        var boundingSphere = this.boundingSphere;
        for (var key in attributes) {
          var attribute = attributes[key];
          var array = Array.prototype.slice.call(attribute.array);
          output.data.attributes[key] = {
            itemSize: attribute.itemSize,
            type: attribute.array.constructor.name,
            array: array
          };
        }
        if (offsets.length > 0) {
          output.data.offsets = JSON.parse(JSON.stringify(offsets));
        }
        if (boundingSphere !== null) {
          output.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
          };
        }
        return output;
      },
      clone: function() {
        var geometry = new THREE.BufferGeometry();
        for (var attr in this.attributes) {
          var sourceAttr = this.attributes[attr];
          geometry.addAttribute(attr, sourceAttr.clone());
        }
        for (var i = 0,
            il = this.offsets.length; i < il; i++) {
          var offset = this.offsets[i];
          geometry.offsets.push({
            start: offset.start,
            index: offset.index,
            count: offset.count
          });
        }
        return geometry;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
    THREE.Geometry = function() {
      Object.defineProperty(this, 'id', {value: THREE.GeometryIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'Geometry';
      this.vertices = [];
      this.colors = [];
      this.faces = [];
      this.faceVertexUvs = [[]];
      this.morphTargets = [];
      this.morphColors = [];
      this.morphNormals = [];
      this.skinWeights = [];
      this.skinIndices = [];
      this.lineDistances = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.hasTangents = false;
      this.dynamic = true;
      this.verticesNeedUpdate = false;
      this.elementsNeedUpdate = false;
      this.uvsNeedUpdate = false;
      this.normalsNeedUpdate = false;
      this.tangentsNeedUpdate = false;
      this.colorsNeedUpdate = false;
      this.lineDistancesNeedUpdate = false;
      this.groupsNeedUpdate = false;
    };
    THREE.Geometry.prototype = {
      constructor: THREE.Geometry,
      applyMatrix: function(matrix) {
        var normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
        for (var i = 0,
            il = this.vertices.length; i < il; i++) {
          var vertex = this.vertices[i];
          vertex.applyMatrix4(matrix);
        }
        for (var i = 0,
            il = this.faces.length; i < il; i++) {
          var face = this.faces[i];
          face.normal.applyMatrix3(normalMatrix).normalize();
          for (var j = 0,
              jl = face.vertexNormals.length; j < jl; j++) {
            face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
          }
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
      },
      fromBufferGeometry: function(geometry) {
        var scope = this;
        var attributes = geometry.attributes;
        var vertices = attributes.position.array;
        var indices = attributes.index !== undefined ? attributes.index.array : undefined;
        var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
        var colors = attributes.color !== undefined ? attributes.color.array : undefined;
        var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
        var tempNormals = [];
        var tempUVs = [];
        for (var i = 0,
            j = 0; i < vertices.length; i += 3, j += 2) {
          scope.vertices.push(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
          if (normals !== undefined) {
            tempNormals.push(new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]));
          }
          if (colors !== undefined) {
            scope.colors.push(new THREE.Color(colors[i], colors[i + 1], colors[i + 2]));
          }
          if (uvs !== undefined) {
            tempUVs.push(new THREE.Vector2(uvs[j], uvs[j + 1]));
          }
        }
        var addFace = function(a, b, c) {
          var vertexNormals = normals !== undefined ? [tempNormals[a].clone(), tempNormals[b].clone(), tempNormals[c].clone()] : [];
          var vertexColors = colors !== undefined ? [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()] : [];
          scope.faces.push(new THREE.Face3(a, b, c, vertexNormals, vertexColors));
          if (uvs !== undefined) {
            scope.faceVertexUvs[0].push([tempUVs[a].clone(), tempUVs[b].clone(), tempUVs[c].clone()]);
          }
        };
        if (indices !== undefined) {
          var drawcalls = geometry.drawcalls;
          if (drawcalls.length > 0) {
            for (var i = 0; i < drawcalls.length; i++) {
              var drawcall = drawcalls[i];
              var start = drawcall.start;
              var count = drawcall.count;
              var index = drawcall.index;
              for (var j = start,
                  jl = start + count; j < jl; j += 3) {
                addFace(index + indices[j], index + indices[j + 1], index + indices[j + 2]);
              }
            }
          } else {
            for (var i = 0; i < indices.length; i += 3) {
              addFace(indices[i], indices[i + 1], indices[i + 2]);
            }
          }
        } else {
          for (var i = 0; i < vertices.length / 3; i += 3) {
            addFace(i, i + 1, i + 2);
          }
        }
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) {
          this.boundingBox = geometry.boundingBox.clone();
        }
        if (geometry.boundingSphere !== null) {
          this.boundingSphere = geometry.boundingSphere.clone();
        }
        return this;
      },
      center: function() {
        this.computeBoundingBox();
        var offset = this.boundingBox.center().negate();
        this.applyMatrix(new THREE.Matrix4().setPosition(offset));
        return offset;
      },
      computeFaceNormals: function() {
        var cb = new THREE.Vector3(),
            ab = new THREE.Vector3();
        for (var f = 0,
            fl = this.faces.length; f < fl; f++) {
          var face = this.faces[f];
          var vA = this.vertices[face.a];
          var vB = this.vertices[face.b];
          var vC = this.vertices[face.c];
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          cb.cross(ab);
          cb.normalize();
          face.normal.copy(cb);
        }
      },
      computeVertexNormals: function(areaWeighted) {
        var v,
            vl,
            f,
            fl,
            face,
            vertices;
        vertices = new Array(this.vertices.length);
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
          vertices[v] = new THREE.Vector3();
        }
        if (areaWeighted) {
          var vA,
              vB,
              vC;
          var cb = new THREE.Vector3(),
              ab = new THREE.Vector3();
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            vA = this.vertices[face.a];
            vB = this.vertices[face.b];
            vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            vertices[face.a].add(cb);
            vertices[face.b].add(cb);
            vertices[face.c].add(cb);
          }
        } else {
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            vertices[face.a].add(face.normal);
            vertices[face.b].add(face.normal);
            vertices[face.c].add(face.normal);
          }
        }
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
          vertices[v].normalize();
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          face.vertexNormals[0] = vertices[face.a].clone();
          face.vertexNormals[1] = vertices[face.b].clone();
          face.vertexNormals[2] = vertices[face.c].clone();
        }
      },
      computeMorphNormals: function() {
        var i,
            il,
            f,
            fl,
            face;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          if (!face.__originalFaceNormal) {
            face.__originalFaceNormal = face.normal.clone();
          } else {
            face.__originalFaceNormal.copy(face.normal);
          }
          if (!face.__originalVertexNormals)
            face.__originalVertexNormals = [];
          for (i = 0, il = face.vertexNormals.length; i < il; i++) {
            if (!face.__originalVertexNormals[i]) {
              face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
            } else {
              face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
            }
          }
        }
        var tmpGeo = new THREE.Geometry();
        tmpGeo.faces = this.faces;
        for (i = 0, il = this.morphTargets.length; i < il; i++) {
          if (!this.morphNormals[i]) {
            this.morphNormals[i] = {};
            this.morphNormals[i].faceNormals = [];
            this.morphNormals[i].vertexNormals = [];
            var dstNormalsFace = this.morphNormals[i].faceNormals;
            var dstNormalsVertex = this.morphNormals[i].vertexNormals;
            var faceNormal,
                vertexNormals;
            for (f = 0, fl = this.faces.length; f < fl; f++) {
              faceNormal = new THREE.Vector3();
              vertexNormals = {
                a: new THREE.Vector3(),
                b: new THREE.Vector3(),
                c: new THREE.Vector3()
              };
              dstNormalsFace.push(faceNormal);
              dstNormalsVertex.push(vertexNormals);
            }
          }
          var morphNormals = this.morphNormals[i];
          tmpGeo.vertices = this.morphTargets[i].vertices;
          tmpGeo.computeFaceNormals();
          tmpGeo.computeVertexNormals();
          var faceNormal,
              vertexNormals;
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            face = this.faces[f];
            faceNormal = morphNormals.faceNormals[f];
            vertexNormals = morphNormals.vertexNormals[f];
            faceNormal.copy(face.normal);
            vertexNormals.a.copy(face.vertexNormals[0]);
            vertexNormals.b.copy(face.vertexNormals[1]);
            vertexNormals.c.copy(face.vertexNormals[2]);
          }
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          face.normal = face.__originalFaceNormal;
          face.vertexNormals = face.__originalVertexNormals;
        }
      },
      computeTangents: function() {
        var f,
            fl,
            v,
            vl,
            i,
            vertexIndex,
            face,
            uv,
            vA,
            vB,
            vC,
            uvA,
            uvB,
            uvC,
            x1,
            x2,
            y1,
            y2,
            z1,
            z2,
            s1,
            s2,
            t1,
            t2,
            r,
            t,
            test,
            tan1 = [],
            tan2 = [],
            sdir = new THREE.Vector3(),
            tdir = new THREE.Vector3(),
            tmp = new THREE.Vector3(),
            tmp2 = new THREE.Vector3(),
            n = new THREE.Vector3(),
            w;
        for (v = 0, vl = this.vertices.length; v < vl; v++) {
          tan1[v] = new THREE.Vector3();
          tan2[v] = new THREE.Vector3();
        }
        function handleTriangle(context, a, b, c, ua, ub, uc) {
          vA = context.vertices[a];
          vB = context.vertices[b];
          vC = context.vertices[c];
          uvA = uv[ua];
          uvB = uv[ub];
          uvC = uv[uc];
          x1 = vB.x - vA.x;
          x2 = vC.x - vA.x;
          y1 = vB.y - vA.y;
          y2 = vC.y - vA.y;
          z1 = vB.z - vA.z;
          z2 = vC.z - vA.z;
          s1 = uvB.x - uvA.x;
          s2 = uvC.x - uvA.x;
          t1 = uvB.y - uvA.y;
          t2 = uvC.y - uvA.y;
          r = 1.0 / (s1 * t2 - s2 * t1);
          sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
          tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
          tan1[a].add(sdir);
          tan1[b].add(sdir);
          tan1[c].add(sdir);
          tan2[a].add(tdir);
          tan2[b].add(tdir);
          tan2[c].add(tdir);
        }
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          uv = this.faceVertexUvs[0][f];
          handleTriangle(this, face.a, face.b, face.c, 0, 1, 2);
        }
        var faceIndex = ['a', 'b', 'c', 'd'];
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          for (i = 0; i < Math.min(face.vertexNormals.length, 3); i++) {
            n.copy(face.vertexNormals[i]);
            vertexIndex = face[faceIndex[i]];
            t = tan1[vertexIndex];
            tmp.copy(t);
            tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
            tmp2.crossVectors(face.vertexNormals[i], t);
            test = tmp2.dot(tan2[vertexIndex]);
            w = (test < 0.0) ? -1.0 : 1.0;
            face.vertexTangents[i] = new THREE.Vector4(tmp.x, tmp.y, tmp.z, w);
          }
        }
        this.hasTangents = true;
      },
      computeLineDistances: function() {
        var d = 0;
        var vertices = this.vertices;
        for (var i = 0,
            il = vertices.length; i < il; i++) {
          if (i > 0) {
            d += vertices[i].distanceTo(vertices[i - 1]);
          }
          this.lineDistances[i] = d;
        }
      },
      computeBoundingBox: function() {
        if (this.boundingBox === null) {
          this.boundingBox = new THREE.Box3();
        }
        this.boundingBox.setFromPoints(this.vertices);
      },
      computeBoundingSphere: function() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new THREE.Sphere();
        }
        this.boundingSphere.setFromPoints(this.vertices);
      },
      merge: function(geometry, matrix, materialIndexOffset) {
        if (geometry instanceof THREE.Geometry === false) {
          THREE.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
          return;
        }
        var normalMatrix,
            vertexOffset = this.vertices.length,
            vertices1 = this.vertices,
            vertices2 = geometry.vertices,
            faces1 = this.faces,
            faces2 = geometry.faces,
            uvs1 = this.faceVertexUvs[0],
            uvs2 = geometry.faceVertexUvs[0];
        if (materialIndexOffset === undefined)
          materialIndexOffset = 0;
        if (matrix !== undefined) {
          normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
        }
        for (var i = 0,
            il = vertices2.length; i < il; i++) {
          var vertex = vertices2[i];
          var vertexCopy = vertex.clone();
          if (matrix !== undefined)
            vertexCopy.applyMatrix4(matrix);
          vertices1.push(vertexCopy);
        }
        for (i = 0, il = faces2.length; i < il; i++) {
          var face = faces2[i],
              faceCopy,
              normal,
              color,
              faceVertexNormals = face.vertexNormals,
              faceVertexColors = face.vertexColors;
          faceCopy = new THREE.Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
          faceCopy.normal.copy(face.normal);
          if (normalMatrix !== undefined) {
            faceCopy.normal.applyMatrix3(normalMatrix).normalize();
          }
          for (var j = 0,
              jl = faceVertexNormals.length; j < jl; j++) {
            normal = faceVertexNormals[j].clone();
            if (normalMatrix !== undefined) {
              normal.applyMatrix3(normalMatrix).normalize();
            }
            faceCopy.vertexNormals.push(normal);
          }
          faceCopy.color.copy(face.color);
          for (var j = 0,
              jl = faceVertexColors.length; j < jl; j++) {
            color = faceVertexColors[j];
            faceCopy.vertexColors.push(color.clone());
          }
          faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
          faces1.push(faceCopy);
        }
        for (i = 0, il = uvs2.length; i < il; i++) {
          var uv = uvs2[i],
              uvCopy = [];
          if (uv === undefined) {
            continue;
          }
          for (var j = 0,
              jl = uv.length; j < jl; j++) {
            uvCopy.push(uv[j].clone());
          }
          uvs1.push(uvCopy);
        }
      },
      mergeMesh: function(mesh) {
        if (mesh instanceof THREE.Mesh === false) {
          THREE.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
          return;
        }
        mesh.matrixAutoUpdate && mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
      },
      mergeVertices: function() {
        var verticesMap = {};
        var unique = [],
            changes = [];
        var v,
            key;
        var precisionPoints = 4;
        var precision = Math.pow(10, precisionPoints);
        var i,
            il,
            face;
        var indices,
            j,
            jl;
        for (i = 0, il = this.vertices.length; i < il; i++) {
          v = this.vertices[i];
          key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
          if (verticesMap[key] === undefined) {
            verticesMap[key] = i;
            unique.push(this.vertices[i]);
            changes[i] = unique.length - 1;
          } else {
            changes[i] = changes[verticesMap[key]];
          }
        }
        ;
        var faceIndicesToRemove = [];
        for (i = 0, il = this.faces.length; i < il; i++) {
          face = this.faces[i];
          face.a = changes[face.a];
          face.b = changes[face.b];
          face.c = changes[face.c];
          indices = [face.a, face.b, face.c];
          var dupIndex = -1;
          for (var n = 0; n < 3; n++) {
            if (indices[n] == indices[(n + 1) % 3]) {
              dupIndex = n;
              faceIndicesToRemove.push(i);
              break;
            }
          }
        }
        for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
          var idx = faceIndicesToRemove[i];
          this.faces.splice(idx, 1);
          for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
            this.faceVertexUvs[j].splice(idx, 1);
          }
        }
        var diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
      },
      toJSON: function() {
        var output = {
          metadata: {
            version: 4.0,
            type: 'BufferGeometry',
            generator: 'BufferGeometryExporter'
          },
          uuid: this.uuid,
          type: this.type
        };
        if (this.name !== "")
          output.name = this.name;
        if (this.parameters !== undefined) {
          var parameters = this.parameters;
          for (var key in parameters) {
            if (parameters[key] !== undefined)
              output[key] = parameters[key];
          }
          return output;
        }
        var vertices = [];
        for (var i = 0; i < this.vertices.length; i++) {
          var vertex = this.vertices[i];
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
        var faces = [];
        var normals = [];
        var normalsHash = {};
        var colors = [];
        var colorsHash = {};
        var uvs = [];
        var uvsHash = {};
        for (var i = 0; i < this.faces.length; i++) {
          var face = this.faces[i];
          var hasMaterial = false;
          var hasFaceUv = false;
          var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
          var hasFaceNormal = face.normal.length() > 0;
          var hasFaceVertexNormal = face.vertexNormals.length > 0;
          var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
          var hasFaceVertexColor = face.vertexColors.length > 0;
          var faceType = 0;
          faceType = setBit(faceType, 0, 0);
          faceType = setBit(faceType, 1, hasMaterial);
          faceType = setBit(faceType, 2, hasFaceUv);
          faceType = setBit(faceType, 3, hasFaceVertexUv);
          faceType = setBit(faceType, 4, hasFaceNormal);
          faceType = setBit(faceType, 5, hasFaceVertexNormal);
          faceType = setBit(faceType, 6, hasFaceColor);
          faceType = setBit(faceType, 7, hasFaceVertexColor);
          faces.push(faceType);
          faces.push(face.a, face.b, face.c);
          if (hasFaceVertexUv) {
            var faceVertexUvs = this.faceVertexUvs[0][i];
            faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
          }
          if (hasFaceNormal) {
            faces.push(getNormalIndex(face.normal));
          }
          if (hasFaceVertexNormal) {
            var vertexNormals = face.vertexNormals;
            faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
          }
          if (hasFaceColor) {
            faces.push(getColorIndex(face.color));
          }
          if (hasFaceVertexColor) {
            var vertexColors = face.vertexColors;
            faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
          }
        }
        function setBit(value, position, enabled) {
          return enabled ? value | (1 << position) : value & (~(1 << position));
        }
        function getNormalIndex(normal) {
          var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
          if (normalsHash[hash] !== undefined) {
            return normalsHash[hash];
          }
          normalsHash[hash] = normals.length / 3;
          normals.push(normal.x, normal.y, normal.z);
          return normalsHash[hash];
        }
        function getColorIndex(color) {
          var hash = color.r.toString() + color.g.toString() + color.b.toString();
          if (colorsHash[hash] !== undefined) {
            return colorsHash[hash];
          }
          colorsHash[hash] = colors.length;
          colors.push(color.getHex());
          return colorsHash[hash];
        }
        function getUvIndex(uv) {
          var hash = uv.x.toString() + uv.y.toString();
          if (uvsHash[hash] !== undefined) {
            return uvsHash[hash];
          }
          uvsHash[hash] = uvs.length / 2;
          uvs.push(uv.x, uv.y);
          return uvsHash[hash];
        }
        output.data = {};
        output.data.vertices = vertices;
        output.data.normals = normals;
        if (colors.length > 0)
          output.data.colors = colors;
        if (uvs.length > 0)
          output.data.uvs = [uvs];
        output.data.faces = faces;
        return output;
      },
      clone: function() {
        var geometry = new THREE.Geometry();
        var vertices = this.vertices;
        for (var i = 0,
            il = vertices.length; i < il; i++) {
          geometry.vertices.push(vertices[i].clone());
        }
        var faces = this.faces;
        for (var i = 0,
            il = faces.length; i < il; i++) {
          geometry.faces.push(faces[i].clone());
        }
        for (var i = 0,
            il = this.faceVertexUvs.length; i < il; i++) {
          var faceVertexUvs = this.faceVertexUvs[i];
          if (geometry.faceVertexUvs[i] === undefined) {
            geometry.faceVertexUvs[i] = [];
          }
          for (var j = 0,
              jl = faceVertexUvs.length; j < jl; j++) {
            var uvs = faceVertexUvs[j],
                uvsCopy = [];
            for (var k = 0,
                kl = uvs.length; k < kl; k++) {
              var uv = uvs[k];
              uvsCopy.push(uv.clone());
            }
            geometry.faceVertexUvs[i].push(uvsCopy);
          }
        }
        return geometry;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
    THREE.GeometryIdCount = 0;
    THREE.Camera = function() {
      THREE.Object3D.call(this);
      this.type = 'Camera';
      this.matrixWorldInverse = new THREE.Matrix4();
      this.projectionMatrix = new THREE.Matrix4();
    };
    THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Camera.prototype.constructor = THREE.Camera;
    THREE.Camera.prototype.getWorldDirection = function() {
      var quaternion = new THREE.Quaternion();
      return function(optionalTarget) {
        var result = optionalTarget || new THREE.Vector3();
        this.getWorldQuaternion(quaternion);
        return result.set(0, 0, -1).applyQuaternion(quaternion);
      };
    }();
    THREE.Camera.prototype.lookAt = function() {
      var m1 = new THREE.Matrix4();
      return function(vector) {
        m1.lookAt(this.position, vector, this.up);
        this.quaternion.setFromRotationMatrix(m1);
      };
    }();
    THREE.Camera.prototype.clone = function(camera) {
      if (camera === undefined)
        camera = new THREE.Camera();
      THREE.Object3D.prototype.clone.call(this, camera);
      camera.matrixWorldInverse.copy(this.matrixWorldInverse);
      camera.projectionMatrix.copy(this.projectionMatrix);
      return camera;
    };
    THREE.CubeCamera = function(near, far, cubeResolution) {
      THREE.Object3D.call(this);
      this.type = 'CubeCamera';
      var fov = 90,
          aspect = 1;
      var cameraPX = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
      this.add(cameraPX);
      var cameraNX = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
      this.add(cameraNX);
      var cameraPY = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
      this.add(cameraPY);
      var cameraNY = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
      this.add(cameraNY);
      var cameraPZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
      this.add(cameraPZ);
      var cameraNZ = new THREE.PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
      this.add(cameraNZ);
      this.renderTarget = new THREE.WebGLRenderTargetCube(cubeResolution, cubeResolution, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
      });
      this.updateCubeMap = function(renderer, scene) {
        var renderTarget = this.renderTarget;
        var generateMipmaps = renderTarget.generateMipmaps;
        renderTarget.generateMipmaps = false;
        renderTarget.activeCubeFace = 0;
        renderer.render(scene, cameraPX, renderTarget);
        renderTarget.activeCubeFace = 1;
        renderer.render(scene, cameraNX, renderTarget);
        renderTarget.activeCubeFace = 2;
        renderer.render(scene, cameraPY, renderTarget);
        renderTarget.activeCubeFace = 3;
        renderer.render(scene, cameraNY, renderTarget);
        renderTarget.activeCubeFace = 4;
        renderer.render(scene, cameraPZ, renderTarget);
        renderTarget.generateMipmaps = generateMipmaps;
        renderTarget.activeCubeFace = 5;
        renderer.render(scene, cameraNZ, renderTarget);
      };
    };
    THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
    THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
    THREE.OrthographicCamera = function(left, right, top, bottom, near, far) {
      THREE.Camera.call(this);
      this.type = 'OrthographicCamera';
      this.zoom = 1;
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
      this.near = (near !== undefined) ? near : 0.1;
      this.far = (far !== undefined) ? far : 2000;
      this.updateProjectionMatrix();
    };
    THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
    THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
      var dx = (this.right - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.right + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      this.projectionMatrix.makeOrthographic(cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far);
    };
    THREE.OrthographicCamera.prototype.clone = function() {
      var camera = new THREE.OrthographicCamera();
      THREE.Camera.prototype.clone.call(this, camera);
      camera.zoom = this.zoom;
      camera.left = this.left;
      camera.right = this.right;
      camera.top = this.top;
      camera.bottom = this.bottom;
      camera.near = this.near;
      camera.far = this.far;
      camera.projectionMatrix.copy(this.projectionMatrix);
      return camera;
    };
    THREE.PerspectiveCamera = function(fov, aspect, near, far) {
      THREE.Camera.call(this);
      this.type = 'PerspectiveCamera';
      this.zoom = 1;
      this.fov = fov !== undefined ? fov : 50;
      this.aspect = aspect !== undefined ? aspect : 1;
      this.near = near !== undefined ? near : 0.1;
      this.far = far !== undefined ? far : 2000;
      this.updateProjectionMatrix();
    };
    THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
    THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
    THREE.PerspectiveCamera.prototype.setLens = function(focalLength, frameHeight) {
      if (frameHeight === undefined)
        frameHeight = 24;
      this.fov = 2 * THREE.Math.radToDeg(Math.atan(frameHeight / (focalLength * 2)));
      this.updateProjectionMatrix();
    };
    THREE.PerspectiveCamera.prototype.setViewOffset = function(fullWidth, fullHeight, x, y, width, height) {
      this.fullWidth = fullWidth;
      this.fullHeight = fullHeight;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.updateProjectionMatrix();
    };
    THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
      var fov = THREE.Math.radToDeg(2 * Math.atan(Math.tan(THREE.Math.degToRad(this.fov) * 0.5) / this.zoom));
      if (this.fullWidth) {
        var aspect = this.fullWidth / this.fullHeight;
        var top = Math.tan(THREE.Math.degToRad(fov * 0.5)) * this.near;
        var bottom = -top;
        var left = aspect * bottom;
        var right = aspect * top;
        var width = Math.abs(right - left);
        var height = Math.abs(top - bottom);
        this.projectionMatrix.makeFrustum(left + this.x * width / this.fullWidth, left + (this.x + this.width) * width / this.fullWidth, top - (this.y + this.height) * height / this.fullHeight, top - this.y * height / this.fullHeight, this.near, this.far);
      } else {
        this.projectionMatrix.makePerspective(fov, this.aspect, this.near, this.far);
      }
    };
    THREE.PerspectiveCamera.prototype.clone = function() {
      var camera = new THREE.PerspectiveCamera();
      THREE.Camera.prototype.clone.call(this, camera);
      camera.zoom = this.zoom;
      camera.fov = this.fov;
      camera.aspect = this.aspect;
      camera.near = this.near;
      camera.far = this.far;
      camera.projectionMatrix.copy(this.projectionMatrix);
      return camera;
    };
    THREE.Light = function(color) {
      THREE.Object3D.call(this);
      this.type = 'Light';
      this.color = new THREE.Color(color);
    };
    THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Light.prototype.constructor = THREE.Light;
    THREE.Light.prototype.clone = function(light) {
      if (light === undefined)
        light = new THREE.Light();
      THREE.Object3D.prototype.clone.call(this, light);
      light.color.copy(this.color);
      return light;
    };
    THREE.AmbientLight = function(color) {
      THREE.Light.call(this, color);
      this.type = 'AmbientLight';
    };
    THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
    THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
    THREE.AmbientLight.prototype.clone = function() {
      var light = new THREE.AmbientLight();
      THREE.Light.prototype.clone.call(this, light);
      return light;
    };
    THREE.AreaLight = function(color, intensity) {
      THREE.Light.call(this, color);
      this.type = 'AreaLight';
      this.normal = new THREE.Vector3(0, -1, 0);
      this.right = new THREE.Vector3(1, 0, 0);
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.width = 1.0;
      this.height = 1.0;
      this.constantAttenuation = 1.5;
      this.linearAttenuation = 0.5;
      this.quadraticAttenuation = 0.1;
    };
    THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
    THREE.AreaLight.prototype.constructor = THREE.AreaLight;
    THREE.DirectionalLight = function(color, intensity) {
      THREE.Light.call(this, color);
      this.type = 'DirectionalLight';
      this.position.set(0, 1, 0);
      this.target = new THREE.Object3D();
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.castShadow = false;
      this.onlyShadow = false;
      this.shadowCameraNear = 50;
      this.shadowCameraFar = 5000;
      this.shadowCameraLeft = -500;
      this.shadowCameraRight = 500;
      this.shadowCameraTop = 500;
      this.shadowCameraBottom = -500;
      this.shadowCameraVisible = false;
      this.shadowBias = 0;
      this.shadowDarkness = 0.5;
      this.shadowMapWidth = 512;
      this.shadowMapHeight = 512;
      this.shadowCascade = false;
      this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1000);
      this.shadowCascadeCount = 2;
      this.shadowCascadeBias = [0, 0, 0];
      this.shadowCascadeWidth = [512, 512, 512];
      this.shadowCascadeHeight = [512, 512, 512];
      this.shadowCascadeNearZ = [-1.000, 0.990, 0.998];
      this.shadowCascadeFarZ = [0.990, 0.998, 1.000];
      this.shadowCascadeArray = [];
      this.shadowMap = null;
      this.shadowMapSize = null;
      this.shadowCamera = null;
      this.shadowMatrix = null;
    };
    THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
    THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
    THREE.DirectionalLight.prototype.clone = function() {
      var light = new THREE.DirectionalLight();
      THREE.Light.prototype.clone.call(this, light);
      light.target = this.target.clone();
      light.intensity = this.intensity;
      light.castShadow = this.castShadow;
      light.onlyShadow = this.onlyShadow;
      light.shadowCameraNear = this.shadowCameraNear;
      light.shadowCameraFar = this.shadowCameraFar;
      light.shadowCameraLeft = this.shadowCameraLeft;
      light.shadowCameraRight = this.shadowCameraRight;
      light.shadowCameraTop = this.shadowCameraTop;
      light.shadowCameraBottom = this.shadowCameraBottom;
      light.shadowCameraVisible = this.shadowCameraVisible;
      light.shadowBias = this.shadowBias;
      light.shadowDarkness = this.shadowDarkness;
      light.shadowMapWidth = this.shadowMapWidth;
      light.shadowMapHeight = this.shadowMapHeight;
      light.shadowCascade = this.shadowCascade;
      light.shadowCascadeOffset.copy(this.shadowCascadeOffset);
      light.shadowCascadeCount = this.shadowCascadeCount;
      light.shadowCascadeBias = this.shadowCascadeBias.slice(0);
      light.shadowCascadeWidth = this.shadowCascadeWidth.slice(0);
      light.shadowCascadeHeight = this.shadowCascadeHeight.slice(0);
      light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0);
      light.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0);
      return light;
    };
    THREE.HemisphereLight = function(skyColor, groundColor, intensity) {
      THREE.Light.call(this, skyColor);
      this.type = 'HemisphereLight';
      this.position.set(0, 100, 0);
      this.groundColor = new THREE.Color(groundColor);
      this.intensity = (intensity !== undefined) ? intensity : 1;
    };
    THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
    THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
    THREE.HemisphereLight.prototype.clone = function() {
      var light = new THREE.HemisphereLight();
      THREE.Light.prototype.clone.call(this, light);
      light.groundColor.copy(this.groundColor);
      light.intensity = this.intensity;
      return light;
    };
    THREE.PointLight = function(color, intensity, distance, decay) {
      THREE.Light.call(this, color);
      this.type = 'PointLight';
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.distance = (distance !== undefined) ? distance : 0;
      this.decay = (decay !== undefined) ? decay : 1;
    };
    THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
    THREE.PointLight.prototype.constructor = THREE.PointLight;
    THREE.PointLight.prototype.clone = function() {
      var light = new THREE.PointLight();
      THREE.Light.prototype.clone.call(this, light);
      light.intensity = this.intensity;
      light.distance = this.distance;
      light.decay = this.decay;
      return light;
    };
    THREE.SpotLight = function(color, intensity, distance, angle, exponent, decay) {
      THREE.Light.call(this, color);
      this.type = 'SpotLight';
      this.position.set(0, 1, 0);
      this.target = new THREE.Object3D();
      this.intensity = (intensity !== undefined) ? intensity : 1;
      this.distance = (distance !== undefined) ? distance : 0;
      this.angle = (angle !== undefined) ? angle : Math.PI / 3;
      this.exponent = (exponent !== undefined) ? exponent : 10;
      this.decay = (decay !== undefined) ? decay : 1;
      this.castShadow = false;
      this.onlyShadow = false;
      this.shadowCameraNear = 50;
      this.shadowCameraFar = 5000;
      this.shadowCameraFov = 50;
      this.shadowCameraVisible = false;
      this.shadowBias = 0;
      this.shadowDarkness = 0.5;
      this.shadowMapWidth = 512;
      this.shadowMapHeight = 512;
      this.shadowMap = null;
      this.shadowMapSize = null;
      this.shadowCamera = null;
      this.shadowMatrix = null;
    };
    THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
    THREE.SpotLight.prototype.constructor = THREE.SpotLight;
    THREE.SpotLight.prototype.clone = function() {
      var light = new THREE.SpotLight();
      THREE.Light.prototype.clone.call(this, light);
      light.target = this.target.clone();
      light.intensity = this.intensity;
      light.distance = this.distance;
      light.angle = this.angle;
      light.exponent = this.exponent;
      light.decay = this.decay;
      light.castShadow = this.castShadow;
      light.onlyShadow = this.onlyShadow;
      light.shadowCameraNear = this.shadowCameraNear;
      light.shadowCameraFar = this.shadowCameraFar;
      light.shadowCameraFov = this.shadowCameraFov;
      light.shadowCameraVisible = this.shadowCameraVisible;
      light.shadowBias = this.shadowBias;
      light.shadowDarkness = this.shadowDarkness;
      light.shadowMapWidth = this.shadowMapWidth;
      light.shadowMapHeight = this.shadowMapHeight;
      return light;
    };
    THREE.Cache = {
      files: {},
      add: function(key, file) {
        this.files[key] = file;
      },
      get: function(key) {
        return this.files[key];
      },
      remove: function(key) {
        delete this.files[key];
      },
      clear: function() {
        this.files = {};
      }
    };
    THREE.Loader = function(showStatus) {
      this.showStatus = showStatus;
      this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;
      this.imageLoader = new THREE.ImageLoader();
      this.onLoadStart = function() {};
      this.onLoadProgress = function() {};
      this.onLoadComplete = function() {};
    };
    THREE.Loader.prototype = {
      constructor: THREE.Loader,
      crossOrigin: undefined,
      addStatusElement: function() {
        var e = document.createElement('div');
        e.style.position = 'absolute';
        e.style.right = '0px';
        e.style.top = '0px';
        e.style.fontSize = '0.8em';
        e.style.textAlign = 'left';
        e.style.background = 'rgba(0,0,0,0.25)';
        e.style.color = '#fff';
        e.style.width = '120px';
        e.style.padding = '0.5em 0.5em 0.5em 0.5em';
        e.style.zIndex = 1000;
        e.innerHTML = 'Loading ...';
        return e;
      },
      updateProgress: function(progress) {
        var message = 'Loaded ';
        if (progress.total) {
          message += (100 * progress.loaded / progress.total).toFixed(0) + '%';
        } else {
          message += (progress.loaded / 1024).toFixed(2) + ' KB';
        }
        this.statusDomElement.innerHTML = message;
      },
      extractUrlBase: function(url) {
        var parts = url.split('/');
        if (parts.length === 1)
          return './';
        parts.pop();
        return parts.join('/') + '/';
      },
      initMaterials: function(materials, texturePath) {
        var array = [];
        for (var i = 0; i < materials.length; ++i) {
          array[i] = this.createMaterial(materials[i], texturePath);
        }
        return array;
      },
      needsTangents: function(materials) {
        for (var i = 0,
            il = materials.length; i < il; i++) {
          var m = materials[i];
          if (m instanceof THREE.ShaderMaterial)
            return true;
        }
        return false;
      },
      createMaterial: function(m, texturePath) {
        var scope = this;
        function nearest_pow2(n) {
          var l = Math.log(n) / Math.LN2;
          return Math.pow(2, Math.round(l));
        }
        function create_texture(where, name, sourceFile, repeat, offset, wrap, anisotropy) {
          var fullPath = texturePath + sourceFile;
          var texture;
          var loader = THREE.Loader.Handlers.get(fullPath);
          if (loader !== null) {
            texture = loader.load(fullPath);
          } else {
            texture = new THREE.Texture();
            loader = scope.imageLoader;
            loader.crossOrigin = scope.crossOrigin;
            loader.load(fullPath, function(image) {
              if (THREE.Math.isPowerOfTwo(image.width) === false || THREE.Math.isPowerOfTwo(image.height) === false) {
                var width = nearest_pow2(image.width);
                var height = nearest_pow2(image.height);
                var canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                var context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, width, height);
                texture.image = canvas;
              } else {
                texture.image = image;
              }
              texture.needsUpdate = true;
            });
          }
          texture.sourceFile = sourceFile;
          if (repeat) {
            texture.repeat.set(repeat[0], repeat[1]);
            if (repeat[0] !== 1)
              texture.wrapS = THREE.RepeatWrapping;
            if (repeat[1] !== 1)
              texture.wrapT = THREE.RepeatWrapping;
          }
          if (offset) {
            texture.offset.set(offset[0], offset[1]);
          }
          if (wrap) {
            var wrapMap = {
              'repeat': THREE.RepeatWrapping,
              'mirror': THREE.MirroredRepeatWrapping
            };
            if (wrapMap[wrap[0]] !== undefined)
              texture.wrapS = wrapMap[wrap[0]];
            if (wrapMap[wrap[1]] !== undefined)
              texture.wrapT = wrapMap[wrap[1]];
          }
          if (anisotropy) {
            texture.anisotropy = anisotropy;
          }
          where[name] = texture;
        }
        function rgb2hex(rgb) {
          return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + rgb[2] * 255;
        }
        var mtype = 'MeshLambertMaterial';
        var mpars = {
          color: 0xeeeeee,
          opacity: 1.0,
          map: null,
          lightMap: null,
          normalMap: null,
          bumpMap: null,
          wireframe: false
        };
        if (m.shading) {
          var shading = m.shading.toLowerCase();
          if (shading === 'phong')
            mtype = 'MeshPhongMaterial';
          else if (shading === 'basic')
            mtype = 'MeshBasicMaterial';
        }
        if (m.blending !== undefined && THREE[m.blending] !== undefined) {
          mpars.blending = THREE[m.blending];
        }
        if (m.transparent !== undefined) {
          mpars.transparent = m.transparent;
        }
        if (m.opacity !== undefined && m.opacity < 1.0) {
          mpars.transparent = true;
        }
        if (m.depthTest !== undefined) {
          mpars.depthTest = m.depthTest;
        }
        if (m.depthWrite !== undefined) {
          mpars.depthWrite = m.depthWrite;
        }
        if (m.visible !== undefined) {
          mpars.visible = m.visible;
        }
        if (m.flipSided !== undefined) {
          mpars.side = THREE.BackSide;
        }
        if (m.doubleSided !== undefined) {
          mpars.side = THREE.DoubleSide;
        }
        if (m.wireframe !== undefined) {
          mpars.wireframe = m.wireframe;
        }
        if (m.vertexColors !== undefined) {
          if (m.vertexColors === 'face') {
            mpars.vertexColors = THREE.FaceColors;
          } else if (m.vertexColors) {
            mpars.vertexColors = THREE.VertexColors;
          }
        }
        if (m.colorDiffuse) {
          mpars.color = rgb2hex(m.colorDiffuse);
        } else if (m.DbgColor) {
          mpars.color = m.DbgColor;
        }
        if (m.colorSpecular) {
          mpars.specular = rgb2hex(m.colorSpecular);
        }
        if (m.colorEmissive) {
          mpars.emissive = rgb2hex(m.colorEmissive);
        }
        if (m.transparency !== undefined) {
          console.warn('THREE.Loader: transparency has been renamed to opacity');
          m.opacity = m.transparency;
        }
        if (m.opacity !== undefined) {
          mpars.opacity = m.opacity;
        }
        if (m.specularCoef) {
          mpars.shininess = m.specularCoef;
        }
        if (m.mapDiffuse && texturePath) {
          create_texture(mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
        }
        if (m.mapLight && texturePath) {
          create_texture(mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
        }
        if (m.mapBump && texturePath) {
          create_texture(mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
        }
        if (m.mapNormal && texturePath) {
          create_texture(mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
        }
        if (m.mapSpecular && texturePath) {
          create_texture(mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
        }
        if (m.mapAlpha && texturePath) {
          create_texture(mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
        }
        if (m.mapBumpScale) {
          mpars.bumpScale = m.mapBumpScale;
        }
        if (m.mapNormalFactor) {
          mpars.normalScale = new THREE.Vector2(m.mapNormalFactor, m.mapNormalFactor);
        }
        var material = new THREE[mtype](mpars);
        if (m.DbgName !== undefined)
          material.name = m.DbgName;
        return material;
      }
    };
    THREE.Loader.Handlers = {
      handlers: [],
      add: function(regex, loader) {
        this.handlers.push(regex, loader);
      },
      get: function(file) {
        for (var i = 0,
            l = this.handlers.length; i < l; i += 2) {
          var regex = this.handlers[i];
          var loader = this.handlers[i + 1];
          if (regex.test(file)) {
            return loader;
          }
        }
        return null;
      }
    };
    THREE.XHRLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.XHRLoader.prototype = {
      constructor: THREE.XHRLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var cached = THREE.Cache.get(url);
        if (cached !== undefined) {
          if (onLoad)
            onLoad(cached);
          return;
        }
        var request = new XMLHttpRequest();
        request.open('GET', url, true);
        request.addEventListener('load', function(event) {
          THREE.Cache.add(url, this.response);
          if (onLoad)
            onLoad(this.response);
          scope.manager.itemEnd(url);
        }, false);
        if (onProgress !== undefined) {
          request.addEventListener('progress', function(event) {
            onProgress(event);
          }, false);
        }
        if (onError !== undefined) {
          request.addEventListener('error', function(event) {
            onError(event);
          }, false);
        }
        if (this.crossOrigin !== undefined)
          request.crossOrigin = this.crossOrigin;
        if (this.responseType !== undefined)
          request.responseType = this.responseType;
        request.send(null);
        scope.manager.itemStart(url);
      },
      setResponseType: function(value) {
        this.responseType = value;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.ImageLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.ImageLoader.prototype = {
      constructor: THREE.ImageLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var cached = THREE.Cache.get(url);
        if (cached !== undefined) {
          onLoad(cached);
          return;
        }
        var image = document.createElement('img');
        image.addEventListener('load', function(event) {
          THREE.Cache.add(url, this);
          if (onLoad)
            onLoad(this);
          scope.manager.itemEnd(url);
        }, false);
        if (onProgress !== undefined) {
          image.addEventListener('progress', function(event) {
            onProgress(event);
          }, false);
        }
        if (onError !== undefined) {
          image.addEventListener('error', function(event) {
            onError(event);
          }, false);
        }
        if (this.crossOrigin !== undefined)
          image.crossOrigin = this.crossOrigin;
        image.src = url;
        scope.manager.itemStart(url);
        return image;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.JSONLoader = function(showStatus) {
      THREE.Loader.call(this, showStatus);
      this.withCredentials = false;
    };
    THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);
    THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;
    THREE.JSONLoader.prototype.load = function(url, callback, texturePath) {
      texturePath = texturePath && (typeof texturePath === 'string') ? texturePath : this.extractUrlBase(url);
      this.onLoadStart();
      this.loadAjaxJSON(this, url, callback, texturePath);
    };
    THREE.JSONLoader.prototype.loadAjaxJSON = function(context, url, callback, texturePath, callbackProgress) {
      var xhr = new XMLHttpRequest();
      var length = 0;
      xhr.onreadystatechange = function() {
        if (xhr.readyState === xhr.DONE) {
          if (xhr.status === 200 || xhr.status === 0) {
            if (xhr.responseText) {
              var json = JSON.parse(xhr.responseText);
              var metadata = json.metadata;
              if (metadata !== undefined) {
                if (metadata.type === 'object') {
                  THREE.error('THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.');
                  return;
                }
                if (metadata.type === 'scene') {
                  THREE.error('THREE.JSONLoader: ' + url + ' seems to be a Scene. Use THREE.SceneLoader instead.');
                  return;
                }
              }
              var result = context.parse(json, texturePath);
              callback(result.geometry, result.materials);
            } else {
              THREE.error('THREE.JSONLoader: ' + url + ' seems to be unreachable or the file is empty.');
            }
            context.onLoadComplete();
          } else {
            THREE.error('THREE.JSONLoader: Couldn\'t load ' + url + ' (' + xhr.status + ')');
          }
        } else if (xhr.readyState === xhr.LOADING) {
          if (callbackProgress) {
            if (length === 0) {
              length = xhr.getResponseHeader('Content-Length');
            }
            callbackProgress({
              total: length,
              loaded: xhr.responseText.length
            });
          }
        } else if (xhr.readyState === xhr.HEADERS_RECEIVED) {
          if (callbackProgress !== undefined) {
            length = xhr.getResponseHeader('Content-Length');
          }
        }
      };
      xhr.open('GET', url, true);
      xhr.withCredentials = this.withCredentials;
      xhr.send(null);
    };
    THREE.JSONLoader.prototype.parse = function(json, texturePath) {
      var geometry = new THREE.Geometry(),
          scale = (json.scale !== undefined) ? 1.0 / json.scale : 1.0;
      parseModel(scale);
      parseSkin();
      parseMorphing(scale);
      geometry.computeFaceNormals();
      geometry.computeBoundingSphere();
      function parseModel(scale) {
        function isBitSet(value, position) {
          return value & (1 << position);
        }
        var i,
            j,
            fi,
            offset,
            zLength,
            colorIndex,
            normalIndex,
            uvIndex,
            materialIndex,
            type,
            isQuad,
            hasMaterial,
            hasFaceVertexUv,
            hasFaceNormal,
            hasFaceVertexNormal,
            hasFaceColor,
            hasFaceVertexColor,
            vertex,
            face,
            faceA,
            faceB,
            hex,
            normal,
            uvLayer,
            uv,
            u,
            v,
            faces = json.faces,
            vertices = json.vertices,
            normals = json.normals,
            colors = json.colors,
            nUvLayers = 0;
        if (json.uvs !== undefined) {
          for (i = 0; i < json.uvs.length; i++) {
            if (json.uvs[i].length)
              nUvLayers++;
          }
          for (i = 0; i < nUvLayers; i++) {
            geometry.faceVertexUvs[i] = [];
          }
        }
        offset = 0;
        zLength = vertices.length;
        while (offset < zLength) {
          vertex = new THREE.Vector3();
          vertex.x = vertices[offset++] * scale;
          vertex.y = vertices[offset++] * scale;
          vertex.z = vertices[offset++] * scale;
          geometry.vertices.push(vertex);
        }
        offset = 0;
        zLength = faces.length;
        while (offset < zLength) {
          type = faces[offset++];
          isQuad = isBitSet(type, 0);
          hasMaterial = isBitSet(type, 1);
          hasFaceVertexUv = isBitSet(type, 3);
          hasFaceNormal = isBitSet(type, 4);
          hasFaceVertexNormal = isBitSet(type, 5);
          hasFaceColor = isBitSet(type, 6);
          hasFaceVertexColor = isBitSet(type, 7);
          if (isQuad) {
            faceA = new THREE.Face3();
            faceA.a = faces[offset];
            faceA.b = faces[offset + 1];
            faceA.c = faces[offset + 3];
            faceB = new THREE.Face3();
            faceB.a = faces[offset + 1];
            faceB.b = faces[offset + 2];
            faceB.c = faces[offset + 3];
            offset += 4;
            if (hasMaterial) {
              materialIndex = faces[offset++];
              faceA.materialIndex = materialIndex;
              faceB.materialIndex = materialIndex;
            }
            fi = geometry.faces.length;
            if (hasFaceVertexUv) {
              for (i = 0; i < nUvLayers; i++) {
                uvLayer = json.uvs[i];
                geometry.faceVertexUvs[i][fi] = [];
                geometry.faceVertexUvs[i][fi + 1] = [];
                for (j = 0; j < 4; j++) {
                  uvIndex = faces[offset++];
                  u = uvLayer[uvIndex * 2];
                  v = uvLayer[uvIndex * 2 + 1];
                  uv = new THREE.Vector2(u, v);
                  if (j !== 2)
                    geometry.faceVertexUvs[i][fi].push(uv);
                  if (j !== 0)
                    geometry.faceVertexUvs[i][fi + 1].push(uv);
                }
              }
            }
            if (hasFaceNormal) {
              normalIndex = faces[offset++] * 3;
              faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
              faceB.normal.copy(faceA.normal);
            }
            if (hasFaceVertexNormal) {
              for (i = 0; i < 4; i++) {
                normalIndex = faces[offset++] * 3;
                normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                if (i !== 2)
                  faceA.vertexNormals.push(normal);
                if (i !== 0)
                  faceB.vertexNormals.push(normal);
              }
            }
            if (hasFaceColor) {
              colorIndex = faces[offset++];
              hex = colors[colorIndex];
              faceA.color.setHex(hex);
              faceB.color.setHex(hex);
            }
            if (hasFaceVertexColor) {
              for (i = 0; i < 4; i++) {
                colorIndex = faces[offset++];
                hex = colors[colorIndex];
                if (i !== 2)
                  faceA.vertexColors.push(new THREE.Color(hex));
                if (i !== 0)
                  faceB.vertexColors.push(new THREE.Color(hex));
              }
            }
            geometry.faces.push(faceA);
            geometry.faces.push(faceB);
          } else {
            face = new THREE.Face3();
            face.a = faces[offset++];
            face.b = faces[offset++];
            face.c = faces[offset++];
            if (hasMaterial) {
              materialIndex = faces[offset++];
              face.materialIndex = materialIndex;
            }
            fi = geometry.faces.length;
            if (hasFaceVertexUv) {
              for (i = 0; i < nUvLayers; i++) {
                uvLayer = json.uvs[i];
                geometry.faceVertexUvs[i][fi] = [];
                for (j = 0; j < 3; j++) {
                  uvIndex = faces[offset++];
                  u = uvLayer[uvIndex * 2];
                  v = uvLayer[uvIndex * 2 + 1];
                  uv = new THREE.Vector2(u, v);
                  geometry.faceVertexUvs[i][fi].push(uv);
                }
              }
            }
            if (hasFaceNormal) {
              normalIndex = faces[offset++] * 3;
              face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
            }
            if (hasFaceVertexNormal) {
              for (i = 0; i < 3; i++) {
                normalIndex = faces[offset++] * 3;
                normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
                face.vertexNormals.push(normal);
              }
            }
            if (hasFaceColor) {
              colorIndex = faces[offset++];
              face.color.setHex(colors[colorIndex]);
            }
            if (hasFaceVertexColor) {
              for (i = 0; i < 3; i++) {
                colorIndex = faces[offset++];
                face.vertexColors.push(new THREE.Color(colors[colorIndex]));
              }
            }
            geometry.faces.push(face);
          }
        }
      }
      ;
      function parseSkin() {
        var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;
        if (json.skinWeights) {
          for (var i = 0,
              l = json.skinWeights.length; i < l; i += influencesPerVertex) {
            var x = json.skinWeights[i];
            var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
            var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
            var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;
            geometry.skinWeights.push(new THREE.Vector4(x, y, z, w));
          }
        }
        if (json.skinIndices) {
          for (var i = 0,
              l = json.skinIndices.length; i < l; i += influencesPerVertex) {
            var a = json.skinIndices[i];
            var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
            var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
            var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;
            geometry.skinIndices.push(new THREE.Vector4(a, b, c, d));
          }
        }
        geometry.bones = json.bones;
        if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
          THREE.warn('THREE.JSONLoader: When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
        }
        geometry.animation = json.animation;
        geometry.animations = json.animations;
      }
      ;
      function parseMorphing(scale) {
        if (json.morphTargets !== undefined) {
          var i,
              l,
              v,
              vl,
              dstVertices,
              srcVertices;
          for (i = 0, l = json.morphTargets.length; i < l; i++) {
            geometry.morphTargets[i] = {};
            geometry.morphTargets[i].name = json.morphTargets[i].name;
            geometry.morphTargets[i].vertices = [];
            dstVertices = geometry.morphTargets[i].vertices;
            srcVertices = json.morphTargets[i].vertices;
            for (v = 0, vl = srcVertices.length; v < vl; v += 3) {
              var vertex = new THREE.Vector3();
              vertex.x = srcVertices[v] * scale;
              vertex.y = srcVertices[v + 1] * scale;
              vertex.z = srcVertices[v + 2] * scale;
              dstVertices.push(vertex);
            }
          }
        }
        if (json.morphColors !== undefined) {
          var i,
              l,
              c,
              cl,
              dstColors,
              srcColors,
              color;
          for (i = 0, l = json.morphColors.length; i < l; i++) {
            geometry.morphColors[i] = {};
            geometry.morphColors[i].name = json.morphColors[i].name;
            geometry.morphColors[i].colors = [];
            dstColors = geometry.morphColors[i].colors;
            srcColors = json.morphColors[i].colors;
            for (c = 0, cl = srcColors.length; c < cl; c += 3) {
              color = new THREE.Color(0xffaa00);
              color.setRGB(srcColors[c], srcColors[c + 1], srcColors[c + 2]);
              dstColors.push(color);
            }
          }
        }
      }
      ;
      if (json.materials === undefined || json.materials.length === 0) {
        return {geometry: geometry};
      } else {
        var materials = this.initMaterials(json.materials, texturePath);
        if (this.needsTangents(materials)) {
          geometry.computeTangents();
        }
        return {
          geometry: geometry,
          materials: materials
        };
      }
    };
    THREE.LoadingManager = function(onLoad, onProgress, onError) {
      var scope = this;
      var loaded = 0,
          total = 0;
      this.onLoad = onLoad;
      this.onProgress = onProgress;
      this.onError = onError;
      this.itemStart = function(url) {
        total++;
      };
      this.itemEnd = function(url) {
        loaded++;
        if (scope.onProgress !== undefined) {
          scope.onProgress(url, loaded, total);
        }
        if (loaded === total && scope.onLoad !== undefined) {
          scope.onLoad();
        }
      };
    };
    THREE.DefaultLoadingManager = new THREE.LoadingManager();
    THREE.BufferGeometryLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.BufferGeometryLoader.prototype = {
      constructor: THREE.BufferGeometryLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
          onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      parse: function(json) {
        var geometry = new THREE.BufferGeometry();
        var attributes = json.data.attributes;
        for (var key in attributes) {
          var attribute = attributes[key];
          var typedArray = new self[attribute.type](attribute.array);
          geometry.addAttribute(key, new THREE.BufferAttribute(typedArray, attribute.itemSize));
        }
        var offsets = json.data.offsets;
        if (offsets !== undefined) {
          geometry.offsets = JSON.parse(JSON.stringify(offsets));
        }
        var boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
          var center = new THREE.Vector3();
          if (boundingSphere.center !== undefined) {
            center.fromArray(boundingSphere.center);
          }
          geometry.boundingSphere = new THREE.Sphere(center, boundingSphere.radius);
        }
        return geometry;
      }
    };
    THREE.MaterialLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.MaterialLoader.prototype = {
      constructor: THREE.MaterialLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
          onLoad(scope.parse(JSON.parse(text)));
        }, onProgress, onError);
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      parse: function(json) {
        var material = new THREE[json.type];
        if (json.color !== undefined)
          material.color.setHex(json.color);
        if (json.emissive !== undefined)
          material.emissive.setHex(json.emissive);
        if (json.specular !== undefined)
          material.specular.setHex(json.specular);
        if (json.shininess !== undefined)
          material.shininess = json.shininess;
        if (json.uniforms !== undefined)
          material.uniforms = json.uniforms;
        if (json.vertexShader !== undefined)
          material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined)
          material.fragmentShader = json.fragmentShader;
        if (json.vertexColors !== undefined)
          material.vertexColors = json.vertexColors;
        if (json.shading !== undefined)
          material.shading = json.shading;
        if (json.blending !== undefined)
          material.blending = json.blending;
        if (json.side !== undefined)
          material.side = json.side;
        if (json.opacity !== undefined)
          material.opacity = json.opacity;
        if (json.transparent !== undefined)
          material.transparent = json.transparent;
        if (json.wireframe !== undefined)
          material.wireframe = json.wireframe;
        if (json.size !== undefined)
          material.size = json.size;
        if (json.sizeAttenuation !== undefined)
          material.sizeAttenuation = json.sizeAttenuation;
        if (json.materials !== undefined) {
          for (var i = 0,
              l = json.materials.length; i < l; i++) {
            material.materials.push(this.parse(json.materials[i]));
          }
        }
        return material;
      }
    };
    THREE.ObjectLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
      this.texturePath = '';
    };
    THREE.ObjectLoader.prototype = {
      constructor: THREE.ObjectLoader,
      load: function(url, onLoad, onProgress, onError) {
        if (this.texturePath === '') {
          this.texturePath = url.substring(0, url.lastIndexOf('/') + 1);
        }
        var scope = this;
        var loader = new THREE.XHRLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(text) {
          scope.parse(JSON.parse(text), onLoad);
        }, onProgress, onError);
      },
      setTexturePath: function(value) {
        this.texturePath = value;
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      },
      parse: function(json, onLoad) {
        var geometries = this.parseGeometries(json.geometries);
        var images = this.parseImages(json.images, function() {
          if (onLoad !== undefined)
            onLoad(object);
        });
        var textures = this.parseTextures(json.textures, images);
        var materials = this.parseMaterials(json.materials, textures);
        var object = this.parseObject(json.object, geometries, materials);
        if (json.images === undefined || json.images.length === 0) {
          if (onLoad !== undefined)
            onLoad(object);
        }
        return object;
      },
      parseGeometries: function(json) {
        var geometries = {};
        if (json !== undefined) {
          var geometryLoader = new THREE.JSONLoader();
          var bufferGeometryLoader = new THREE.BufferGeometryLoader();
          for (var i = 0,
              l = json.length; i < l; i++) {
            var geometry;
            var data = json[i];
            switch (data.type) {
              case 'PlaneGeometry':
              case 'PlaneBufferGeometry':
                geometry = new THREE[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                break;
              case 'BoxGeometry':
              case 'CubeGeometry':
                geometry = new THREE.BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                break;
              case 'CircleGeometry':
                geometry = new THREE.CircleGeometry(data.radius, data.segments);
                break;
              case 'CylinderGeometry':
                geometry = new THREE.CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded);
                break;
              case 'SphereGeometry':
                geometry = new THREE.SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                break;
              case 'IcosahedronGeometry':
                geometry = new THREE.IcosahedronGeometry(data.radius, data.detail);
                break;
              case 'TorusGeometry':
                geometry = new THREE.TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                break;
              case 'TorusKnotGeometry':
                geometry = new THREE.TorusKnotGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.p, data.q, data.heightScale);
                break;
              case 'BufferGeometry':
                geometry = bufferGeometryLoader.parse(data);
                break;
              case 'Geometry':
                geometry = geometryLoader.parse(data.data).geometry;
                break;
            }
            geometry.uuid = data.uuid;
            if (data.name !== undefined)
              geometry.name = data.name;
            geometries[data.uuid] = geometry;
          }
        }
        return geometries;
      },
      parseMaterials: function(json, textures) {
        var materials = {};
        if (json !== undefined) {
          var getTexture = function(name) {
            if (textures[name] === undefined) {
              THREE.warn('THREE.ObjectLoader: Undefined texture', name);
            }
            return textures[name];
          };
          var loader = new THREE.MaterialLoader();
          for (var i = 0,
              l = json.length; i < l; i++) {
            var data = json[i];
            var material = loader.parse(data);
            material.uuid = data.uuid;
            if (data.name !== undefined)
              material.name = data.name;
            if (data.map !== undefined) {
              material.map = getTexture(data.map);
            }
            if (data.bumpMap !== undefined) {
              material.bumpMap = getTexture(data.bumpMap);
              if (data.bumpScale) {
                material.bumpScale = new THREE.Vector2(data.bumpScale, data.bumpScale);
              }
            }
            if (data.alphaMap !== undefined) {
              material.alphaMap = getTexture(data.alphaMap);
            }
            if (data.envMap !== undefined) {
              material.envMap = getTexture(data.envMap);
            }
            if (data.normalMap !== undefined) {
              material.normalMap = getTexture(data.normalMap);
              if (data.normalScale) {
                material.normalScale = new THREE.Vector2(data.normalScale, data.normalScale);
              }
            }
            if (data.lightMap !== undefined) {
              material.lightMap = getTexture(data.lightMap);
            }
            if (data.specularMap !== undefined) {
              material.specularMap = getTexture(data.specularMap);
            }
            materials[data.uuid] = material;
          }
        }
        return materials;
      },
      parseImages: function(json, onLoad) {
        var scope = this;
        var images = {};
        if (json !== undefined && json.length > 0) {
          var manager = new THREE.LoadingManager(onLoad);
          var loader = new THREE.ImageLoader(manager);
          loader.setCrossOrigin(this.crossOrigin);
          var loadImage = function(url) {
            scope.manager.itemStart(url);
            return loader.load(url, function() {
              scope.manager.itemEnd(url);
            });
          };
          for (var i = 0,
              l = json.length; i < l; i++) {
            var image = json[i];
            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.texturePath + image.url;
            images[image.uuid] = loadImage(path);
          }
        }
        return images;
      },
      parseTextures: function(json, images) {
        var textures = {};
        if (json !== undefined) {
          for (var i = 0,
              l = json.length; i < l; i++) {
            var data = json[i];
            if (data.image === undefined) {
              THREE.warn('THREE.ObjectLoader: No "image" speficied for', data.uuid);
            }
            if (images[data.image] === undefined) {
              THREE.warn('THREE.ObjectLoader: Undefined image', data.image);
            }
            var texture = new THREE.Texture(images[data.image]);
            texture.needsUpdate = true;
            texture.uuid = data.uuid;
            if (data.name !== undefined)
              texture.name = data.name;
            if (data.repeat !== undefined)
              texture.repeat = new THREE.Vector2(data.repeat[0], data.repeat[1]);
            if (data.minFilter !== undefined)
              texture.minFilter = THREE[data.minFilter];
            if (data.magFilter !== undefined)
              texture.magFilter = THREE[data.magFilter];
            if (data.anisotropy !== undefined)
              texture.anisotropy = data.anisotropy;
            if (data.wrap instanceof Array) {
              texture.wrapS = THREE[data.wrap[0]];
              texture.wrapT = THREE[data.wrap[1]];
            }
            textures[data.uuid] = texture;
          }
        }
        return textures;
      },
      parseObject: function() {
        var matrix = new THREE.Matrix4();
        return function(data, geometries, materials) {
          var object;
          var getGeometry = function(name) {
            if (geometries[name] === undefined) {
              THREE.warn('THREE.ObjectLoader: Undefined geometry', name);
            }
            return geometries[name];
          };
          var getMaterial = function(name) {
            if (materials[name] === undefined) {
              THREE.warn('THREE.ObjectLoader: Undefined material', name);
            }
            return materials[name];
          };
          switch (data.type) {
            case 'Scene':
              object = new THREE.Scene();
              break;
            case 'PerspectiveCamera':
              object = new THREE.PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
              break;
            case 'OrthographicCamera':
              object = new THREE.OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
              break;
            case 'AmbientLight':
              object = new THREE.AmbientLight(data.color);
              break;
            case 'DirectionalLight':
              object = new THREE.DirectionalLight(data.color, data.intensity);
              break;
            case 'PointLight':
              object = new THREE.PointLight(data.color, data.intensity, data.distance, data.decay);
              break;
            case 'SpotLight':
              object = new THREE.SpotLight(data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay);
              break;
            case 'HemisphereLight':
              object = new THREE.HemisphereLight(data.color, data.groundColor, data.intensity);
              break;
            case 'Mesh':
              object = new THREE.Mesh(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case 'Line':
              object = new THREE.Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
              break;
            case 'PointCloud':
              object = new THREE.PointCloud(getGeometry(data.geometry), getMaterial(data.material));
              break;
            case 'Sprite':
              object = new THREE.Sprite(getMaterial(data.material));
              break;
            case 'Group':
              object = new THREE.Group();
              break;
            default:
              object = new THREE.Object3D();
          }
          object.uuid = data.uuid;
          if (data.name !== undefined)
            object.name = data.name;
          if (data.matrix !== undefined) {
            matrix.fromArray(data.matrix);
            matrix.decompose(object.position, object.quaternion, object.scale);
          } else {
            if (data.position !== undefined)
              object.position.fromArray(data.position);
            if (data.rotation !== undefined)
              object.rotation.fromArray(data.rotation);
            if (data.scale !== undefined)
              object.scale.fromArray(data.scale);
          }
          if (data.visible !== undefined)
            object.visible = data.visible;
          if (data.userData !== undefined)
            object.userData = data.userData;
          if (data.children !== undefined) {
            for (var child in data.children) {
              object.add(this.parseObject(data.children[child], geometries, materials));
            }
          }
          return object;
        };
      }()
    };
    THREE.TextureLoader = function(manager) {
      this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;
    };
    THREE.TextureLoader.prototype = {
      constructor: THREE.TextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new THREE.ImageLoader(scope.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.load(url, function(image) {
          var texture = new THREE.Texture(image);
          texture.needsUpdate = true;
          if (onLoad !== undefined) {
            onLoad(texture);
          }
        }, onProgress, onError);
      },
      setCrossOrigin: function(value) {
        this.crossOrigin = value;
      }
    };
    THREE.DataTextureLoader = THREE.BinaryTextureLoader = function() {
      this._parser = null;
    };
    THREE.BinaryTextureLoader.prototype = {
      constructor: THREE.BinaryTextureLoader,
      load: function(url, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new THREE.DataTexture();
        var loader = new THREE.XHRLoader();
        loader.setResponseType('arraybuffer');
        loader.load(url, function(buffer) {
          var texData = scope._parser(buffer);
          if (!texData)
            return;
          if (undefined !== texData.image) {
            texture.image = texData.image;
          } else if (undefined !== texData.data) {
            texture.image.width = texData.width;
            texture.image.height = texData.height;
            texture.image.data = texData.data;
          }
          texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
          texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;
          texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
          texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;
          texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
          if (undefined !== texData.format) {
            texture.format = texData.format;
          }
          if (undefined !== texData.type) {
            texture.type = texData.type;
          }
          if (undefined !== texData.mipmaps) {
            texture.mipmaps = texData.mipmaps;
          }
          if (1 === texData.mipmapCount) {
            texture.minFilter = THREE.LinearFilter;
          }
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
      }
    };
    THREE.CompressedTextureLoader = function() {
      this._parser = null;
    };
    THREE.CompressedTextureLoader.prototype = {
      constructor: THREE.CompressedTextureLoader,
      load: function(url, onLoad, onError) {
        var scope = this;
        var images = [];
        var texture = new THREE.CompressedTexture();
        texture.image = images;
        var loader = new THREE.XHRLoader();
        loader.setResponseType('arraybuffer');
        if (url instanceof Array) {
          var loaded = 0;
          var loadTexture = function(i) {
            loader.load(url[i], function(buffer) {
              var texDatas = scope._parser(buffer, true);
              images[i] = {
                width: texDatas.width,
                height: texDatas.height,
                format: texDatas.format,
                mipmaps: texDatas.mipmaps
              };
              loaded += 1;
              if (loaded === 6) {
                if (texDatas.mipmapCount == 1)
                  texture.minFilter = THREE.LinearFilter;
                texture.format = texDatas.format;
                texture.needsUpdate = true;
                if (onLoad)
                  onLoad(texture);
              }
            });
          };
          for (var i = 0,
              il = url.length; i < il; ++i) {
            loadTexture(i);
          }
        } else {
          loader.load(url, function(buffer) {
            var texDatas = scope._parser(buffer, true);
            if (texDatas.isCubemap) {
              var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
              for (var f = 0; f < faces; f++) {
                images[f] = {mipmaps: []};
                for (var i = 0; i < texDatas.mipmapCount; i++) {
                  images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                  images[f].format = texDatas.format;
                  images[f].width = texDatas.width;
                  images[f].height = texDatas.height;
                }
              }
            } else {
              texture.image.width = texDatas.width;
              texture.image.height = texDatas.height;
              texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) {
              texture.minFilter = THREE.LinearFilter;
            }
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          });
        }
        return texture;
      }
    };
    THREE.Material = function() {
      Object.defineProperty(this, 'id', {value: THREE.MaterialIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.type = 'Material';
      this.side = THREE.FrontSide;
      this.opacity = 1;
      this.transparent = false;
      this.blending = THREE.NormalBlending;
      this.blendSrc = THREE.SrcAlphaFactor;
      this.blendDst = THREE.OneMinusSrcAlphaFactor;
      this.blendEquation = THREE.AddEquation;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;
      this.depthTest = true;
      this.depthWrite = true;
      this.colorWrite = true;
      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;
      this.alphaTest = 0;
      this.overdraw = 0;
      this.visible = true;
      this._needsUpdate = true;
    };
    THREE.Material.prototype = {
      constructor: THREE.Material,
      get needsUpdate() {
        return this._needsUpdate;
      },
      set needsUpdate(value) {
        if (value === true)
          this.update();
        this._needsUpdate = value;
      },
      setValues: function(values) {
        if (values === undefined)
          return;
        for (var key in values) {
          var newValue = values[key];
          if (newValue === undefined) {
            THREE.warn("THREE.Material: '" + key + "' parameter is undefined.");
            continue;
          }
          if (key in this) {
            var currentValue = this[key];
            if (currentValue instanceof THREE.Color) {
              currentValue.set(newValue);
            } else if (currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3) {
              currentValue.copy(newValue);
            } else if (key == 'overdraw') {
              this[key] = Number(newValue);
            } else {
              this[key] = newValue;
            }
          }
        }
      },
      toJSON: function() {
        var output = {
          metadata: {
            version: 4.2,
            type: 'material',
            generator: 'MaterialExporter'
          },
          uuid: this.uuid,
          type: this.type
        };
        if (this.name !== "")
          output.name = this.name;
        if (this instanceof THREE.MeshBasicMaterial) {
          output.color = this.color.getHex();
          if (this.vertexColors !== THREE.NoColors)
            output.vertexColors = this.vertexColors;
          if (this.blending !== THREE.NormalBlending)
            output.blending = this.blending;
          if (this.side !== THREE.FrontSide)
            output.side = this.side;
        } else if (this instanceof THREE.MeshLambertMaterial) {
          output.color = this.color.getHex();
          output.emissive = this.emissive.getHex();
          if (this.vertexColors !== THREE.NoColors)
            output.vertexColors = this.vertexColors;
          if (this.shading !== THREE.SmoothShading)
            output.shading = this.shading;
          if (this.blending !== THREE.NormalBlending)
            output.blending = this.blending;
          if (this.side !== THREE.FrontSide)
            output.side = this.side;
        } else if (this instanceof THREE.MeshPhongMaterial) {
          output.color = this.color.getHex();
          output.emissive = this.emissive.getHex();
          output.specular = this.specular.getHex();
          output.shininess = this.shininess;
          if (this.vertexColors !== THREE.NoColors)
            output.vertexColors = this.vertexColors;
          if (this.shading !== THREE.SmoothShading)
            output.shading = this.shading;
          if (this.blending !== THREE.NormalBlending)
            output.blending = this.blending;
          if (this.side !== THREE.FrontSide)
            output.side = this.side;
        } else if (this instanceof THREE.MeshNormalMaterial) {
          if (this.blending !== THREE.NormalBlending)
            output.blending = this.blending;
          if (this.side !== THREE.FrontSide)
            output.side = this.side;
        } else if (this instanceof THREE.MeshDepthMaterial) {
          if (this.blending !== THREE.NormalBlending)
            output.blending = this.blending;
          if (this.side !== THREE.FrontSide)
            output.side = this.side;
        } else if (this instanceof THREE.PointCloudMaterial) {
          output.size = this.size;
          output.sizeAttenuation = this.sizeAttenuation;
          output.color = this.color.getHex();
          if (this.vertexColors !== THREE.NoColors)
            output.vertexColors = this.vertexColors;
          if (this.blending !== THREE.NormalBlending)
            output.blending = this.blending;
        } else if (this instanceof THREE.ShaderMaterial) {
          output.uniforms = this.uniforms;
          output.vertexShader = this.vertexShader;
          output.fragmentShader = this.fragmentShader;
        } else if (this instanceof THREE.SpriteMaterial) {
          output.color = this.color.getHex();
        }
        if (this.opacity < 1)
          output.opacity = this.opacity;
        if (this.transparent !== false)
          output.transparent = this.transparent;
        if (this.wireframe !== false)
          output.wireframe = this.wireframe;
        return output;
      },
      clone: function(material) {
        if (material === undefined)
          material = new THREE.Material();
        material.name = this.name;
        material.side = this.side;
        material.opacity = this.opacity;
        material.transparent = this.transparent;
        material.blending = this.blending;
        material.blendSrc = this.blendSrc;
        material.blendDst = this.blendDst;
        material.blendEquation = this.blendEquation;
        material.blendSrcAlpha = this.blendSrcAlpha;
        material.blendDstAlpha = this.blendDstAlpha;
        material.blendEquationAlpha = this.blendEquationAlpha;
        material.depthTest = this.depthTest;
        material.depthWrite = this.depthWrite;
        material.polygonOffset = this.polygonOffset;
        material.polygonOffsetFactor = this.polygonOffsetFactor;
        material.polygonOffsetUnits = this.polygonOffsetUnits;
        material.alphaTest = this.alphaTest;
        material.overdraw = this.overdraw;
        material.visible = this.visible;
        return material;
      },
      update: function() {
        this.dispatchEvent({type: 'update'});
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
    THREE.MaterialIdCount = 0;
    THREE.LineBasicMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'LineBasicMaterial';
      this.color = new THREE.Color(0xffffff);
      this.linewidth = 1;
      this.linecap = 'round';
      this.linejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.fog = true;
      this.setValues(parameters);
    };
    THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
    THREE.LineBasicMaterial.prototype.clone = function() {
      var material = new THREE.LineBasicMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.linewidth = this.linewidth;
      material.linecap = this.linecap;
      material.linejoin = this.linejoin;
      material.vertexColors = this.vertexColors;
      material.fog = this.fog;
      return material;
    };
    THREE.LineDashedMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'LineDashedMaterial';
      this.color = new THREE.Color(0xffffff);
      this.linewidth = 1;
      this.scale = 1;
      this.dashSize = 3;
      this.gapSize = 1;
      this.vertexColors = false;
      this.fog = true;
      this.setValues(parameters);
    };
    THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
    THREE.LineDashedMaterial.prototype.clone = function() {
      var material = new THREE.LineDashedMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.linewidth = this.linewidth;
      material.scale = this.scale;
      material.dashSize = this.dashSize;
      material.gapSize = this.gapSize;
      material.vertexColors = this.vertexColors;
      material.fog = this.fog;
      return material;
    };
    THREE.MeshBasicMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshBasicMaterial';
      this.color = new THREE.Color(0xffffff);
      this.map = null;
      this.lightMap = null;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = THREE.MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.fog = true;
      this.shading = THREE.SmoothShading;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.setValues(parameters);
    };
    THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
    THREE.MeshBasicMaterial.prototype.clone = function() {
      var material = new THREE.MeshBasicMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.map = this.map;
      material.lightMap = this.lightMap;
      material.specularMap = this.specularMap;
      material.alphaMap = this.alphaMap;
      material.envMap = this.envMap;
      material.combine = this.combine;
      material.reflectivity = this.reflectivity;
      material.refractionRatio = this.refractionRatio;
      material.fog = this.fog;
      material.shading = this.shading;
      material.wireframe = this.wireframe;
      material.wireframeLinewidth = this.wireframeLinewidth;
      material.wireframeLinecap = this.wireframeLinecap;
      material.wireframeLinejoin = this.wireframeLinejoin;
      material.vertexColors = this.vertexColors;
      material.skinning = this.skinning;
      material.morphTargets = this.morphTargets;
      return material;
    };
    THREE.MeshLambertMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshLambertMaterial';
      this.color = new THREE.Color(0xffffff);
      this.emissive = new THREE.Color(0x000000);
      this.wrapAround = false;
      this.wrapRGB = new THREE.Vector3(1, 1, 1);
      this.map = null;
      this.lightMap = null;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = THREE.MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.fog = true;
      this.shading = THREE.SmoothShading;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    };
    THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
    THREE.MeshLambertMaterial.prototype.clone = function() {
      var material = new THREE.MeshLambertMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.emissive.copy(this.emissive);
      material.wrapAround = this.wrapAround;
      material.wrapRGB.copy(this.wrapRGB);
      material.map = this.map;
      material.lightMap = this.lightMap;
      material.specularMap = this.specularMap;
      material.alphaMap = this.alphaMap;
      material.envMap = this.envMap;
      material.combine = this.combine;
      material.reflectivity = this.reflectivity;
      material.refractionRatio = this.refractionRatio;
      material.fog = this.fog;
      material.shading = this.shading;
      material.wireframe = this.wireframe;
      material.wireframeLinewidth = this.wireframeLinewidth;
      material.wireframeLinecap = this.wireframeLinecap;
      material.wireframeLinejoin = this.wireframeLinejoin;
      material.vertexColors = this.vertexColors;
      material.skinning = this.skinning;
      material.morphTargets = this.morphTargets;
      material.morphNormals = this.morphNormals;
      return material;
    };
    THREE.MeshPhongMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshPhongMaterial';
      this.color = new THREE.Color(0xffffff);
      this.emissive = new THREE.Color(0x000000);
      this.specular = new THREE.Color(0x111111);
      this.shininess = 30;
      this.metal = false;
      this.wrapAround = false;
      this.wrapRGB = new THREE.Vector3(1, 1, 1);
      this.map = null;
      this.lightMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalScale = new THREE.Vector2(1, 1);
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = THREE.MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.fog = true;
      this.shading = THREE.SmoothShading;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = 'round';
      this.wireframeLinejoin = 'round';
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.setValues(parameters);
    };
    THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
    THREE.MeshPhongMaterial.prototype.clone = function() {
      var material = new THREE.MeshPhongMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.emissive.copy(this.emissive);
      material.specular.copy(this.specular);
      material.shininess = this.shininess;
      material.metal = this.metal;
      material.wrapAround = this.wrapAround;
      material.wrapRGB.copy(this.wrapRGB);
      material.map = this.map;
      material.lightMap = this.lightMap;
      material.bumpMap = this.bumpMap;
      material.bumpScale = this.bumpScale;
      material.normalMap = this.normalMap;
      material.normalScale.copy(this.normalScale);
      material.specularMap = this.specularMap;
      material.alphaMap = this.alphaMap;
      material.envMap = this.envMap;
      material.combine = this.combine;
      material.reflectivity = this.reflectivity;
      material.refractionRatio = this.refractionRatio;
      material.fog = this.fog;
      material.shading = this.shading;
      material.wireframe = this.wireframe;
      material.wireframeLinewidth = this.wireframeLinewidth;
      material.wireframeLinecap = this.wireframeLinecap;
      material.wireframeLinejoin = this.wireframeLinejoin;
      material.vertexColors = this.vertexColors;
      material.skinning = this.skinning;
      material.morphTargets = this.morphTargets;
      material.morphNormals = this.morphNormals;
      return material;
    };
    THREE.MeshDepthMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'MeshDepthMaterial';
      this.morphTargets = false;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.setValues(parameters);
    };
    THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
    THREE.MeshDepthMaterial.prototype.clone = function() {
      var material = new THREE.MeshDepthMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.wireframe = this.wireframe;
      material.wireframeLinewidth = this.wireframeLinewidth;
      return material;
    };
    THREE.MeshNormalMaterial = function(parameters) {
      THREE.Material.call(this, parameters);
      this.type = 'MeshNormalMaterial';
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.morphTargets = false;
      this.setValues(parameters);
    };
    THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
    THREE.MeshNormalMaterial.prototype.clone = function() {
      var material = new THREE.MeshNormalMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.wireframe = this.wireframe;
      material.wireframeLinewidth = this.wireframeLinewidth;
      return material;
    };
    THREE.MeshFaceMaterial = function(materials) {
      this.uuid = THREE.Math.generateUUID();
      this.type = 'MeshFaceMaterial';
      this.materials = materials instanceof Array ? materials : [];
    };
    THREE.MeshFaceMaterial.prototype = {
      constructor: THREE.MeshFaceMaterial,
      toJSON: function() {
        var output = {
          metadata: {
            version: 4.2,
            type: 'material',
            generator: 'MaterialExporter'
          },
          uuid: this.uuid,
          type: this.type,
          materials: []
        };
        for (var i = 0,
            l = this.materials.length; i < l; i++) {
          output.materials.push(this.materials[i].toJSON());
        }
        return output;
      },
      clone: function() {
        var material = new THREE.MeshFaceMaterial();
        for (var i = 0; i < this.materials.length; i++) {
          material.materials.push(this.materials[i].clone());
        }
        return material;
      }
    };
    THREE.PointCloudMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'PointCloudMaterial';
      this.color = new THREE.Color(0xffffff);
      this.map = null;
      this.size = 1;
      this.sizeAttenuation = true;
      this.vertexColors = THREE.NoColors;
      this.fog = true;
      this.setValues(parameters);
    };
    THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;
    THREE.PointCloudMaterial.prototype.clone = function() {
      var material = new THREE.PointCloudMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.map = this.map;
      material.size = this.size;
      material.sizeAttenuation = this.sizeAttenuation;
      material.vertexColors = this.vertexColors;
      material.fog = this.fog;
      return material;
    };
    THREE.ParticleBasicMaterial = function(parameters) {
      THREE.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.');
      return new THREE.PointCloudMaterial(parameters);
    };
    THREE.ParticleSystemMaterial = function(parameters) {
      THREE.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.');
      return new THREE.PointCloudMaterial(parameters);
    };
    THREE.ShaderMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'ShaderMaterial';
      this.defines = {};
      this.uniforms = {};
      this.attributes = null;
      this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
      this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
      this.shading = THREE.SmoothShading;
      this.linewidth = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.lights = false;
      this.vertexColors = THREE.NoColors;
      this.skinning = false;
      this.morphTargets = false;
      this.morphNormals = false;
      this.defaultAttributeValues = {
        'color': [1, 1, 1],
        'uv': [0, 0],
        'uv2': [0, 0]
      };
      this.index0AttributeName = undefined;
      this.setValues(parameters);
    };
    THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
    THREE.ShaderMaterial.prototype.clone = function() {
      var material = new THREE.ShaderMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.fragmentShader = this.fragmentShader;
      material.vertexShader = this.vertexShader;
      material.uniforms = THREE.UniformsUtils.clone(this.uniforms);
      material.attributes = this.attributes;
      material.defines = this.defines;
      material.shading = this.shading;
      material.wireframe = this.wireframe;
      material.wireframeLinewidth = this.wireframeLinewidth;
      material.fog = this.fog;
      material.lights = this.lights;
      material.vertexColors = this.vertexColors;
      material.skinning = this.skinning;
      material.morphTargets = this.morphTargets;
      material.morphNormals = this.morphNormals;
      return material;
    };
    THREE.RawShaderMaterial = function(parameters) {
      THREE.ShaderMaterial.call(this, parameters);
      this.type = 'RawShaderMaterial';
    };
    THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
    THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
    THREE.RawShaderMaterial.prototype.clone = function() {
      var material = new THREE.RawShaderMaterial();
      THREE.ShaderMaterial.prototype.clone.call(this, material);
      return material;
    };
    THREE.SpriteMaterial = function(parameters) {
      THREE.Material.call(this);
      this.type = 'SpriteMaterial';
      this.color = new THREE.Color(0xffffff);
      this.map = null;
      this.rotation = 0;
      this.fog = false;
      this.setValues(parameters);
    };
    THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
    THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
    THREE.SpriteMaterial.prototype.clone = function() {
      var material = new THREE.SpriteMaterial();
      THREE.Material.prototype.clone.call(this, material);
      material.color.copy(this.color);
      material.map = this.map;
      material.rotation = this.rotation;
      material.fog = this.fog;
      return material;
    };
    THREE.Texture = function(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      Object.defineProperty(this, 'id', {value: THREE.TextureIdCount++});
      this.uuid = THREE.Math.generateUUID();
      this.name = '';
      this.sourceFile = '';
      this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
      this.mipmaps = [];
      this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;
      this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
      this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;
      this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
      this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;
      this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
      this.format = format !== undefined ? format : THREE.RGBAFormat;
      this.type = type !== undefined ? type : THREE.UnsignedByteType;
      this.offset = new THREE.Vector2(0, 0);
      this.repeat = new THREE.Vector2(1, 1);
      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4;
      this._needsUpdate = false;
      this.onUpdate = null;
    };
    THREE.Texture.DEFAULT_IMAGE = undefined;
    THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
    THREE.Texture.prototype = {
      constructor: THREE.Texture,
      get needsUpdate() {
        return this._needsUpdate;
      },
      set needsUpdate(value) {
        if (value === true)
          this.update();
        this._needsUpdate = value;
      },
      clone: function(texture) {
        if (texture === undefined)
          texture = new THREE.Texture();
        texture.image = this.image;
        texture.mipmaps = this.mipmaps.slice(0);
        texture.mapping = this.mapping;
        texture.wrapS = this.wrapS;
        texture.wrapT = this.wrapT;
        texture.magFilter = this.magFilter;
        texture.minFilter = this.minFilter;
        texture.anisotropy = this.anisotropy;
        texture.format = this.format;
        texture.type = this.type;
        texture.offset.copy(this.offset);
        texture.repeat.copy(this.repeat);
        texture.generateMipmaps = this.generateMipmaps;
        texture.premultiplyAlpha = this.premultiplyAlpha;
        texture.flipY = this.flipY;
        texture.unpackAlignment = this.unpackAlignment;
        return texture;
      },
      update: function() {
        this.dispatchEvent({type: 'update'});
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
    THREE.TextureIdCount = 0;
    THREE.CubeTexture = function(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
      THREE.Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.images = images;
    };
    THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
    THREE.CubeTexture.clone = function(texture) {
      if (texture === undefined)
        texture = new THREE.CubeTexture();
      THREE.Texture.prototype.clone.call(this, texture);
      texture.images = this.images;
      return texture;
    };
    THREE.CompressedTexture = function(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
      THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.image = {
        width: width,
        height: height
      };
      this.mipmaps = mipmaps;
      this.flipY = false;
      this.generateMipmaps = false;
    };
    THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
    THREE.CompressedTexture.prototype.clone = function() {
      var texture = new THREE.CompressedTexture();
      THREE.Texture.prototype.clone.call(this, texture);
      return texture;
    };
    THREE.DataTexture = function(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
      THREE.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.image = {
        data: data,
        width: width,
        height: height
      };
    };
    THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.DataTexture.prototype.constructor = THREE.DataTexture;
    THREE.DataTexture.prototype.clone = function() {
      var texture = new THREE.DataTexture();
      THREE.Texture.prototype.clone.call(this, texture);
      return texture;
    };
    THREE.VideoTexture = function(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      THREE.Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.generateMipmaps = false;
      var scope = this;
      var update = function() {
        requestAnimationFrame(update);
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
          scope.needsUpdate = true;
        }
      };
      update();
    };
    THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);
    THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
    THREE.Group = function() {
      THREE.Object3D.call(this);
      this.type = 'Group';
    };
    THREE.Group.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Group.prototype.constructor = THREE.Group;
    THREE.PointCloud = function(geometry, material) {
      THREE.Object3D.call(this);
      this.type = 'PointCloud';
      this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
      this.material = material !== undefined ? material : new THREE.PointCloudMaterial({color: Math.random() * 0xffffff});
    };
    THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype);
    THREE.PointCloud.prototype.constructor = THREE.PointCloud;
    THREE.PointCloud.prototype.raycast = (function() {
      var inverseMatrix = new THREE.Matrix4();
      var ray = new THREE.Ray();
      return function(raycaster, intersects) {
        var object = this;
        var geometry = object.geometry;
        var threshold = raycaster.params.PointCloud.threshold;
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        if (geometry.boundingBox !== null) {
          if (ray.isIntersectionBox(geometry.boundingBox) === false) {
            return;
          }
        }
        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var position = new THREE.Vector3();
        var testPoint = function(point, index) {
          var rayPointDistance = ray.distanceToPoint(point);
          if (rayPointDistance < localThreshold) {
            var intersectPoint = ray.closestPointToPoint(point);
            intersectPoint.applyMatrix4(object.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectPoint);
            intersects.push({
              distance: distance,
              distanceToRay: rayPointDistance,
              point: intersectPoint.clone(),
              index: index,
              face: null,
              object: object
            });
          }
        };
        if (geometry instanceof THREE.BufferGeometry) {
          var attributes = geometry.attributes;
          var positions = attributes.position.array;
          if (attributes.index !== undefined) {
            var indices = attributes.index.array;
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              var offset = {
                start: 0,
                count: indices.length,
                index: 0
              };
              offsets = [offset];
            }
            for (var oi = 0,
                ol = offsets.length; oi < ol; ++oi) {
              var start = offsets[oi].start;
              var count = offsets[oi].count;
              var index = offsets[oi].index;
              for (var i = start,
                  il = start + count; i < il; i++) {
                var a = index + indices[i];
                position.fromArray(positions, a * 3);
                testPoint(position, a);
              }
            }
          } else {
            var pointCount = positions.length / 3;
            for (var i = 0; i < pointCount; i++) {
              position.set(positions[3 * i], positions[3 * i + 1], positions[3 * i + 2]);
              testPoint(position, i);
            }
          }
        } else {
          var vertices = this.geometry.vertices;
          for (var i = 0; i < vertices.length; i++) {
            testPoint(vertices[i], i);
          }
        }
      };
    }());
    THREE.PointCloud.prototype.clone = function(object) {
      if (object === undefined)
        object = new THREE.PointCloud(this.geometry, this.material);
      THREE.Object3D.prototype.clone.call(this, object);
      return object;
    };
    THREE.ParticleSystem = function(geometry, material) {
      THREE.warn('THREE.ParticleSystem has been renamed to THREE.PointCloud.');
      return new THREE.PointCloud(geometry, material);
    };
    THREE.Line = function(geometry, material, mode) {
      THREE.Object3D.call(this);
      this.type = 'Line';
      this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
      this.material = material !== undefined ? material : new THREE.LineBasicMaterial({color: Math.random() * 0xffffff});
      this.mode = mode !== undefined ? mode : THREE.LineStrip;
    };
    THREE.LineStrip = 0;
    THREE.LinePieces = 1;
    THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Line.prototype.constructor = THREE.Line;
    THREE.Line.prototype.raycast = (function() {
      var inverseMatrix = new THREE.Matrix4();
      var ray = new THREE.Ray();
      var sphere = new THREE.Sphere();
      return function(raycaster, intersects) {
        var precision = raycaster.linePrecision;
        var precisionSq = precision * precision;
        var geometry = this.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(this.matrixWorld);
        if (raycaster.ray.isIntersectionSphere(sphere) === false) {
          return;
        }
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        var vStart = new THREE.Vector3();
        var vEnd = new THREE.Vector3();
        var interSegment = new THREE.Vector3();
        var interRay = new THREE.Vector3();
        var step = this.mode === THREE.LineStrip ? 1 : 2;
        if (geometry instanceof THREE.BufferGeometry) {
          var attributes = geometry.attributes;
          if (attributes.index !== undefined) {
            var indices = attributes.index.array;
            var positions = attributes.position.array;
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              offsets = [{
                start: 0,
                count: indices.length,
                index: 0
              }];
            }
            for (var oi = 0; oi < offsets.length; oi++) {
              var start = offsets[oi].start;
              var count = offsets[oi].count;
              var index = offsets[oi].index;
              for (var i = start; i < start + count - 1; i += step) {
                var a = index + indices[i];
                var b = index + indices[i + 1];
                vStart.fromArray(positions, a * 3);
                vEnd.fromArray(positions, b * 3);
                var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > precisionSq)
                  continue;
                var distance = ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects.push({
                  distance: distance,
                  point: interSegment.clone().applyMatrix4(this.matrixWorld),
                  index: i,
                  offsetIndex: oi,
                  face: null,
                  faceIndex: null,
                  object: this
                });
              }
            }
          } else {
            var positions = attributes.position.array;
            for (var i = 0; i < positions.length / 3 - 1; i += step) {
              vStart.fromArray(positions, 3 * i);
              vEnd.fromArray(positions, 3 * i + 3);
              var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > precisionSq)
                continue;
              var distance = ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects.push({
                distance: distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        } else if (geometry instanceof THREE.Geometry) {
          var vertices = geometry.vertices;
          var nbVertices = vertices.length;
          for (var i = 0; i < nbVertices - 1; i += step) {
            var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
            if (distSq > precisionSq)
              continue;
            var distance = ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects.push({
              distance: distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      };
    }());
    THREE.Line.prototype.clone = function(object) {
      if (object === undefined)
        object = new THREE.Line(this.geometry, this.material, this.mode);
      THREE.Object3D.prototype.clone.call(this, object);
      return object;
    };
    THREE.Mesh = function(geometry, material) {
      THREE.Object3D.call(this);
      this.type = 'Mesh';
      this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
      this.material = material !== undefined ? material : new THREE.MeshBasicMaterial({color: Math.random() * 0xffffff});
      this.updateMorphTargets();
    };
    THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Mesh.prototype.constructor = THREE.Mesh;
    THREE.Mesh.prototype.updateMorphTargets = function() {
      if (this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0) {
        this.morphTargetBase = -1;
        this.morphTargetForcedOrder = [];
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (var m = 0,
            ml = this.geometry.morphTargets.length; m < ml; m++) {
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[this.geometry.morphTargets[m].name] = m;
        }
      }
    };
    THREE.Mesh.prototype.getMorphTargetIndexByName = function(name) {
      if (this.morphTargetDictionary[name] !== undefined) {
        return this.morphTargetDictionary[name];
      }
      THREE.warn('THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.');
      return 0;
    };
    THREE.Mesh.prototype.raycast = (function() {
      var inverseMatrix = new THREE.Matrix4();
      var ray = new THREE.Ray();
      var sphere = new THREE.Sphere();
      var vA = new THREE.Vector3();
      var vB = new THREE.Vector3();
      var vC = new THREE.Vector3();
      return function(raycaster, intersects) {
        var geometry = this.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        sphere.copy(geometry.boundingSphere);
        sphere.applyMatrix4(this.matrixWorld);
        if (raycaster.ray.isIntersectionSphere(sphere) === false) {
          return;
        }
        inverseMatrix.getInverse(this.matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        if (geometry.boundingBox !== null) {
          if (ray.isIntersectionBox(geometry.boundingBox) === false) {
            return;
          }
        }
        if (geometry instanceof THREE.BufferGeometry) {
          var material = this.material;
          if (material === undefined)
            return;
          var attributes = geometry.attributes;
          var a,
              b,
              c;
          var precision = raycaster.precision;
          if (attributes.index !== undefined) {
            var indices = attributes.index.array;
            var positions = attributes.position.array;
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              offsets = [{
                start: 0,
                count: indices.length,
                index: 0
              }];
            }
            for (var oi = 0,
                ol = offsets.length; oi < ol; ++oi) {
              var start = offsets[oi].start;
              var count = offsets[oi].count;
              var index = offsets[oi].index;
              for (var i = start,
                  il = start + count; i < il; i += 3) {
                a = index + indices[i];
                b = index + indices[i + 1];
                c = index + indices[i + 2];
                vA.fromArray(positions, a * 3);
                vB.fromArray(positions, b * 3);
                vC.fromArray(positions, c * 3);
                if (material.side === THREE.BackSide) {
                  var intersectionPoint = ray.intersectTriangle(vC, vB, vA, true);
                } else {
                  var intersectionPoint = ray.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide);
                }
                if (intersectionPoint === null)
                  continue;
                intersectionPoint.applyMatrix4(this.matrixWorld);
                var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
                if (distance < precision || distance < raycaster.near || distance > raycaster.far)
                  continue;
                intersects.push({
                  distance: distance,
                  point: intersectionPoint,
                  face: new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC)),
                  faceIndex: null,
                  object: this
                });
              }
            }
          } else {
            var positions = attributes.position.array;
            for (var i = 0,
                j = 0,
                il = positions.length; i < il; i += 3, j += 9) {
              a = i;
              b = i + 1;
              c = i + 2;
              vA.fromArray(positions, j);
              vB.fromArray(positions, j + 3);
              vC.fromArray(positions, j + 6);
              if (material.side === THREE.BackSide) {
                var intersectionPoint = ray.intersectTriangle(vC, vB, vA, true);
              } else {
                var intersectionPoint = ray.intersectTriangle(vA, vB, vC, material.side !== THREE.DoubleSide);
              }
              if (intersectionPoint === null)
                continue;
              intersectionPoint.applyMatrix4(this.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
              if (distance < precision || distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects.push({
                distance: distance,
                point: intersectionPoint,
                face: new THREE.Face3(a, b, c, THREE.Triangle.normal(vA, vB, vC)),
                faceIndex: null,
                object: this
              });
            }
          }
        } else if (geometry instanceof THREE.Geometry) {
          var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
          var objectMaterials = isFaceMaterial === true ? this.material.materials : null;
          var a,
              b,
              c;
          var precision = raycaster.precision;
          var vertices = geometry.vertices;
          for (var f = 0,
              fl = geometry.faces.length; f < fl; f++) {
            var face = geometry.faces[f];
            var material = isFaceMaterial === true ? objectMaterials[face.materialIndex] : this.material;
            if (material === undefined)
              continue;
            a = vertices[face.a];
            b = vertices[face.b];
            c = vertices[face.c];
            if (material.morphTargets === true) {
              var morphTargets = geometry.morphTargets;
              var morphInfluences = this.morphTargetInfluences;
              vA.set(0, 0, 0);
              vB.set(0, 0, 0);
              vC.set(0, 0, 0);
              for (var t = 0,
                  tl = morphTargets.length; t < tl; t++) {
                var influence = morphInfluences[t];
                if (influence === 0)
                  continue;
                var targets = morphTargets[t].vertices;
                vA.x += (targets[face.a].x - a.x) * influence;
                vA.y += (targets[face.a].y - a.y) * influence;
                vA.z += (targets[face.a].z - a.z) * influence;
                vB.x += (targets[face.b].x - b.x) * influence;
                vB.y += (targets[face.b].y - b.y) * influence;
                vB.z += (targets[face.b].z - b.z) * influence;
                vC.x += (targets[face.c].x - c.x) * influence;
                vC.y += (targets[face.c].y - c.y) * influence;
                vC.z += (targets[face.c].z - c.z) * influence;
              }
              vA.add(a);
              vB.add(b);
              vC.add(c);
              a = vA;
              b = vB;
              c = vC;
            }
            if (material.side === THREE.BackSide) {
              var intersectionPoint = ray.intersectTriangle(c, b, a, true);
            } else {
              var intersectionPoint = ray.intersectTriangle(a, b, c, material.side !== THREE.DoubleSide);
            }
            if (intersectionPoint === null)
              continue;
            intersectionPoint.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectionPoint);
            if (distance < precision || distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects.push({
              distance: distance,
              point: intersectionPoint,
              face: face,
              faceIndex: f,
              object: this
            });
          }
        }
      };
    }());
    THREE.Mesh.prototype.clone = function(object, recursive) {
      if (object === undefined)
        object = new THREE.Mesh(this.geometry, this.material);
      THREE.Object3D.prototype.clone.call(this, object, recursive);
      return object;
    };
    THREE.Bone = function(skin) {
      THREE.Object3D.call(this);
      this.type = 'Bone';
      this.skin = skin;
    };
    THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Bone.prototype.constructor = THREE.Bone;
    THREE.Skeleton = function(bones, boneInverses, useVertexTexture) {
      this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
      this.identityMatrix = new THREE.Matrix4();
      bones = bones || [];
      this.bones = bones.slice(0);
      if (this.useVertexTexture) {
        var size;
        if (this.bones.length > 256)
          size = 64;
        else if (this.bones.length > 64)
          size = 32;
        else if (this.bones.length > 16)
          size = 16;
        else
          size = 8;
        this.boneTextureWidth = size;
        this.boneTextureHeight = size;
        this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4);
        this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType);
        this.boneTexture.minFilter = THREE.NearestFilter;
        this.boneTexture.magFilter = THREE.NearestFilter;
        this.boneTexture.generateMipmaps = false;
        this.boneTexture.flipY = false;
      } else {
        this.boneMatrices = new Float32Array(16 * this.bones.length);
      }
      if (boneInverses === undefined) {
        this.calculateInverses();
      } else {
        if (this.bones.length === boneInverses.length) {
          this.boneInverses = boneInverses.slice(0);
        } else {
          THREE.warn('THREE.Skeleton bonInverses is the wrong length.');
          this.boneInverses = [];
          for (var b = 0,
              bl = this.bones.length; b < bl; b++) {
            this.boneInverses.push(new THREE.Matrix4());
          }
        }
      }
    };
    THREE.Skeleton.prototype.calculateInverses = function() {
      this.boneInverses = [];
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        var inverse = new THREE.Matrix4();
        if (this.bones[b]) {
          inverse.getInverse(this.bones[b].matrixWorld);
        }
        this.boneInverses.push(inverse);
      }
    };
    THREE.Skeleton.prototype.pose = function() {
      var bone;
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        bone = this.bones[b];
        if (bone) {
          bone.matrixWorld.getInverse(this.boneInverses[b]);
        }
      }
      for (var b = 0,
          bl = this.bones.length; b < bl; b++) {
        bone = this.bones[b];
        if (bone) {
          if (bone.parent) {
            bone.matrix.getInverse(bone.parent.matrixWorld);
            bone.matrix.multiply(bone.matrixWorld);
          } else {
            bone.matrix.copy(bone.matrixWorld);
          }
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        }
      }
    };
    THREE.Skeleton.prototype.update = (function() {
      var offsetMatrix = new THREE.Matrix4();
      return function() {
        for (var b = 0,
            bl = this.bones.length; b < bl; b++) {
          var matrix = this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix;
          offsetMatrix.multiplyMatrices(matrix, this.boneInverses[b]);
          offsetMatrix.flattenToArrayOffset(this.boneMatrices, b * 16);
        }
        if (this.useVertexTexture) {
          this.boneTexture.needsUpdate = true;
        }
      };
    })();
    THREE.SkinnedMesh = function(geometry, material, useVertexTexture) {
      THREE.Mesh.call(this, geometry, material);
      this.type = 'SkinnedMesh';
      this.bindMode = "attached";
      this.bindMatrix = new THREE.Matrix4();
      this.bindMatrixInverse = new THREE.Matrix4();
      var bones = [];
      if (this.geometry && this.geometry.bones !== undefined) {
        var bone,
            gbone,
            p,
            q,
            s;
        for (var b = 0,
            bl = this.geometry.bones.length; b < bl; ++b) {
          gbone = this.geometry.bones[b];
          p = gbone.pos;
          q = gbone.rotq;
          s = gbone.scl;
          bone = new THREE.Bone(this);
          bones.push(bone);
          bone.name = gbone.name;
          bone.position.set(p[0], p[1], p[2]);
          bone.quaternion.set(q[0], q[1], q[2], q[3]);
          if (s !== undefined) {
            bone.scale.set(s[0], s[1], s[2]);
          } else {
            bone.scale.set(1, 1, 1);
          }
        }
        for (var b = 0,
            bl = this.geometry.bones.length; b < bl; ++b) {
          gbone = this.geometry.bones[b];
          if (gbone.parent !== -1) {
            bones[gbone.parent].add(bones[b]);
          } else {
            this.add(bones[b]);
          }
        }
      }
      this.normalizeSkinWeights();
      this.updateMatrixWorld(true);
      this.bind(new THREE.Skeleton(bones, undefined, useVertexTexture));
    };
    THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
    THREE.SkinnedMesh.prototype.bind = function(skeleton, bindMatrix) {
      this.skeleton = skeleton;
      if (bindMatrix === undefined) {
        this.updateMatrixWorld(true);
        bindMatrix = this.matrixWorld;
      }
      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.getInverse(bindMatrix);
    };
    THREE.SkinnedMesh.prototype.pose = function() {
      this.skeleton.pose();
    };
    THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
      if (this.geometry instanceof THREE.Geometry) {
        for (var i = 0; i < this.geometry.skinIndices.length; i++) {
          var sw = this.geometry.skinWeights[i];
          var scale = 1.0 / sw.lengthManhattan();
          if (scale !== Infinity) {
            sw.multiplyScalar(scale);
          } else {
            sw.set(1);
          }
        }
      } else {}
    };
    THREE.SkinnedMesh.prototype.updateMatrixWorld = function(force) {
      THREE.Mesh.prototype.updateMatrixWorld.call(this, true);
      if (this.bindMode === "attached") {
        this.bindMatrixInverse.getInverse(this.matrixWorld);
      } else if (this.bindMode === "detached") {
        this.bindMatrixInverse.getInverse(this.bindMatrix);
      } else {
        THREE.warn('THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode);
      }
    };
    THREE.SkinnedMesh.prototype.clone = function(object) {
      if (object === undefined) {
        object = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture);
      }
      THREE.Mesh.prototype.clone.call(this, object);
      return object;
    };
    THREE.MorphAnimMesh = function(geometry, material) {
      THREE.Mesh.call(this, geometry, material);
      this.type = 'MorphAnimMesh';
      this.duration = 1000;
      this.mirroredLoop = false;
      this.time = 0;
      this.lastKeyframe = 0;
      this.currentKeyframe = 0;
      this.direction = 1;
      this.directionBackwards = false;
      this.setFrameRange(0, this.geometry.morphTargets.length - 1);
    };
    THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;
    THREE.MorphAnimMesh.prototype.setFrameRange = function(start, end) {
      this.startKeyframe = start;
      this.endKeyframe = end;
      this.length = this.endKeyframe - this.startKeyframe + 1;
    };
    THREE.MorphAnimMesh.prototype.setDirectionForward = function() {
      this.direction = 1;
      this.directionBackwards = false;
    };
    THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {
      this.direction = -1;
      this.directionBackwards = true;
    };
    THREE.MorphAnimMesh.prototype.parseAnimations = function() {
      var geometry = this.geometry;
      if (!geometry.animations)
        geometry.animations = {};
      var firstAnimation,
          animations = geometry.animations;
      var pattern = /([a-z]+)_?(\d+)/;
      for (var i = 0,
          il = geometry.morphTargets.length; i < il; i++) {
        var morph = geometry.morphTargets[i];
        var parts = morph.name.match(pattern);
        if (parts && parts.length > 1) {
          var label = parts[1];
          if (!animations[label])
            animations[label] = {
              start: Infinity,
              end: -Infinity
            };
          var animation = animations[label];
          if (i < animation.start)
            animation.start = i;
          if (i > animation.end)
            animation.end = i;
          if (!firstAnimation)
            firstAnimation = label;
        }
      }
      geometry.firstAnimation = firstAnimation;
    };
    THREE.MorphAnimMesh.prototype.setAnimationLabel = function(label, start, end) {
      if (!this.geometry.animations)
        this.geometry.animations = {};
      this.geometry.animations[label] = {
        start: start,
        end: end
      };
    };
    THREE.MorphAnimMesh.prototype.playAnimation = function(label, fps) {
      var animation = this.geometry.animations[label];
      if (animation) {
        this.setFrameRange(animation.start, animation.end);
        this.duration = 1000 * ((animation.end - animation.start) / fps);
        this.time = 0;
      } else {
        THREE.warn('THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()');
      }
    };
    THREE.MorphAnimMesh.prototype.updateAnimation = function(delta) {
      var frameTime = this.duration / this.length;
      this.time += this.direction * delta;
      if (this.mirroredLoop) {
        if (this.time > this.duration || this.time < 0) {
          this.direction *= -1;
          if (this.time > this.duration) {
            this.time = this.duration;
            this.directionBackwards = true;
          }
          if (this.time < 0) {
            this.time = 0;
            this.directionBackwards = false;
          }
        }
      } else {
        this.time = this.time % this.duration;
        if (this.time < 0)
          this.time += this.duration;
      }
      var keyframe = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / frameTime), 0, this.length - 1);
      if (keyframe !== this.currentKeyframe) {
        this.morphTargetInfluences[this.lastKeyframe] = 0;
        this.morphTargetInfluences[this.currentKeyframe] = 1;
        this.morphTargetInfluences[keyframe] = 0;
        this.lastKeyframe = this.currentKeyframe;
        this.currentKeyframe = keyframe;
      }
      var mix = (this.time % frameTime) / frameTime;
      if (this.directionBackwards) {
        mix = 1 - mix;
      }
      this.morphTargetInfluences[this.currentKeyframe] = mix;
      this.morphTargetInfluences[this.lastKeyframe] = 1 - mix;
    };
    THREE.MorphAnimMesh.prototype.interpolateTargets = function(a, b, t) {
      var influences = this.morphTargetInfluences;
      for (var i = 0,
          l = influences.length; i < l; i++) {
        influences[i] = 0;
      }
      if (a > -1)
        influences[a] = 1 - t;
      if (b > -1)
        influences[b] = t;
    };
    THREE.MorphAnimMesh.prototype.clone = function(object) {
      if (object === undefined)
        object = new THREE.MorphAnimMesh(this.geometry, this.material);
      object.duration = this.duration;
      object.mirroredLoop = this.mirroredLoop;
      object.time = this.time;
      object.lastKeyframe = this.lastKeyframe;
      object.currentKeyframe = this.currentKeyframe;
      object.direction = this.direction;
      object.directionBackwards = this.directionBackwards;
      THREE.Mesh.prototype.clone.call(this, object);
      return object;
    };
    THREE.LOD = function() {
      THREE.Object3D.call(this);
      this.objects = [];
    };
    THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
    THREE.LOD.prototype.constructor = THREE.LOD;
    THREE.LOD.prototype.addLevel = function(object, distance) {
      if (distance === undefined)
        distance = 0;
      distance = Math.abs(distance);
      for (var l = 0; l < this.objects.length; l++) {
        if (distance < this.objects[l].distance) {
          break;
        }
      }
      this.objects.splice(l, 0, {
        distance: distance,
        object: object
      });
      this.add(object);
    };
    THREE.LOD.prototype.getObjectForDistance = function(distance) {
      for (var i = 1,
          l = this.objects.length; i < l; i++) {
        if (distance < this.objects[i].distance) {
          break;
        }
      }
      return this.objects[i - 1].object;
    };
    THREE.LOD.prototype.raycast = (function() {
      var matrixPosition = new THREE.Vector3();
      return function(raycaster, intersects) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(matrixPosition);
        this.getObjectForDistance(distance).raycast(raycaster, intersects);
      };
    }());
    THREE.LOD.prototype.update = function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      return function(camera) {
        if (this.objects.length > 1) {
          v1.setFromMatrixPosition(camera.matrixWorld);
          v2.setFromMatrixPosition(this.matrixWorld);
          var distance = v1.distanceTo(v2);
          this.objects[0].object.visible = true;
          for (var i = 1,
              l = this.objects.length; i < l; i++) {
            if (distance >= this.objects[i].distance) {
              this.objects[i - 1].object.visible = false;
              this.objects[i].object.visible = true;
            } else {
              break;
            }
          }
          for (; i < l; i++) {
            this.objects[i].object.visible = false;
          }
        }
      };
    }();
    THREE.LOD.prototype.clone = function(object) {
      if (object === undefined)
        object = new THREE.LOD();
      THREE.Object3D.prototype.clone.call(this, object);
      for (var i = 0,
          l = this.objects.length; i < l; i++) {
        var x = this.objects[i].object.clone();
        x.visible = i === 0;
        object.addLevel(x, this.objects[i].distance);
      }
      return object;
    };
    THREE.Sprite = (function() {
      var indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
      var vertices = new Float32Array([-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0]);
      var uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      var geometry = new THREE.BufferGeometry();
      geometry.addAttribute('index', new THREE.BufferAttribute(indices, 1));
      geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
      return function(material) {
        THREE.Object3D.call(this);
        this.type = 'Sprite';
        this.geometry = geometry;
        this.material = (material !== undefined) ? material : new THREE.SpriteMaterial();
      };
    })();
    THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Sprite.prototype.constructor = THREE.Sprite;
    THREE.Sprite.prototype.raycast = (function() {
      var matrixPosition = new THREE.Vector3();
      return function(raycaster, intersects) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distance = raycaster.ray.distanceToPoint(matrixPosition);
        if (distance > this.scale.x) {
          return;
        }
        intersects.push({
          distance: distance,
          point: this.position,
          face: null,
          object: this
        });
      };
    }());
    THREE.Sprite.prototype.clone = function(object) {
      if (object === undefined)
        object = new THREE.Sprite(this.material);
      THREE.Object3D.prototype.clone.call(this, object);
      return object;
    };
    THREE.Particle = THREE.Sprite;
    THREE.LensFlare = function(texture, size, distance, blending, color) {
      THREE.Object3D.call(this);
      this.lensFlares = [];
      this.positionScreen = new THREE.Vector3();
      this.customUpdateCallback = undefined;
      if (texture !== undefined) {
        this.add(texture, size, distance, blending, color);
      }
    };
    THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
    THREE.LensFlare.prototype.constructor = THREE.LensFlare;
    THREE.LensFlare.prototype.add = function(texture, size, distance, blending, color, opacity) {
      if (size === undefined)
        size = -1;
      if (distance === undefined)
        distance = 0;
      if (opacity === undefined)
        opacity = 1;
      if (color === undefined)
        color = new THREE.Color(0xffffff);
      if (blending === undefined)
        blending = THREE.NormalBlending;
      distance = Math.min(distance, Math.max(0, distance));
      this.lensFlares.push({
        texture: texture,
        size: size,
        distance: distance,
        x: 0,
        y: 0,
        z: 0,
        scale: 1,
        rotation: 1,
        opacity: opacity,
        color: color,
        blending: blending
      });
    };
    THREE.LensFlare.prototype.updateLensFlares = function() {
      var f,
          fl = this.lensFlares.length;
      var flare;
      var vecX = -this.positionScreen.x * 2;
      var vecY = -this.positionScreen.y * 2;
      for (f = 0; f < fl; f++) {
        flare = this.lensFlares[f];
        flare.x = this.positionScreen.x + vecX * flare.distance;
        flare.y = this.positionScreen.y + vecY * flare.distance;
        flare.wantedRotation = flare.x * Math.PI * 0.25;
        flare.rotation += (flare.wantedRotation - flare.rotation) * 0.25;
      }
    };
    THREE.Scene = function() {
      THREE.Object3D.call(this);
      this.type = 'Scene';
      this.fog = null;
      this.overrideMaterial = null;
      this.autoUpdate = true;
    };
    THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Scene.prototype.constructor = THREE.Scene;
    THREE.Scene.prototype.clone = function(object) {
      if (object === undefined)
        object = new THREE.Scene();
      THREE.Object3D.prototype.clone.call(this, object);
      if (this.fog !== null)
        object.fog = this.fog.clone();
      if (this.overrideMaterial !== null)
        object.overrideMaterial = this.overrideMaterial.clone();
      object.autoUpdate = this.autoUpdate;
      object.matrixAutoUpdate = this.matrixAutoUpdate;
      return object;
    };
    THREE.Fog = function(color, near, far) {
      this.name = '';
      this.color = new THREE.Color(color);
      this.near = (near !== undefined) ? near : 1;
      this.far = (far !== undefined) ? far : 1000;
    };
    THREE.Fog.prototype.clone = function() {
      return new THREE.Fog(this.color.getHex(), this.near, this.far);
    };
    THREE.FogExp2 = function(color, density) {
      this.name = '';
      this.color = new THREE.Color(color);
      this.density = (density !== undefined) ? density : 0.00025;
    };
    THREE.FogExp2.prototype.clone = function() {
      return new THREE.FogExp2(this.color.getHex(), this.density);
    };
    THREE.ShaderChunk = {};
    THREE.ShaderChunk['common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\nfloat square( in float a ) { return a*a; }\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\nfloat average( in float a ) { return a; }\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n}\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n	return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\n	float distance = dot( planeNormal, point-pointOnPlane );\n	return point - distance * planeNormal;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\n}\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n	if ( decayExponent > 0.0 ) {\n	  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\n	}\n	return 1.0;\n}\n\nvec3 inputToLinear( in vec3 a ) {\n#ifdef GAMMA_INPUT\n	return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\nvec3 linearToOutput( in vec3 a ) {\n#ifdef GAMMA_OUTPUT\n	return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n#else\n	return a;\n#endif\n}\n";
    THREE.ShaderChunk['alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
    THREE.ShaderChunk['lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack += ambientLightColor;\n\n#endif\n";
    THREE.ShaderChunk['map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n\n#endif\n";
    THREE.ShaderChunk['default_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n	vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";
    THREE.ShaderChunk['map_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";
    THREE.ShaderChunk['skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";
    THREE.ShaderChunk['lightmap_pars_vertex'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif";
    THREE.ShaderChunk['lights_phong_fragment'] = "#ifndef FLAT_SHADED\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n	#endif\n\n#else\n\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			totalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\n\n			// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			totalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		totalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		totalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		totalDiffuseLight += hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		totalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\n#ifdef METAL\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\n\n#else\n\n	outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\n\n#endif\n";
    THREE.ShaderChunk['fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";
    THREE.ShaderChunk['morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif";
    THREE.ShaderChunk['envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";
    THREE.ShaderChunk['normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";
    THREE.ShaderChunk['lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif";
    THREE.ShaderChunk['shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n	}\n\n#endif";
    THREE.ShaderChunk['lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif";
    THREE.ShaderChunk['map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor.xyz = inputToLinear( texelColor.xyz );\n\n	diffuseColor *= texelColor;\n\n#endif";
    THREE.ShaderChunk['lightmap_vertex'] = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif";
    THREE.ShaderChunk['map_particle_fragment'] = "#ifdef USE_MAP\n\n	diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";
    THREE.ShaderChunk['color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";
    THREE.ShaderChunk['color_vertex'] = "#ifdef USE_COLOR\n\n	vColor.xyz = inputToLinear( color.xyz );\n\n#endif";
    THREE.ShaderChunk['skinning_vertex'] = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";
    THREE.ShaderChunk['envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";
    THREE.ShaderChunk['linear_to_gamma_fragment'] = "\n	outgoingLight = linearToOutput( outgoingLight );\n";
    THREE.ShaderChunk['color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";
    THREE.ShaderChunk['lights_lambert_pars_vertex'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n";
    THREE.ShaderChunk['map_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";
    THREE.ShaderChunk['envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	envColor.xyz = inputToLinear( envColor.xyz );\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";
    THREE.ShaderChunk['logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";
    THREE.ShaderChunk['morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";
    THREE.ShaderChunk['specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";
    THREE.ShaderChunk['fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\n		fogFactor = whiteCompliment( fogFactor );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";
    THREE.ShaderChunk['bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n	// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n";
    THREE.ShaderChunk['defaultnormal_vertex'] = "#ifdef USE_SKINNING\n\n	vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n	vec3 objectNormal = morphedNormal;\n\n#else\n\n	vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
    THREE.ShaderChunk['lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n";
    THREE.ShaderChunk['skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
    THREE.ShaderChunk['map_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";
    THREE.ShaderChunk['lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n	outgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\n\n#endif";
    THREE.ShaderChunk['shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";
    THREE.ShaderChunk['color_fragment'] = "#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif";
    THREE.ShaderChunk['morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif";
    THREE.ShaderChunk['envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n	shadowColor = inputToLinear( shadowColor );\n\n	outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";
    THREE.ShaderChunk['worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#elif defined( USE_MORPHTARGETS )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";
    THREE.ShaderChunk['skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";
    THREE.ShaderChunk['logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif";
    THREE.ShaderChunk['alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
    THREE.ShaderChunk['alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";
    THREE.UniformsUtils = {
      merge: function(uniforms) {
        var merged = {};
        for (var u = 0; u < uniforms.length; u++) {
          var tmp = this.clone(uniforms[u]);
          for (var p in tmp) {
            merged[p] = tmp[p];
          }
        }
        return merged;
      },
      clone: function(uniforms_src) {
        var uniforms_dst = {};
        for (var u in uniforms_src) {
          uniforms_dst[u] = {};
          for (var p in uniforms_src[u]) {
            var parameter_src = uniforms_src[u][p];
            if (parameter_src instanceof THREE.Color || parameter_src instanceof THREE.Vector2 || parameter_src instanceof THREE.Vector3 || parameter_src instanceof THREE.Vector4 || parameter_src instanceof THREE.Matrix4 || parameter_src instanceof THREE.Texture) {
              uniforms_dst[u][p] = parameter_src.clone();
            } else if (parameter_src instanceof Array) {
              uniforms_dst[u][p] = parameter_src.slice();
            } else {
              uniforms_dst[u][p] = parameter_src;
            }
          }
        }
        return uniforms_dst;
      }
    };
    THREE.UniformsLib = {
      common: {
        "diffuse": {
          type: "c",
          value: new THREE.Color(0xeeeeee)
        },
        "opacity": {
          type: "f",
          value: 1.0
        },
        "map": {
          type: "t",
          value: null
        },
        "offsetRepeat": {
          type: "v4",
          value: new THREE.Vector4(0, 0, 1, 1)
        },
        "lightMap": {
          type: "t",
          value: null
        },
        "specularMap": {
          type: "t",
          value: null
        },
        "alphaMap": {
          type: "t",
          value: null
        },
        "envMap": {
          type: "t",
          value: null
        },
        "flipEnvMap": {
          type: "f",
          value: -1
        },
        "reflectivity": {
          type: "f",
          value: 1.0
        },
        "refractionRatio": {
          type: "f",
          value: 0.98
        },
        "morphTargetInfluences": {
          type: "f",
          value: 0
        }
      },
      bump: {
        "bumpMap": {
          type: "t",
          value: null
        },
        "bumpScale": {
          type: "f",
          value: 1
        }
      },
      normalmap: {
        "normalMap": {
          type: "t",
          value: null
        },
        "normalScale": {
          type: "v2",
          value: new THREE.Vector2(1, 1)
        }
      },
      fog: {
        "fogDensity": {
          type: "f",
          value: 0.00025
        },
        "fogNear": {
          type: "f",
          value: 1
        },
        "fogFar": {
          type: "f",
          value: 2000
        },
        "fogColor": {
          type: "c",
          value: new THREE.Color(0xffffff)
        }
      },
      lights: {
        "ambientLightColor": {
          type: "fv",
          value: []
        },
        "directionalLightDirection": {
          type: "fv",
          value: []
        },
        "directionalLightColor": {
          type: "fv",
          value: []
        },
        "hemisphereLightDirection": {
          type: "fv",
          value: []
        },
        "hemisphereLightSkyColor": {
          type: "fv",
          value: []
        },
        "hemisphereLightGroundColor": {
          type: "fv",
          value: []
        },
        "pointLightColor": {
          type: "fv",
          value: []
        },
        "pointLightPosition": {
          type: "fv",
          value: []
        },
        "pointLightDistance": {
          type: "fv1",
          value: []
        },
        "pointLightDecay": {
          type: "fv1",
          value: []
        },
        "spotLightColor": {
          type: "fv",
          value: []
        },
        "spotLightPosition": {
          type: "fv",
          value: []
        },
        "spotLightDirection": {
          type: "fv",
          value: []
        },
        "spotLightDistance": {
          type: "fv1",
          value: []
        },
        "spotLightAngleCos": {
          type: "fv1",
          value: []
        },
        "spotLightExponent": {
          type: "fv1",
          value: []
        },
        "spotLightDecay": {
          type: "fv1",
          value: []
        }
      },
      particle: {
        "psColor": {
          type: "c",
          value: new THREE.Color(0xeeeeee)
        },
        "opacity": {
          type: "f",
          value: 1.0
        },
        "size": {
          type: "f",
          value: 1.0
        },
        "scale": {
          type: "f",
          value: 1.0
        },
        "map": {
          type: "t",
          value: null
        },
        "offsetRepeat": {
          type: "v4",
          value: new THREE.Vector4(0, 0, 1, 1)
        },
        "fogDensity": {
          type: "f",
          value: 0.00025
        },
        "fogNear": {
          type: "f",
          value: 1
        },
        "fogFar": {
          type: "f",
          value: 2000
        },
        "fogColor": {
          type: "c",
          value: new THREE.Color(0xffffff)
        }
      },
      shadowmap: {
        "shadowMap": {
          type: "tv",
          value: []
        },
        "shadowMapSize": {
          type: "v2v",
          value: []
        },
        "shadowBias": {
          type: "fv1",
          value: []
        },
        "shadowDarkness": {
          type: "fv1",
          value: []
        },
        "shadowMatrix": {
          type: "m4v",
          value: []
        }
      }
    };
    THREE.ShaderLib = {
      'basic': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], THREE.UniformsLib["shadowmap"]]),
        vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["skinbase_vertex"], "	#ifdef USE_ENVMAP", THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "	#endif", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'lambert': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], {
          "emissive": {
            type: "c",
            value: new THREE.Color(0x000000)
          },
          "wrapRGB": {
            type: "v3",
            value: new THREE.Vector3(1, 1, 1)
          }
        }]),
        vertexShader: ["#define LAMBERT", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_lambert_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_lambert_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform float opacity;", "varying vec3 vLightFront;", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], "	#ifdef DOUBLE_SIDED", "		if ( gl_FrontFacing )", "			outgoingLight += diffuseColor.rgb * vLightFront + emissive;", "		else", "			outgoingLight += diffuseColor.rgb * vLightBack + emissive;", "	#else", "		outgoingLight += diffuseColor.rgb * vLightFront + emissive;", "	#endif", THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'phong': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["bump"], THREE.UniformsLib["normalmap"], THREE.UniformsLib["fog"], THREE.UniformsLib["lights"], THREE.UniformsLib["shadowmap"], {
          "emissive": {
            type: "c",
            value: new THREE.Color(0x000000)
          },
          "specular": {
            type: "c",
            value: new THREE.Color(0x111111)
          },
          "shininess": {
            type: "f",
            value: 30
          },
          "wrapRGB": {
            type: "v3",
            value: new THREE.Vector3(1, 1, 1)
          }
        }]),
        vertexShader: ["#define PHONG", "varying vec3 vViewPosition;", "#ifndef FLAT_SHADED", "	varying vec3 vNormal;", "#endif", THREE.ShaderChunk["common"], THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], THREE.ShaderChunk["envmap_pars_vertex"], THREE.ShaderChunk["lights_phong_pars_vertex"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "#ifndef FLAT_SHADED", "	vNormal = normalize( transformedNormal );", "#endif", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "	vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["envmap_vertex"], THREE.ShaderChunk["lights_phong_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["#define PHONG", "uniform vec3 diffuse;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["alphamap_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], THREE.ShaderChunk["envmap_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["lights_phong_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["bumpmap_pars_fragment"], THREE.ShaderChunk["normalmap_pars_fragment"], THREE.ShaderChunk["specularmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphamap_fragment"], THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], THREE.ShaderChunk["lights_phong_fragment"], THREE.ShaderChunk["lightmap_fragment"], THREE.ShaderChunk["envmap_fragment"], THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["linear_to_gamma_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'particle_basic': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["particle"], THREE.UniformsLib["shadowmap"]]),
        vertexShader: ["uniform float size;", "uniform float scale;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["shadowmap_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	#ifdef USE_SIZEATTENUATION", "		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );", "	#else", "		gl_PointSize = size;", "	#endif", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk["logdepthbuf_vertex"], THREE.ShaderChunk["worldpos_vertex"], THREE.ShaderChunk["shadowmap_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 psColor;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_particle_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["shadowmap_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( psColor, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["map_particle_fragment"], THREE.ShaderChunk["color_fragment"], THREE.ShaderChunk["alphatest_fragment"], "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk["shadowmap_fragment"], THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'dashed': {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib["common"], THREE.UniformsLib["fog"], {
          "scale": {
            type: "f",
            value: 1
          },
          "dashSize": {
            type: "f",
            value: 1
          },
          "totalSize": {
            type: "f",
            value: 2
          }
        }]),
        vertexShader: ["uniform float scale;", "attribute float lineDistance;", "varying float vLineDistance;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["color_vertex"], "	vLineDistance = scale * lineDistance;", "	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "	gl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;", "uniform float opacity;", "uniform float dashSize;", "uniform float totalSize;", "varying float vLineDistance;", THREE.ShaderChunk["common"], THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["fog_pars_fragment"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	if ( mod( vLineDistance, totalSize ) > dashSize ) {", "		discard;", "	}", "	vec3 outgoingLight = vec3( 0.0 );", "	vec4 diffuseColor = vec4( diffuse, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], THREE.ShaderChunk["color_fragment"], "	outgoingLight = diffuseColor.rgb;", THREE.ShaderChunk["fog_fragment"], "	gl_FragColor = vec4( outgoingLight, diffuseColor.a );", "}"].join("\n")
      },
      'depth': {
        uniforms: {
          "mNear": {
            type: "f",
            value: 1.0
          },
          "mFar": {
            type: "f",
            value: 2000.0
          },
          "opacity": {
            type: "f",
            value: 1.0
          }
        },
        vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform float mNear;", "uniform float mFar;", "uniform float opacity;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", THREE.ShaderChunk["logdepthbuf_fragment"], "	#ifdef USE_LOGDEPTHBUF_EXT", "		float depth = gl_FragDepthEXT / gl_FragCoord.w;", "	#else", "		float depth = gl_FragCoord.z / gl_FragCoord.w;", "	#endif", "	float color = 1.0 - smoothstep( mNear, mFar, depth );", "	gl_FragColor = vec4( vec3( color ), opacity );", "}"].join("\n")
      },
      'normal': {
        uniforms: {"opacity": {
            type: "f",
            value: 1.0
          }},
        vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform float opacity;", "varying vec3 vNormal;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
      },
      'cube': {
        uniforms: {
          "tCube": {
            type: "t",
            value: null
          },
          "tFlip": {
            type: "f",
            value: -1
          }
        },
        vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform samplerCube tCube;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
      },
      'equirect': {
        uniforms: {
          "tEquirect": {
            type: "t",
            value: null
          },
          "tFlip": {
            type: "f",
            value: -1
          }
        },
        vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", "	vWorldPosition = transformDirection( position, modelMatrix );", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: ["uniform sampler2D tEquirect;", "uniform float tFlip;", "varying vec3 vWorldPosition;", THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "void main() {", "vec3 direction = normalize( vWorldPosition );", "vec2 sampleUV;", "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );", "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "gl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk["logdepthbuf_fragment"], "}"].join("\n")
      },
      'depthRGBA': {
        uniforms: {},
        vertexShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], THREE.ShaderChunk["logdepthbuf_pars_vertex"], "void main() {", THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], THREE.ShaderChunk["default_vertex"], THREE.ShaderChunk["logdepthbuf_vertex"], "}"].join("\n"),
        fragmentShader: [THREE.ShaderChunk["common"], THREE.ShaderChunk["logdepthbuf_pars_fragment"], "vec4 pack_depth( const in float depth ) {", "	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );", "	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );", "	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", "	res -= res.xxyz * bit_mask;", "	return res;", "}", "void main() {", THREE.ShaderChunk["logdepthbuf_fragment"], "	#ifdef USE_LOGDEPTHBUF_EXT", "		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );", "	#else", "		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );", "	#endif", "}"].join("\n")
      }
    };
    THREE.WebGLRenderer = function(parameters) {
      console.log('THREE.WebGLRenderer', THREE.REVISION);
      parameters = parameters || {};
      var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement('canvas'),
          _context = parameters.context !== undefined ? parameters.context : null,
          pixelRatio = 1,
          _precision = parameters.precision !== undefined ? parameters.precision : 'highp',
          _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
          _depth = parameters.depth !== undefined ? parameters.depth : true,
          _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
          _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
          _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
          _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
          _logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,
          _clearColor = new THREE.Color(0x000000),
          _clearAlpha = 0;
      var lights = [];
      var _webglObjects = {};
      var _webglObjectsImmediate = [];
      var opaqueObjects = [];
      var transparentObjects = [];
      var sprites = [];
      var lensFlares = [];
      this.domElement = _canvas;
      this.context = null;
      this.autoClear = true;
      this.autoClearColor = true;
      this.autoClearDepth = true;
      this.autoClearStencil = true;
      this.sortObjects = true;
      this.gammaFactor = 2.0;
      this.gammaInput = false;
      this.gammaOutput = false;
      this.shadowMapEnabled = false;
      this.shadowMapType = THREE.PCFShadowMap;
      this.shadowMapCullFace = THREE.CullFaceFront;
      this.shadowMapDebug = false;
      this.shadowMapCascade = false;
      this.maxMorphTargets = 8;
      this.maxMorphNormals = 4;
      this.autoScaleCubemaps = true;
      this.info = {
        memory: {
          programs: 0,
          geometries: 0,
          textures: 0
        },
        render: {
          calls: 0,
          vertices: 0,
          faces: 0,
          points: 0
        }
      };
      var _this = this,
          _programs = [],
          _currentProgram = null,
          _currentFramebuffer = null,
          _currentMaterialId = -1,
          _currentGeometryProgram = '',
          _currentCamera = null,
          _usedTextureUnits = 0,
          _viewportX = 0,
          _viewportY = 0,
          _viewportWidth = _canvas.width,
          _viewportHeight = _canvas.height,
          _currentWidth = 0,
          _currentHeight = 0,
          _frustum = new THREE.Frustum(),
          _projScreenMatrix = new THREE.Matrix4(),
          _vector3 = new THREE.Vector3(),
          _direction = new THREE.Vector3(),
          _lightsNeedUpdate = true,
          _lights = {
            ambient: [0, 0, 0],
            directional: {
              length: 0,
              colors: [],
              positions: []
            },
            point: {
              length: 0,
              colors: [],
              positions: [],
              distances: [],
              decays: []
            },
            spot: {
              length: 0,
              colors: [],
              positions: [],
              distances: [],
              directions: [],
              anglesCos: [],
              exponents: [],
              decays: []
            },
            hemi: {
              length: 0,
              skyColors: [],
              groundColors: [],
              positions: []
            }
          };
      var _gl;
      try {
        var attributes = {
          alpha: _alpha,
          depth: _depth,
          stencil: _stencil,
          antialias: _antialias,
          premultipliedAlpha: _premultipliedAlpha,
          preserveDrawingBuffer: _preserveDrawingBuffer
        };
        _gl = _context || _canvas.getContext('webgl', attributes) || _canvas.getContext('experimental-webgl', attributes);
        if (_gl === null) {
          if (_canvas.getContext('webgl') !== null) {
            throw 'Error creating WebGL context with your selected attributes.';
          } else {
            throw 'Error creating WebGL context.';
          }
        }
        _canvas.addEventListener('webglcontextlost', function(event) {
          event.preventDefault();
          resetGLState();
          setDefaultGLState();
          _webglObjects = {};
        }, false);
      } catch (error) {
        THREE.error('THREE.WebGLRenderer: ' + error);
      }
      var state = new THREE.WebGLState(_gl, paramThreeToGL);
      if (_gl.getShaderPrecisionFormat === undefined) {
        _gl.getShaderPrecisionFormat = function() {
          return {
            'rangeMin': 1,
            'rangeMax': 1,
            'precision': 1
          };
        };
      }
      var extensions = new THREE.WebGLExtensions(_gl);
      extensions.get('OES_texture_float');
      extensions.get('OES_texture_float_linear');
      extensions.get('OES_texture_half_float');
      extensions.get('OES_texture_half_float_linear');
      extensions.get('OES_standard_derivatives');
      if (_logarithmicDepthBuffer) {
        extensions.get('EXT_frag_depth');
      }
      var glClearColor = function(r, g, b, a) {
        if (_premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        _gl.clearColor(r, g, b, a);
      };
      var setDefaultGLState = function() {
        _gl.clearColor(0, 0, 0, 1);
        _gl.clearDepth(1);
        _gl.clearStencil(0);
        _gl.enable(_gl.DEPTH_TEST);
        _gl.depthFunc(_gl.LEQUAL);
        _gl.frontFace(_gl.CCW);
        _gl.cullFace(_gl.BACK);
        _gl.enable(_gl.CULL_FACE);
        _gl.enable(_gl.BLEND);
        _gl.blendEquation(_gl.FUNC_ADD);
        _gl.blendFunc(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA);
        _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
      };
      var resetGLState = function() {
        _currentProgram = null;
        _currentCamera = null;
        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        _lightsNeedUpdate = true;
        state.reset();
      };
      setDefaultGLState();
      this.context = _gl;
      this.state = state;
      var _maxTextures = _gl.getParameter(_gl.MAX_TEXTURE_IMAGE_UNITS);
      var _maxVertexTextures = _gl.getParameter(_gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
      var _maxTextureSize = _gl.getParameter(_gl.MAX_TEXTURE_SIZE);
      var _maxCubemapSize = _gl.getParameter(_gl.MAX_CUBE_MAP_TEXTURE_SIZE);
      var _supportsVertexTextures = _maxVertexTextures > 0;
      var _supportsBoneTextures = _supportsVertexTextures && extensions.get('OES_texture_float');
      var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.HIGH_FLOAT);
      var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT);
      var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT);
      var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat(_gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT);
      var getCompressedTextureFormats = (function() {
        var array;
        return function() {
          if (array !== undefined) {
            return array;
          }
          array = [];
          if (extensions.get('WEBGL_compressed_texture_pvrtc') || extensions.get('WEBGL_compressed_texture_s3tc')) {
            var formats = _gl.getParameter(_gl.COMPRESSED_TEXTURE_FORMATS);
            for (var i = 0; i < formats.length; i++) {
              array.push(formats[i]);
            }
          }
          return array;
        };
      })();
      var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
      var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;
      if (_precision === 'highp' && !highpAvailable) {
        if (mediumpAvailable) {
          _precision = 'mediump';
          THREE.warn('THREE.WebGLRenderer: highp not supported, using mediump.');
        } else {
          _precision = 'lowp';
          THREE.warn('THREE.WebGLRenderer: highp and mediump not supported, using lowp.');
        }
      }
      if (_precision === 'mediump' && !mediumpAvailable) {
        _precision = 'lowp';
        THREE.warn('THREE.WebGLRenderer: mediump not supported, using lowp.');
      }
      var shadowMapPlugin = new THREE.ShadowMapPlugin(this, lights, _webglObjects, _webglObjectsImmediate);
      var spritePlugin = new THREE.SpritePlugin(this, sprites);
      var lensFlarePlugin = new THREE.LensFlarePlugin(this, lensFlares);
      this.getContext = function() {
        return _gl;
      };
      this.forceContextLoss = function() {
        extensions.get('WEBGL_lose_context').loseContext();
      };
      this.supportsVertexTextures = function() {
        return _supportsVertexTextures;
      };
      this.supportsFloatTextures = function() {
        return extensions.get('OES_texture_float');
      };
      this.supportsHalfFloatTextures = function() {
        return extensions.get('OES_texture_half_float');
      };
      this.supportsStandardDerivatives = function() {
        return extensions.get('OES_standard_derivatives');
      };
      this.supportsCompressedTextureS3TC = function() {
        return extensions.get('WEBGL_compressed_texture_s3tc');
      };
      this.supportsCompressedTexturePVRTC = function() {
        return extensions.get('WEBGL_compressed_texture_pvrtc');
      };
      this.supportsBlendMinMax = function() {
        return extensions.get('EXT_blend_minmax');
      };
      this.getMaxAnisotropy = (function() {
        var value;
        return function() {
          if (value !== undefined) {
            return value;
          }
          var extension = extensions.get('EXT_texture_filter_anisotropic');
          value = extension !== null ? _gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
          return value;
        };
      })();
      this.getPrecision = function() {
        return _precision;
      };
      this.getPixelRatio = function() {
        return pixelRatio;
      };
      this.setPixelRatio = function(value) {
        pixelRatio = value;
      };
      this.setSize = function(width, height, updateStyle) {
        _canvas.width = width * pixelRatio;
        _canvas.height = height * pixelRatio;
        if (updateStyle !== false) {
          _canvas.style.width = width + 'px';
          _canvas.style.height = height + 'px';
        }
        this.setViewport(0, 0, width, height);
      };
      this.setViewport = function(x, y, width, height) {
        _viewportX = x * pixelRatio;
        _viewportY = y * pixelRatio;
        _viewportWidth = width * pixelRatio;
        _viewportHeight = height * pixelRatio;
        _gl.viewport(_viewportX, _viewportY, _viewportWidth, _viewportHeight);
      };
      this.setScissor = function(x, y, width, height) {
        _gl.scissor(x * pixelRatio, y * pixelRatio, width * pixelRatio, height * pixelRatio);
      };
      this.enableScissorTest = function(enable) {
        enable ? _gl.enable(_gl.SCISSOR_TEST) : _gl.disable(_gl.SCISSOR_TEST);
      };
      this.getClearColor = function() {
        return _clearColor;
      };
      this.setClearColor = function(color, alpha) {
        _clearColor.set(color);
        _clearAlpha = alpha !== undefined ? alpha : 1;
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
      };
      this.getClearAlpha = function() {
        return _clearAlpha;
      };
      this.setClearAlpha = function(alpha) {
        _clearAlpha = alpha;
        glClearColor(_clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha);
      };
      this.clear = function(color, depth, stencil) {
        var bits = 0;
        if (color === undefined || color)
          bits |= _gl.COLOR_BUFFER_BIT;
        if (depth === undefined || depth)
          bits |= _gl.DEPTH_BUFFER_BIT;
        if (stencil === undefined || stencil)
          bits |= _gl.STENCIL_BUFFER_BIT;
        _gl.clear(bits);
      };
      this.clearColor = function() {
        _gl.clear(_gl.COLOR_BUFFER_BIT);
      };
      this.clearDepth = function() {
        _gl.clear(_gl.DEPTH_BUFFER_BIT);
      };
      this.clearStencil = function() {
        _gl.clear(_gl.STENCIL_BUFFER_BIT);
      };
      this.clearTarget = function(renderTarget, color, depth, stencil) {
        this.setRenderTarget(renderTarget);
        this.clear(color, depth, stencil);
      };
      this.resetGLState = resetGLState;
      function createParticleBuffers(geometry) {
        geometry.__webglVertexBuffer = _gl.createBuffer();
        geometry.__webglColorBuffer = _gl.createBuffer();
        _this.info.memory.geometries++;
      }
      ;
      function createLineBuffers(geometry) {
        geometry.__webglVertexBuffer = _gl.createBuffer();
        geometry.__webglColorBuffer = _gl.createBuffer();
        geometry.__webglLineDistanceBuffer = _gl.createBuffer();
        _this.info.memory.geometries++;
      }
      ;
      function createMeshBuffers(geometryGroup) {
        geometryGroup.__webglVertexBuffer = _gl.createBuffer();
        geometryGroup.__webglNormalBuffer = _gl.createBuffer();
        geometryGroup.__webglTangentBuffer = _gl.createBuffer();
        geometryGroup.__webglColorBuffer = _gl.createBuffer();
        geometryGroup.__webglUVBuffer = _gl.createBuffer();
        geometryGroup.__webglUV2Buffer = _gl.createBuffer();
        geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
        geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();
        geometryGroup.__webglFaceBuffer = _gl.createBuffer();
        geometryGroup.__webglLineBuffer = _gl.createBuffer();
        var numMorphTargets = geometryGroup.numMorphTargets;
        if (numMorphTargets) {
          geometryGroup.__webglMorphTargetsBuffers = [];
          for (var m = 0,
              ml = numMorphTargets; m < ml; m++) {
            geometryGroup.__webglMorphTargetsBuffers.push(_gl.createBuffer());
          }
        }
        var numMorphNormals = geometryGroup.numMorphNormals;
        if (numMorphNormals) {
          geometryGroup.__webglMorphNormalsBuffers = [];
          for (var m = 0,
              ml = numMorphNormals; m < ml; m++) {
            geometryGroup.__webglMorphNormalsBuffers.push(_gl.createBuffer());
          }
        }
        _this.info.memory.geometries++;
      }
      ;
      var onObjectRemoved = function(event) {
        var object = event.target;
        object.traverse(function(child) {
          child.removeEventListener('remove', onObjectRemoved);
          removeObject(child);
        });
      };
      var onGeometryDispose = function(event) {
        var geometry = event.target;
        geometry.removeEventListener('dispose', onGeometryDispose);
        deallocateGeometry(geometry);
      };
      var onTextureDispose = function(event) {
        var texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        deallocateTexture(texture);
        _this.info.memory.textures--;
      };
      var onRenderTargetDispose = function(event) {
        var renderTarget = event.target;
        renderTarget.removeEventListener('dispose', onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        _this.info.memory.textures--;
      };
      var onMaterialDispose = function(event) {
        var material = event.target;
        material.removeEventListener('dispose', onMaterialDispose);
        deallocateMaterial(material);
      };
      var deleteBuffers = function(geometry) {
        var buffers = ['__webglVertexBuffer', '__webglNormalBuffer', '__webglTangentBuffer', '__webglColorBuffer', '__webglUVBuffer', '__webglUV2Buffer', '__webglSkinIndicesBuffer', '__webglSkinWeightsBuffer', '__webglFaceBuffer', '__webglLineBuffer', '__webglLineDistanceBuffer'];
        for (var i = 0,
            l = buffers.length; i < l; i++) {
          var name = buffers[i];
          if (geometry[name] !== undefined) {
            _gl.deleteBuffer(geometry[name]);
            delete geometry[name];
          }
        }
        if (geometry.__webglCustomAttributesList !== undefined) {
          for (var name in geometry.__webglCustomAttributesList) {
            _gl.deleteBuffer(geometry.__webglCustomAttributesList[name].buffer);
          }
          delete geometry.__webglCustomAttributesList;
        }
        _this.info.memory.geometries--;
      };
      var deallocateGeometry = function(geometry) {
        delete geometry.__webglInit;
        if (geometry instanceof THREE.BufferGeometry) {
          for (var name in geometry.attributes) {
            var attribute = geometry.attributes[name];
            if (attribute.buffer !== undefined) {
              _gl.deleteBuffer(attribute.buffer);
              delete attribute.buffer;
            }
          }
          _this.info.memory.geometries--;
        } else {
          var geometryGroupsList = geometryGroups[geometry.id];
          if (geometryGroupsList !== undefined) {
            for (var i = 0,
                l = geometryGroupsList.length; i < l; i++) {
              var geometryGroup = geometryGroupsList[i];
              if (geometryGroup.numMorphTargets !== undefined) {
                for (var m = 0,
                    ml = geometryGroup.numMorphTargets; m < ml; m++) {
                  _gl.deleteBuffer(geometryGroup.__webglMorphTargetsBuffers[m]);
                }
                delete geometryGroup.__webglMorphTargetsBuffers;
              }
              if (geometryGroup.numMorphNormals !== undefined) {
                for (var m = 0,
                    ml = geometryGroup.numMorphNormals; m < ml; m++) {
                  _gl.deleteBuffer(geometryGroup.__webglMorphNormalsBuffers[m]);
                }
                delete geometryGroup.__webglMorphNormalsBuffers;
              }
              deleteBuffers(geometryGroup);
            }
            delete geometryGroups[geometry.id];
          } else {
            deleteBuffers(geometry);
          }
        }
        _currentGeometryProgram = '';
      };
      var deallocateTexture = function(texture) {
        if (texture.image && texture.image.__webglTextureCube) {
          _gl.deleteTexture(texture.image.__webglTextureCube);
          delete texture.image.__webglTextureCube;
        } else {
          if (texture.__webglInit === undefined)
            return;
          _gl.deleteTexture(texture.__webglTexture);
          delete texture.__webglTexture;
          delete texture.__webglInit;
        }
      };
      var deallocateRenderTarget = function(renderTarget) {
        if (!renderTarget || renderTarget.__webglTexture === undefined)
          return;
        _gl.deleteTexture(renderTarget.__webglTexture);
        delete renderTarget.__webglTexture;
        if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
          for (var i = 0; i < 6; i++) {
            _gl.deleteFramebuffer(renderTarget.__webglFramebuffer[i]);
            _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer[i]);
          }
        } else {
          _gl.deleteFramebuffer(renderTarget.__webglFramebuffer);
          _gl.deleteRenderbuffer(renderTarget.__webglRenderbuffer);
        }
        delete renderTarget.__webglFramebuffer;
        delete renderTarget.__webglRenderbuffer;
      };
      var deallocateMaterial = function(material) {
        var program = material.program.program;
        if (program === undefined)
          return;
        material.program = undefined;
        var i,
            il,
            programInfo;
        var deleteProgram = false;
        for (i = 0, il = _programs.length; i < il; i++) {
          programInfo = _programs[i];
          if (programInfo.program === program) {
            programInfo.usedTimes--;
            if (programInfo.usedTimes === 0) {
              deleteProgram = true;
            }
            break;
          }
        }
        if (deleteProgram === true) {
          var newPrograms = [];
          for (i = 0, il = _programs.length; i < il; i++) {
            programInfo = _programs[i];
            if (programInfo.program !== program) {
              newPrograms.push(programInfo);
            }
          }
          _programs = newPrograms;
          _gl.deleteProgram(program);
          _this.info.memory.programs--;
        }
      };
      function initCustomAttributes(object) {
        var geometry = object.geometry;
        var material = object.material;
        var nvertices = geometry.vertices.length;
        if (material.attributes) {
          if (geometry.__webglCustomAttributesList === undefined) {
            geometry.__webglCustomAttributesList = [];
          }
          for (var name in material.attributes) {
            var attribute = material.attributes[name];
            if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {
              attribute.__webglInitialized = true;
              var size = 1;
              if (attribute.type === 'v2')
                size = 2;
              else if (attribute.type === 'v3')
                size = 3;
              else if (attribute.type === 'v4')
                size = 4;
              else if (attribute.type === 'c')
                size = 3;
              attribute.size = size;
              attribute.array = new Float32Array(nvertices * size);
              attribute.buffer = _gl.createBuffer();
              attribute.buffer.belongsToAttribute = name;
              attribute.needsUpdate = true;
            }
            geometry.__webglCustomAttributesList.push(attribute);
          }
        }
      }
      ;
      function initParticleBuffers(geometry, object) {
        var nvertices = geometry.vertices.length;
        geometry.__vertexArray = new Float32Array(nvertices * 3);
        geometry.__colorArray = new Float32Array(nvertices * 3);
        geometry.__webglParticleCount = nvertices;
        initCustomAttributes(object);
      }
      ;
      function initLineBuffers(geometry, object) {
        var nvertices = geometry.vertices.length;
        geometry.__vertexArray = new Float32Array(nvertices * 3);
        geometry.__colorArray = new Float32Array(nvertices * 3);
        geometry.__lineDistanceArray = new Float32Array(nvertices * 1);
        geometry.__webglLineCount = nvertices;
        initCustomAttributes(object);
      }
      ;
      function initMeshBuffers(geometryGroup, object) {
        var geometry = object.geometry,
            faces3 = geometryGroup.faces3,
            nvertices = faces3.length * 3,
            ntris = faces3.length * 1,
            nlines = faces3.length * 3,
            material = getBufferMaterial(object, geometryGroup);
        geometryGroup.__vertexArray = new Float32Array(nvertices * 3);
        geometryGroup.__normalArray = new Float32Array(nvertices * 3);
        geometryGroup.__colorArray = new Float32Array(nvertices * 3);
        geometryGroup.__uvArray = new Float32Array(nvertices * 2);
        if (geometry.faceVertexUvs.length > 1) {
          geometryGroup.__uv2Array = new Float32Array(nvertices * 2);
        }
        if (geometry.hasTangents) {
          geometryGroup.__tangentArray = new Float32Array(nvertices * 4);
        }
        if (object.geometry.skinWeights.length && object.geometry.skinIndices.length) {
          geometryGroup.__skinIndexArray = new Float32Array(nvertices * 4);
          geometryGroup.__skinWeightArray = new Float32Array(nvertices * 4);
        }
        var UintArray = extensions.get('OES_element_index_uint') !== null && ntris > 21845 ? Uint32Array : Uint16Array;
        geometryGroup.__typeArray = UintArray;
        geometryGroup.__faceArray = new UintArray(ntris * 3);
        geometryGroup.__lineArray = new UintArray(nlines * 2);
        var numMorphTargets = geometryGroup.numMorphTargets;
        if (numMorphTargets) {
          geometryGroup.__morphTargetsArrays = [];
          for (var m = 0,
              ml = numMorphTargets; m < ml; m++) {
            geometryGroup.__morphTargetsArrays.push(new Float32Array(nvertices * 3));
          }
        }
        var numMorphNormals = geometryGroup.numMorphNormals;
        if (numMorphNormals) {
          geometryGroup.__morphNormalsArrays = [];
          for (var m = 0,
              ml = numMorphNormals; m < ml; m++) {
            geometryGroup.__morphNormalsArrays.push(new Float32Array(nvertices * 3));
          }
        }
        geometryGroup.__webglFaceCount = ntris * 3;
        geometryGroup.__webglLineCount = nlines * 2;
        if (material.attributes) {
          if (geometryGroup.__webglCustomAttributesList === undefined) {
            geometryGroup.__webglCustomAttributesList = [];
          }
          for (var name in material.attributes) {
            var originalAttribute = material.attributes[name];
            var attribute = {};
            for (var property in originalAttribute) {
              attribute[property] = originalAttribute[property];
            }
            if (!attribute.__webglInitialized || attribute.createUniqueBuffers) {
              attribute.__webglInitialized = true;
              var size = 1;
              if (attribute.type === 'v2')
                size = 2;
              else if (attribute.type === 'v3')
                size = 3;
              else if (attribute.type === 'v4')
                size = 4;
              else if (attribute.type === 'c')
                size = 3;
              attribute.size = size;
              attribute.array = new Float32Array(nvertices * size);
              attribute.buffer = _gl.createBuffer();
              attribute.buffer.belongsToAttribute = name;
              originalAttribute.needsUpdate = true;
              attribute.__original = originalAttribute;
            }
            geometryGroup.__webglCustomAttributesList.push(attribute);
          }
        }
        geometryGroup.__inittedArrays = true;
      }
      ;
      function getBufferMaterial(object, geometryGroup) {
        return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[geometryGroup.materialIndex] : object.material;
      }
      function materialNeedsFaceNormals(material) {
        return material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading;
      }
      function setParticleBuffers(geometry, hint, object) {
        var v,
            c,
            vertex,
            offset,
            color,
            vertices = geometry.vertices,
            vl = vertices.length,
            colors = geometry.colors,
            cl = colors.length,
            vertexArray = geometry.__vertexArray,
            colorArray = geometry.__colorArray,
            dirtyVertices = geometry.verticesNeedUpdate,
            dirtyColors = geometry.colorsNeedUpdate,
            customAttributes = geometry.__webglCustomAttributesList,
            i,
            il,
            ca,
            cal,
            value,
            customAttribute;
        if (dirtyVertices) {
          for (v = 0; v < vl; v++) {
            vertex = vertices[v];
            offset = v * 3;
            vertexArray[offset] = vertex.x;
            vertexArray[offset + 1] = vertex.y;
            vertexArray[offset + 2] = vertex.z;
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
        }
        if (dirtyColors) {
          for (c = 0; c < cl; c++) {
            color = colors[c];
            offset = c * 3;
            colorArray[offset] = color.r;
            colorArray[offset + 1] = color.g;
            colorArray[offset + 2] = color.b;
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
        }
        if (customAttributes) {
          for (i = 0, il = customAttributes.length; i < il; i++) {
            customAttribute = customAttributes[i];
            if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices')) {
              cal = customAttribute.value.length;
              offset = 0;
              if (customAttribute.size === 1) {
                for (ca = 0; ca < cal; ca++) {
                  customAttribute.array[ca] = customAttribute.value[ca];
                }
              } else if (customAttribute.size === 2) {
                for (ca = 0; ca < cal; ca++) {
                  value = customAttribute.value[ca];
                  customAttribute.array[offset] = value.x;
                  customAttribute.array[offset + 1] = value.y;
                  offset += 2;
                }
              } else if (customAttribute.size === 3) {
                if (customAttribute.type === 'c') {
                  for (ca = 0; ca < cal; ca++) {
                    value = customAttribute.value[ca];
                    customAttribute.array[offset] = value.r;
                    customAttribute.array[offset + 1] = value.g;
                    customAttribute.array[offset + 2] = value.b;
                    offset += 3;
                  }
                } else {
                  for (ca = 0; ca < cal; ca++) {
                    value = customAttribute.value[ca];
                    customAttribute.array[offset] = value.x;
                    customAttribute.array[offset + 1] = value.y;
                    customAttribute.array[offset + 2] = value.z;
                    offset += 3;
                  }
                }
              } else if (customAttribute.size === 4) {
                for (ca = 0; ca < cal; ca++) {
                  value = customAttribute.value[ca];
                  customAttribute.array[offset] = value.x;
                  customAttribute.array[offset + 1] = value.y;
                  customAttribute.array[offset + 2] = value.z;
                  customAttribute.array[offset + 3] = value.w;
                  offset += 4;
                }
              }
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
            customAttribute.needsUpdate = false;
          }
        }
      }
      function setLineBuffers(geometry, hint) {
        var v,
            c,
            d,
            vertex,
            offset,
            color,
            vertices = geometry.vertices,
            colors = geometry.colors,
            lineDistances = geometry.lineDistances,
            vl = vertices.length,
            cl = colors.length,
            dl = lineDistances.length,
            vertexArray = geometry.__vertexArray,
            colorArray = geometry.__colorArray,
            lineDistanceArray = geometry.__lineDistanceArray,
            dirtyVertices = geometry.verticesNeedUpdate,
            dirtyColors = geometry.colorsNeedUpdate,
            dirtyLineDistances = geometry.lineDistancesNeedUpdate,
            customAttributes = geometry.__webglCustomAttributesList,
            i,
            il,
            ca,
            cal,
            value,
            customAttribute;
        if (dirtyVertices) {
          for (v = 0; v < vl; v++) {
            vertex = vertices[v];
            offset = v * 3;
            vertexArray[offset] = vertex.x;
            vertexArray[offset + 1] = vertex.y;
            vertexArray[offset + 2] = vertex.z;
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglVertexBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
        }
        if (dirtyColors) {
          for (c = 0; c < cl; c++) {
            color = colors[c];
            offset = c * 3;
            colorArray[offset] = color.r;
            colorArray[offset + 1] = color.g;
            colorArray[offset + 2] = color.b;
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglColorBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
        }
        if (dirtyLineDistances) {
          for (d = 0; d < dl; d++) {
            lineDistanceArray[d] = lineDistances[d];
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, lineDistanceArray, hint);
        }
        if (customAttributes) {
          for (i = 0, il = customAttributes.length; i < il; i++) {
            customAttribute = customAttributes[i];
            if (customAttribute.needsUpdate && (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices')) {
              offset = 0;
              cal = customAttribute.value.length;
              if (customAttribute.size === 1) {
                for (ca = 0; ca < cal; ca++) {
                  customAttribute.array[ca] = customAttribute.value[ca];
                }
              } else if (customAttribute.size === 2) {
                for (ca = 0; ca < cal; ca++) {
                  value = customAttribute.value[ca];
                  customAttribute.array[offset] = value.x;
                  customAttribute.array[offset + 1] = value.y;
                  offset += 2;
                }
              } else if (customAttribute.size === 3) {
                if (customAttribute.type === 'c') {
                  for (ca = 0; ca < cal; ca++) {
                    value = customAttribute.value[ca];
                    customAttribute.array[offset] = value.r;
                    customAttribute.array[offset + 1] = value.g;
                    customAttribute.array[offset + 2] = value.b;
                    offset += 3;
                  }
                } else {
                  for (ca = 0; ca < cal; ca++) {
                    value = customAttribute.value[ca];
                    customAttribute.array[offset] = value.x;
                    customAttribute.array[offset + 1] = value.y;
                    customAttribute.array[offset + 2] = value.z;
                    offset += 3;
                  }
                }
              } else if (customAttribute.size === 4) {
                for (ca = 0; ca < cal; ca++) {
                  value = customAttribute.value[ca];
                  customAttribute.array[offset] = value.x;
                  customAttribute.array[offset + 1] = value.y;
                  customAttribute.array[offset + 2] = value.z;
                  customAttribute.array[offset + 3] = value.w;
                  offset += 4;
                }
              }
              _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
              _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
              customAttribute.needsUpdate = false;
            }
          }
        }
      }
      function setMeshBuffers(geometryGroup, object, hint, dispose, material) {
        if (!geometryGroup.__inittedArrays) {
          return;
        }
        var needsFaceNormals = materialNeedsFaceNormals(material);
        var f,
            fl,
            fi,
            face,
            vertexNormals,
            faceNormal,
            vertexColors,
            faceColor,
            vertexTangents,
            uv,
            uv2,
            v1,
            v2,
            v3,
            t1,
            t2,
            t3,
            n1,
            n2,
            n3,
            c1,
            c2,
            c3,
            sw1,
            sw2,
            sw3,
            si1,
            si2,
            si3,
            i,
            il,
            vn,
            uvi,
            uv2i,
            vk,
            vkl,
            vka,
            nka,
            chf,
            faceVertexNormals,
            vertexIndex = 0,
            offset = 0,
            offset_uv = 0,
            offset_uv2 = 0,
            offset_face = 0,
            offset_normal = 0,
            offset_tangent = 0,
            offset_line = 0,
            offset_color = 0,
            offset_skin = 0,
            offset_morphTarget = 0,
            offset_custom = 0,
            value,
            vertexArray = geometryGroup.__vertexArray,
            uvArray = geometryGroup.__uvArray,
            uv2Array = geometryGroup.__uv2Array,
            normalArray = geometryGroup.__normalArray,
            tangentArray = geometryGroup.__tangentArray,
            colorArray = geometryGroup.__colorArray,
            skinIndexArray = geometryGroup.__skinIndexArray,
            skinWeightArray = geometryGroup.__skinWeightArray,
            morphTargetsArrays = geometryGroup.__morphTargetsArrays,
            morphNormalsArrays = geometryGroup.__morphNormalsArrays,
            customAttributes = geometryGroup.__webglCustomAttributesList,
            customAttribute,
            faceArray = geometryGroup.__faceArray,
            lineArray = geometryGroup.__lineArray,
            geometry = object.geometry,
            dirtyVertices = geometry.verticesNeedUpdate,
            dirtyElements = geometry.elementsNeedUpdate,
            dirtyUvs = geometry.uvsNeedUpdate,
            dirtyNormals = geometry.normalsNeedUpdate,
            dirtyTangents = geometry.tangentsNeedUpdate,
            dirtyColors = geometry.colorsNeedUpdate,
            dirtyMorphTargets = geometry.morphTargetsNeedUpdate,
            vertices = geometry.vertices,
            chunk_faces3 = geometryGroup.faces3,
            obj_faces = geometry.faces,
            obj_uvs = geometry.faceVertexUvs[0],
            obj_uvs2 = geometry.faceVertexUvs[1],
            obj_skinIndices = geometry.skinIndices,
            obj_skinWeights = geometry.skinWeights,
            morphTargets = geometry.morphTargets,
            morphNormals = geometry.morphNormals;
        if (dirtyVertices) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            face = obj_faces[chunk_faces3[f]];
            v1 = vertices[face.a];
            v2 = vertices[face.b];
            v3 = vertices[face.c];
            vertexArray[offset] = v1.x;
            vertexArray[offset + 1] = v1.y;
            vertexArray[offset + 2] = v1.z;
            vertexArray[offset + 3] = v2.x;
            vertexArray[offset + 4] = v2.y;
            vertexArray[offset + 5] = v2.z;
            vertexArray[offset + 6] = v3.x;
            vertexArray[offset + 7] = v3.y;
            vertexArray[offset + 8] = v3.z;
            offset += 9;
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, vertexArray, hint);
        }
        if (dirtyMorphTargets) {
          for (vk = 0, vkl = morphTargets.length; vk < vkl; vk++) {
            offset_morphTarget = 0;
            for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
              chf = chunk_faces3[f];
              face = obj_faces[chf];
              v1 = morphTargets[vk].vertices[face.a];
              v2 = morphTargets[vk].vertices[face.b];
              v3 = morphTargets[vk].vertices[face.c];
              vka = morphTargetsArrays[vk];
              vka[offset_morphTarget] = v1.x;
              vka[offset_morphTarget + 1] = v1.y;
              vka[offset_morphTarget + 2] = v1.z;
              vka[offset_morphTarget + 3] = v2.x;
              vka[offset_morphTarget + 4] = v2.y;
              vka[offset_morphTarget + 5] = v2.z;
              vka[offset_morphTarget + 6] = v3.x;
              vka[offset_morphTarget + 7] = v3.y;
              vka[offset_morphTarget + 8] = v3.z;
              if (material.morphNormals) {
                if (needsFaceNormals) {
                  n1 = morphNormals[vk].faceNormals[chf];
                  n2 = n1;
                  n3 = n1;
                } else {
                  faceVertexNormals = morphNormals[vk].vertexNormals[chf];
                  n1 = faceVertexNormals.a;
                  n2 = faceVertexNormals.b;
                  n3 = faceVertexNormals.c;
                }
                nka = morphNormalsArrays[vk];
                nka[offset_morphTarget] = n1.x;
                nka[offset_morphTarget + 1] = n1.y;
                nka[offset_morphTarget + 2] = n1.z;
                nka[offset_morphTarget + 3] = n2.x;
                nka[offset_morphTarget + 4] = n2.y;
                nka[offset_morphTarget + 5] = n2.z;
                nka[offset_morphTarget + 6] = n3.x;
                nka[offset_morphTarget + 7] = n3.y;
                nka[offset_morphTarget + 8] = n3.z;
              }
              offset_morphTarget += 9;
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[vk]);
            _gl.bufferData(_gl.ARRAY_BUFFER, morphTargetsArrays[vk], hint);
            if (material.morphNormals) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[vk]);
              _gl.bufferData(_gl.ARRAY_BUFFER, morphNormalsArrays[vk], hint);
            }
          }
        }
        if (obj_skinWeights.length) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            face = obj_faces[chunk_faces3[f]];
            sw1 = obj_skinWeights[face.a];
            sw2 = obj_skinWeights[face.b];
            sw3 = obj_skinWeights[face.c];
            skinWeightArray[offset_skin] = sw1.x;
            skinWeightArray[offset_skin + 1] = sw1.y;
            skinWeightArray[offset_skin + 2] = sw1.z;
            skinWeightArray[offset_skin + 3] = sw1.w;
            skinWeightArray[offset_skin + 4] = sw2.x;
            skinWeightArray[offset_skin + 5] = sw2.y;
            skinWeightArray[offset_skin + 6] = sw2.z;
            skinWeightArray[offset_skin + 7] = sw2.w;
            skinWeightArray[offset_skin + 8] = sw3.x;
            skinWeightArray[offset_skin + 9] = sw3.y;
            skinWeightArray[offset_skin + 10] = sw3.z;
            skinWeightArray[offset_skin + 11] = sw3.w;
            si1 = obj_skinIndices[face.a];
            si2 = obj_skinIndices[face.b];
            si3 = obj_skinIndices[face.c];
            skinIndexArray[offset_skin] = si1.x;
            skinIndexArray[offset_skin + 1] = si1.y;
            skinIndexArray[offset_skin + 2] = si1.z;
            skinIndexArray[offset_skin + 3] = si1.w;
            skinIndexArray[offset_skin + 4] = si2.x;
            skinIndexArray[offset_skin + 5] = si2.y;
            skinIndexArray[offset_skin + 6] = si2.z;
            skinIndexArray[offset_skin + 7] = si2.w;
            skinIndexArray[offset_skin + 8] = si3.x;
            skinIndexArray[offset_skin + 9] = si3.y;
            skinIndexArray[offset_skin + 10] = si3.z;
            skinIndexArray[offset_skin + 11] = si3.w;
            offset_skin += 12;
          }
          if (offset_skin > 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, skinIndexArray, hint);
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, skinWeightArray, hint);
          }
        }
        if (dirtyColors) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            face = obj_faces[chunk_faces3[f]];
            vertexColors = face.vertexColors;
            faceColor = face.color;
            if (vertexColors.length === 3 && material.vertexColors === THREE.VertexColors) {
              c1 = vertexColors[0];
              c2 = vertexColors[1];
              c3 = vertexColors[2];
            } else {
              c1 = faceColor;
              c2 = faceColor;
              c3 = faceColor;
            }
            colorArray[offset_color] = c1.r;
            colorArray[offset_color + 1] = c1.g;
            colorArray[offset_color + 2] = c1.b;
            colorArray[offset_color + 3] = c2.r;
            colorArray[offset_color + 4] = c2.g;
            colorArray[offset_color + 5] = c2.b;
            colorArray[offset_color + 6] = c3.r;
            colorArray[offset_color + 7] = c3.g;
            colorArray[offset_color + 8] = c3.b;
            offset_color += 9;
          }
          if (offset_color > 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, colorArray, hint);
          }
        }
        if (dirtyTangents && geometry.hasTangents) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            face = obj_faces[chunk_faces3[f]];
            vertexTangents = face.vertexTangents;
            t1 = vertexTangents[0];
            t2 = vertexTangents[1];
            t3 = vertexTangents[2];
            tangentArray[offset_tangent] = t1.x;
            tangentArray[offset_tangent + 1] = t1.y;
            tangentArray[offset_tangent + 2] = t1.z;
            tangentArray[offset_tangent + 3] = t1.w;
            tangentArray[offset_tangent + 4] = t2.x;
            tangentArray[offset_tangent + 5] = t2.y;
            tangentArray[offset_tangent + 6] = t2.z;
            tangentArray[offset_tangent + 7] = t2.w;
            tangentArray[offset_tangent + 8] = t3.x;
            tangentArray[offset_tangent + 9] = t3.y;
            tangentArray[offset_tangent + 10] = t3.z;
            tangentArray[offset_tangent + 11] = t3.w;
            offset_tangent += 12;
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, tangentArray, hint);
        }
        if (dirtyNormals) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            face = obj_faces[chunk_faces3[f]];
            vertexNormals = face.vertexNormals;
            faceNormal = face.normal;
            if (vertexNormals.length === 3 && needsFaceNormals === false) {
              for (i = 0; i < 3; i++) {
                vn = vertexNormals[i];
                normalArray[offset_normal] = vn.x;
                normalArray[offset_normal + 1] = vn.y;
                normalArray[offset_normal + 2] = vn.z;
                offset_normal += 3;
              }
            } else {
              for (i = 0; i < 3; i++) {
                normalArray[offset_normal] = faceNormal.x;
                normalArray[offset_normal + 1] = faceNormal.y;
                normalArray[offset_normal + 2] = faceNormal.z;
                offset_normal += 3;
              }
            }
          }
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, normalArray, hint);
        }
        if (dirtyUvs && obj_uvs) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            fi = chunk_faces3[f];
            uv = obj_uvs[fi];
            if (uv === undefined)
              continue;
            for (i = 0; i < 3; i++) {
              uvi = uv[i];
              uvArray[offset_uv] = uvi.x;
              uvArray[offset_uv + 1] = uvi.y;
              offset_uv += 2;
            }
          }
          if (offset_uv > 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, uvArray, hint);
          }
        }
        if (dirtyUvs && obj_uvs2) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            fi = chunk_faces3[f];
            uv2 = obj_uvs2[fi];
            if (uv2 === undefined)
              continue;
            for (i = 0; i < 3; i++) {
              uv2i = uv2[i];
              uv2Array[offset_uv2] = uv2i.x;
              uv2Array[offset_uv2 + 1] = uv2i.y;
              offset_uv2 += 2;
            }
          }
          if (offset_uv2 > 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, uv2Array, hint);
          }
        }
        if (dirtyElements) {
          for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
            faceArray[offset_face] = vertexIndex;
            faceArray[offset_face + 1] = vertexIndex + 1;
            faceArray[offset_face + 2] = vertexIndex + 2;
            offset_face += 3;
            lineArray[offset_line] = vertexIndex;
            lineArray[offset_line + 1] = vertexIndex + 1;
            lineArray[offset_line + 2] = vertexIndex;
            lineArray[offset_line + 3] = vertexIndex + 2;
            lineArray[offset_line + 4] = vertexIndex + 1;
            lineArray[offset_line + 5] = vertexIndex + 2;
            offset_line += 6;
            vertexIndex += 3;
          }
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
          _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, faceArray, hint);
          _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
          _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, lineArray, hint);
        }
        if (customAttributes) {
          for (i = 0, il = customAttributes.length; i < il; i++) {
            customAttribute = customAttributes[i];
            if (!customAttribute.__original.needsUpdate)
              continue;
            offset_custom = 0;
            if (customAttribute.size === 1) {
              if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  face = obj_faces[chunk_faces3[f]];
                  customAttribute.array[offset_custom] = customAttribute.value[face.a];
                  customAttribute.array[offset_custom + 1] = customAttribute.value[face.b];
                  customAttribute.array[offset_custom + 2] = customAttribute.value[face.c];
                  offset_custom += 3;
                }
              } else if (customAttribute.boundTo === 'faces') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  customAttribute.array[offset_custom] = value;
                  customAttribute.array[offset_custom + 1] = value;
                  customAttribute.array[offset_custom + 2] = value;
                  offset_custom += 3;
                }
              }
            } else if (customAttribute.size === 2) {
              if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  face = obj_faces[chunk_faces3[f]];
                  v1 = customAttribute.value[face.a];
                  v2 = customAttribute.value[face.b];
                  v3 = customAttribute.value[face.c];
                  customAttribute.array[offset_custom] = v1.x;
                  customAttribute.array[offset_custom + 1] = v1.y;
                  customAttribute.array[offset_custom + 2] = v2.x;
                  customAttribute.array[offset_custom + 3] = v2.y;
                  customAttribute.array[offset_custom + 4] = v3.x;
                  customAttribute.array[offset_custom + 5] = v3.y;
                  offset_custom += 6;
                }
              } else if (customAttribute.boundTo === 'faces') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  v1 = value;
                  v2 = value;
                  v3 = value;
                  customAttribute.array[offset_custom] = v1.x;
                  customAttribute.array[offset_custom + 1] = v1.y;
                  customAttribute.array[offset_custom + 2] = v2.x;
                  customAttribute.array[offset_custom + 3] = v2.y;
                  customAttribute.array[offset_custom + 4] = v3.x;
                  customAttribute.array[offset_custom + 5] = v3.y;
                  offset_custom += 6;
                }
              }
            } else if (customAttribute.size === 3) {
              var pp;
              if (customAttribute.type === 'c') {
                pp = ['r', 'g', 'b'];
              } else {
                pp = ['x', 'y', 'z'];
              }
              if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  face = obj_faces[chunk_faces3[f]];
                  v1 = customAttribute.value[face.a];
                  v2 = customAttribute.value[face.b];
                  v3 = customAttribute.value[face.c];
                  customAttribute.array[offset_custom] = v1[pp[0]];
                  customAttribute.array[offset_custom + 1] = v1[pp[1]];
                  customAttribute.array[offset_custom + 2] = v1[pp[2]];
                  customAttribute.array[offset_custom + 3] = v2[pp[0]];
                  customAttribute.array[offset_custom + 4] = v2[pp[1]];
                  customAttribute.array[offset_custom + 5] = v2[pp[2]];
                  customAttribute.array[offset_custom + 6] = v3[pp[0]];
                  customAttribute.array[offset_custom + 7] = v3[pp[1]];
                  customAttribute.array[offset_custom + 8] = v3[pp[2]];
                  offset_custom += 9;
                }
              } else if (customAttribute.boundTo === 'faces') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  v1 = value;
                  v2 = value;
                  v3 = value;
                  customAttribute.array[offset_custom] = v1[pp[0]];
                  customAttribute.array[offset_custom + 1] = v1[pp[1]];
                  customAttribute.array[offset_custom + 2] = v1[pp[2]];
                  customAttribute.array[offset_custom + 3] = v2[pp[0]];
                  customAttribute.array[offset_custom + 4] = v2[pp[1]];
                  customAttribute.array[offset_custom + 5] = v2[pp[2]];
                  customAttribute.array[offset_custom + 6] = v3[pp[0]];
                  customAttribute.array[offset_custom + 7] = v3[pp[1]];
                  customAttribute.array[offset_custom + 8] = v3[pp[2]];
                  offset_custom += 9;
                }
              } else if (customAttribute.boundTo === 'faceVertices') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  v1 = value[0];
                  v2 = value[1];
                  v3 = value[2];
                  customAttribute.array[offset_custom] = v1[pp[0]];
                  customAttribute.array[offset_custom + 1] = v1[pp[1]];
                  customAttribute.array[offset_custom + 2] = v1[pp[2]];
                  customAttribute.array[offset_custom + 3] = v2[pp[0]];
                  customAttribute.array[offset_custom + 4] = v2[pp[1]];
                  customAttribute.array[offset_custom + 5] = v2[pp[2]];
                  customAttribute.array[offset_custom + 6] = v3[pp[0]];
                  customAttribute.array[offset_custom + 7] = v3[pp[1]];
                  customAttribute.array[offset_custom + 8] = v3[pp[2]];
                  offset_custom += 9;
                }
              }
            } else if (customAttribute.size === 4) {
              if (customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  face = obj_faces[chunk_faces3[f]];
                  v1 = customAttribute.value[face.a];
                  v2 = customAttribute.value[face.b];
                  v3 = customAttribute.value[face.c];
                  customAttribute.array[offset_custom] = v1.x;
                  customAttribute.array[offset_custom + 1] = v1.y;
                  customAttribute.array[offset_custom + 2] = v1.z;
                  customAttribute.array[offset_custom + 3] = v1.w;
                  customAttribute.array[offset_custom + 4] = v2.x;
                  customAttribute.array[offset_custom + 5] = v2.y;
                  customAttribute.array[offset_custom + 6] = v2.z;
                  customAttribute.array[offset_custom + 7] = v2.w;
                  customAttribute.array[offset_custom + 8] = v3.x;
                  customAttribute.array[offset_custom + 9] = v3.y;
                  customAttribute.array[offset_custom + 10] = v3.z;
                  customAttribute.array[offset_custom + 11] = v3.w;
                  offset_custom += 12;
                }
              } else if (customAttribute.boundTo === 'faces') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  v1 = value;
                  v2 = value;
                  v3 = value;
                  customAttribute.array[offset_custom] = v1.x;
                  customAttribute.array[offset_custom + 1] = v1.y;
                  customAttribute.array[offset_custom + 2] = v1.z;
                  customAttribute.array[offset_custom + 3] = v1.w;
                  customAttribute.array[offset_custom + 4] = v2.x;
                  customAttribute.array[offset_custom + 5] = v2.y;
                  customAttribute.array[offset_custom + 6] = v2.z;
                  customAttribute.array[offset_custom + 7] = v2.w;
                  customAttribute.array[offset_custom + 8] = v3.x;
                  customAttribute.array[offset_custom + 9] = v3.y;
                  customAttribute.array[offset_custom + 10] = v3.z;
                  customAttribute.array[offset_custom + 11] = v3.w;
                  offset_custom += 12;
                }
              } else if (customAttribute.boundTo === 'faceVertices') {
                for (f = 0, fl = chunk_faces3.length; f < fl; f++) {
                  value = customAttribute.value[chunk_faces3[f]];
                  v1 = value[0];
                  v2 = value[1];
                  v3 = value[2];
                  customAttribute.array[offset_custom] = v1.x;
                  customAttribute.array[offset_custom + 1] = v1.y;
                  customAttribute.array[offset_custom + 2] = v1.z;
                  customAttribute.array[offset_custom + 3] = v1.w;
                  customAttribute.array[offset_custom + 4] = v2.x;
                  customAttribute.array[offset_custom + 5] = v2.y;
                  customAttribute.array[offset_custom + 6] = v2.z;
                  customAttribute.array[offset_custom + 7] = v2.w;
                  customAttribute.array[offset_custom + 8] = v3.x;
                  customAttribute.array[offset_custom + 9] = v3.y;
                  customAttribute.array[offset_custom + 10] = v3.z;
                  customAttribute.array[offset_custom + 11] = v3.w;
                  offset_custom += 12;
                }
              }
            }
            _gl.bindBuffer(_gl.ARRAY_BUFFER, customAttribute.buffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, customAttribute.array, hint);
          }
        }
        if (dispose) {
          delete geometryGroup.__inittedArrays;
          delete geometryGroup.__colorArray;
          delete geometryGroup.__normalArray;
          delete geometryGroup.__tangentArray;
          delete geometryGroup.__uvArray;
          delete geometryGroup.__uv2Array;
          delete geometryGroup.__faceArray;
          delete geometryGroup.__vertexArray;
          delete geometryGroup.__lineArray;
          delete geometryGroup.__skinIndexArray;
          delete geometryGroup.__skinWeightArray;
        }
      }
      ;
      this.renderBufferImmediate = function(object, program, material) {
        state.initAttributes();
        if (object.hasPositions && !object.__webglVertexBuffer)
          object.__webglVertexBuffer = _gl.createBuffer();
        if (object.hasNormals && !object.__webglNormalBuffer)
          object.__webglNormalBuffer = _gl.createBuffer();
        if (object.hasUvs && !object.__webglUvBuffer)
          object.__webglUvBuffer = _gl.createBuffer();
        if (object.hasColors && !object.__webglColorBuffer)
          object.__webglColorBuffer = _gl.createBuffer();
        if (object.hasPositions) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglVertexBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(program.attributes.position);
          _gl.vertexAttribPointer(program.attributes.position, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasNormals) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglNormalBuffer);
          if (material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading) {
            var nx,
                ny,
                nz,
                nax,
                nbx,
                ncx,
                nay,
                nby,
                ncy,
                naz,
                nbz,
                ncz,
                normalArray,
                i,
                il = object.count * 3;
            for (i = 0; i < il; i += 9) {
              normalArray = object.normalArray;
              nax = normalArray[i];
              nay = normalArray[i + 1];
              naz = normalArray[i + 2];
              nbx = normalArray[i + 3];
              nby = normalArray[i + 4];
              nbz = normalArray[i + 5];
              ncx = normalArray[i + 6];
              ncy = normalArray[i + 7];
              ncz = normalArray[i + 8];
              nx = (nax + nbx + ncx) / 3;
              ny = (nay + nby + ncy) / 3;
              nz = (naz + nbz + ncz) / 3;
              normalArray[i] = nx;
              normalArray[i + 1] = ny;
              normalArray[i + 2] = nz;
              normalArray[i + 3] = nx;
              normalArray[i + 4] = ny;
              normalArray[i + 5] = nz;
              normalArray[i + 6] = nx;
              normalArray[i + 7] = ny;
              normalArray[i + 8] = nz;
            }
          }
          _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(program.attributes.normal);
          _gl.vertexAttribPointer(program.attributes.normal, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasUvs && material.map) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglUvBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(program.attributes.uv);
          _gl.vertexAttribPointer(program.attributes.uv, 2, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasColors && material.vertexColors !== THREE.NoColors) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, object.__webglColorBuffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
          state.enableAttribute(program.attributes.color);
          _gl.vertexAttribPointer(program.attributes.color, 3, _gl.FLOAT, false, 0, 0);
        }
        state.disableUnusedAttributes();
        _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
        object.count = 0;
      };
      function setupVertexAttributes(material, program, geometry, startIndex) {
        var geometryAttributes = geometry.attributes;
        var programAttributes = program.attributes;
        var programAttributesKeys = program.attributesKeys;
        for (var i = 0,
            l = programAttributesKeys.length; i < l; i++) {
          var key = programAttributesKeys[i];
          var programAttribute = programAttributes[key];
          if (programAttribute >= 0) {
            var geometryAttribute = geometryAttributes[key];
            if (geometryAttribute !== undefined) {
              var size = geometryAttribute.itemSize;
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryAttribute.buffer);
              state.enableAttribute(programAttribute);
              _gl.vertexAttribPointer(programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4);
            } else if (material.defaultAttributeValues !== undefined) {
              if (material.defaultAttributeValues[key].length === 2) {
                _gl.vertexAttrib2fv(programAttribute, material.defaultAttributeValues[key]);
              } else if (material.defaultAttributeValues[key].length === 3) {
                _gl.vertexAttrib3fv(programAttribute, material.defaultAttributeValues[key]);
              }
            }
          }
        }
        state.disableUnusedAttributes();
      }
      this.renderBufferDirect = function(camera, lights, fog, material, geometry, object) {
        if (material.visible === false)
          return;
        updateObject(object);
        var program = setProgram(camera, lights, fog, material, object);
        var updateBuffers = false,
            wireframeBit = material.wireframe ? 1 : 0,
            geometryProgram = 'direct_' + geometry.id + '_' + program.id + '_' + wireframeBit;
        if (geometryProgram !== _currentGeometryProgram) {
          _currentGeometryProgram = geometryProgram;
          updateBuffers = true;
        }
        if (updateBuffers) {
          state.initAttributes();
        }
        if (object instanceof THREE.Mesh) {
          var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;
          var index = geometry.attributes.index;
          if (index) {
            var type,
                size;
            if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {
              type = _gl.UNSIGNED_INT;
              size = 4;
            } else {
              type = _gl.UNSIGNED_SHORT;
              size = 2;
            }
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              if (updateBuffers) {
                setupVertexAttributes(material, program, geometry, 0);
                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
              }
              _gl.drawElements(mode, index.array.length, type, 0);
              _this.info.render.calls++;
              _this.info.render.vertices += index.array.length;
              _this.info.render.faces += index.array.length / 3;
            } else {
              updateBuffers = true;
              for (var i = 0,
                  il = offsets.length; i < il; i++) {
                var startIndex = offsets[i].index;
                if (updateBuffers) {
                  setupVertexAttributes(material, program, geometry, startIndex);
                  _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
                }
                _gl.drawElements(mode, offsets[i].count, type, offsets[i].start * size);
                _this.info.render.calls++;
                _this.info.render.vertices += offsets[i].count;
                _this.info.render.faces += offsets[i].count / 3;
              }
            }
          } else {
            if (updateBuffers) {
              setupVertexAttributes(material, program, geometry, 0);
            }
            var position = geometry.attributes['position'];
            _gl.drawArrays(mode, 0, position.array.length / position.itemSize);
            _this.info.render.calls++;
            _this.info.render.vertices += position.array.length / position.itemSize;
            _this.info.render.faces += position.array.length / (3 * position.itemSize);
          }
        } else if (object instanceof THREE.PointCloud) {
          var mode = _gl.POINTS;
          var index = geometry.attributes.index;
          if (index) {
            var type,
                size;
            if (index.array instanceof Uint32Array && extensions.get('OES_element_index_uint')) {
              type = _gl.UNSIGNED_INT;
              size = 4;
            } else {
              type = _gl.UNSIGNED_SHORT;
              size = 2;
            }
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              if (updateBuffers) {
                setupVertexAttributes(material, program, geometry, 0);
                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
              }
              _gl.drawElements(mode, index.array.length, type, 0);
              _this.info.render.calls++;
              _this.info.render.points += index.array.length;
            } else {
              if (offsets.length > 1)
                updateBuffers = true;
              for (var i = 0,
                  il = offsets.length; i < il; i++) {
                var startIndex = offsets[i].index;
                if (updateBuffers) {
                  setupVertexAttributes(material, program, geometry, startIndex);
                  _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
                }
                _gl.drawElements(mode, offsets[i].count, type, offsets[i].start * size);
                _this.info.render.calls++;
                _this.info.render.points += offsets[i].count;
              }
            }
          } else {
            if (updateBuffers) {
              setupVertexAttributes(material, program, geometry, 0);
            }
            var position = geometry.attributes.position;
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              _gl.drawArrays(mode, 0, position.array.length / 3);
              _this.info.render.calls++;
              _this.info.render.points += position.array.length / 3;
            } else {
              for (var i = 0,
                  il = offsets.length; i < il; i++) {
                _gl.drawArrays(mode, offsets[i].index, offsets[i].count);
                _this.info.render.calls++;
                _this.info.render.points += offsets[i].count;
              }
            }
          }
        } else if (object instanceof THREE.Line) {
          var mode = (object.mode === THREE.LineStrip) ? _gl.LINE_STRIP : _gl.LINES;
          state.setLineWidth(material.linewidth * pixelRatio);
          var index = geometry.attributes.index;
          if (index) {
            var type,
                size;
            if (index.array instanceof Uint32Array) {
              type = _gl.UNSIGNED_INT;
              size = 4;
            } else {
              type = _gl.UNSIGNED_SHORT;
              size = 2;
            }
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              if (updateBuffers) {
                setupVertexAttributes(material, program, geometry, 0);
                _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
              }
              _gl.drawElements(mode, index.array.length, type, 0);
              _this.info.render.calls++;
              _this.info.render.vertices += index.array.length;
            } else {
              if (offsets.length > 1)
                updateBuffers = true;
              for (var i = 0,
                  il = offsets.length; i < il; i++) {
                var startIndex = offsets[i].index;
                if (updateBuffers) {
                  setupVertexAttributes(material, program, geometry, startIndex);
                  _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, index.buffer);
                }
                _gl.drawElements(mode, offsets[i].count, type, offsets[i].start * size);
                _this.info.render.calls++;
                _this.info.render.vertices += offsets[i].count;
              }
            }
          } else {
            if (updateBuffers) {
              setupVertexAttributes(material, program, geometry, 0);
            }
            var position = geometry.attributes.position;
            var offsets = geometry.offsets;
            if (offsets.length === 0) {
              _gl.drawArrays(mode, 0, position.array.length / 3);
              _this.info.render.calls++;
              _this.info.render.vertices += position.array.length / 3;
            } else {
              for (var i = 0,
                  il = offsets.length; i < il; i++) {
                _gl.drawArrays(mode, offsets[i].index, offsets[i].count);
                _this.info.render.calls++;
                _this.info.render.vertices += offsets[i].count;
              }
            }
          }
        }
      };
      this.renderBuffer = function(camera, lights, fog, material, geometryGroup, object) {
        if (material.visible === false)
          return;
        updateObject(object);
        var program = setProgram(camera, lights, fog, material, object);
        var attributes = program.attributes;
        var updateBuffers = false,
            wireframeBit = material.wireframe ? 1 : 0,
            geometryProgram = geometryGroup.id + '_' + program.id + '_' + wireframeBit;
        if (geometryProgram !== _currentGeometryProgram) {
          _currentGeometryProgram = geometryProgram;
          updateBuffers = true;
        }
        if (updateBuffers) {
          state.initAttributes();
        }
        if (!material.morphTargets && attributes.position >= 0) {
          if (updateBuffers) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
            state.enableAttribute(attributes.position);
            _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
          }
        } else {
          if (object.morphTargetBase) {
            setupMorphTargets(material, geometryGroup, object);
          }
        }
        if (updateBuffers) {
          if (geometryGroup.__webglCustomAttributesList) {
            for (var i = 0,
                il = geometryGroup.__webglCustomAttributesList.length; i < il; i++) {
              var attribute = geometryGroup.__webglCustomAttributesList[i];
              if (attributes[attribute.buffer.belongsToAttribute] >= 0) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, attribute.buffer);
                state.enableAttribute(attributes[attribute.buffer.belongsToAttribute]);
                _gl.vertexAttribPointer(attributes[attribute.buffer.belongsToAttribute], attribute.size, _gl.FLOAT, false, 0, 0);
              }
            }
          }
          if (attributes.color >= 0) {
            if (object.geometry.colors.length > 0 || object.geometry.faces.length > 0) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer);
              state.enableAttribute(attributes.color);
              _gl.vertexAttribPointer(attributes.color, 3, _gl.FLOAT, false, 0, 0);
            } else if (material.defaultAttributeValues !== undefined) {
              _gl.vertexAttrib3fv(attributes.color, material.defaultAttributeValues.color);
            }
          }
          if (attributes.normal >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer);
            state.enableAttribute(attributes.normal);
            _gl.vertexAttribPointer(attributes.normal, 3, _gl.FLOAT, false, 0, 0);
          }
          if (attributes.tangent >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer);
            state.enableAttribute(attributes.tangent);
            _gl.vertexAttribPointer(attributes.tangent, 4, _gl.FLOAT, false, 0, 0);
          }
          if (attributes.uv >= 0) {
            if (object.geometry.faceVertexUvs[0]) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer);
              state.enableAttribute(attributes.uv);
              _gl.vertexAttribPointer(attributes.uv, 2, _gl.FLOAT, false, 0, 0);
            } else if (material.defaultAttributeValues !== undefined) {
              _gl.vertexAttrib2fv(attributes.uv, material.defaultAttributeValues.uv);
            }
          }
          if (attributes.uv2 >= 0) {
            if (object.geometry.faceVertexUvs[1]) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer);
              state.enableAttribute(attributes.uv2);
              _gl.vertexAttribPointer(attributes.uv2, 2, _gl.FLOAT, false, 0, 0);
            } else if (material.defaultAttributeValues !== undefined) {
              _gl.vertexAttrib2fv(attributes.uv2, material.defaultAttributeValues.uv2);
            }
          }
          if (material.skinning && attributes.skinIndex >= 0 && attributes.skinWeight >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer);
            state.enableAttribute(attributes.skinIndex);
            _gl.vertexAttribPointer(attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0);
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer);
            state.enableAttribute(attributes.skinWeight);
            _gl.vertexAttribPointer(attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0);
          }
          if (attributes.lineDistance >= 0) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer);
            state.enableAttribute(attributes.lineDistance);
            _gl.vertexAttribPointer(attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0);
          }
        }
        state.disableUnusedAttributes();
        if (object instanceof THREE.Mesh) {
          var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;
          if (material.wireframe) {
            state.setLineWidth(material.wireframeLinewidth * pixelRatio);
            if (updateBuffers)
              _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer);
            _gl.drawElements(_gl.LINES, geometryGroup.__webglLineCount, type, 0);
          } else {
            if (updateBuffers)
              _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer);
            _gl.drawElements(_gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0);
          }
          _this.info.render.calls++;
          _this.info.render.vertices += geometryGroup.__webglFaceCount;
          _this.info.render.faces += geometryGroup.__webglFaceCount / 3;
        } else if (object instanceof THREE.Line) {
          var mode = (object.mode === THREE.LineStrip) ? _gl.LINE_STRIP : _gl.LINES;
          state.setLineWidth(material.linewidth * pixelRatio);
          _gl.drawArrays(mode, 0, geometryGroup.__webglLineCount);
          _this.info.render.calls++;
        } else if (object instanceof THREE.PointCloud) {
          _gl.drawArrays(_gl.POINTS, 0, geometryGroup.__webglParticleCount);
          _this.info.render.calls++;
          _this.info.render.points += geometryGroup.__webglParticleCount;
        }
      };
      function setupMorphTargets(material, geometryGroup, object) {
        var attributes = material.program.attributes;
        if (object.morphTargetBase !== -1 && attributes.position >= 0) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[object.morphTargetBase]);
          state.enableAttribute(attributes.position);
          _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
        } else if (attributes.position >= 0) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer);
          state.enableAttribute(attributes.position);
          _gl.vertexAttribPointer(attributes.position, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.morphTargetForcedOrder.length) {
          var m = 0;
          var order = object.morphTargetForcedOrder;
          var influences = object.morphTargetInfluences;
          var attribute;
          while (m < material.numSupportedMorphTargets && m < order.length) {
            attribute = attributes['morphTarget' + m];
            if (attribute >= 0) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[order[m]]);
              state.enableAttribute(attribute);
              _gl.vertexAttribPointer(attribute, 3, _gl.FLOAT, false, 0, 0);
            }
            attribute = attributes['morphNormal' + m];
            if (attribute >= 0 && material.morphNormals) {
              _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[order[m]]);
              state.enableAttribute(attribute);
              _gl.vertexAttribPointer(attribute, 3, _gl.FLOAT, false, 0, 0);
            }
            object.__webglMorphTargetInfluences[m] = influences[order[m]];
            m++;
          }
        } else {
          var activeInfluenceIndices = [];
          var influences = object.morphTargetInfluences;
          var morphTargets = object.geometry.morphTargets;
          if (influences.length > morphTargets.length) {
            console.warn('THREE.WebGLRenderer: Influences array is bigger than morphTargets array.');
            influences.length = morphTargets.length;
          }
          for (var i = 0,
              il = influences.length; i < il; i++) {
            var influence = influences[i];
            activeInfluenceIndices.push([influence, i]);
          }
          if (activeInfluenceIndices.length > material.numSupportedMorphTargets) {
            activeInfluenceIndices.sort(numericalSort);
            activeInfluenceIndices.length = material.numSupportedMorphTargets;
          } else if (activeInfluenceIndices.length > material.numSupportedMorphNormals) {
            activeInfluenceIndices.sort(numericalSort);
          } else if (activeInfluenceIndices.length === 0) {
            activeInfluenceIndices.push([0, 0]);
          }
          var attribute;
          for (var m = 0,
              ml = material.numSupportedMorphTargets; m < ml; m++) {
            if (activeInfluenceIndices[m]) {
              var influenceIndex = activeInfluenceIndices[m][1];
              attribute = attributes['morphTarget' + m];
              if (attribute >= 0) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[influenceIndex]);
                state.enableAttribute(attribute);
                _gl.vertexAttribPointer(attribute, 3, _gl.FLOAT, false, 0, 0);
              }
              attribute = attributes['morphNormal' + m];
              if (attribute >= 0 && material.morphNormals) {
                _gl.bindBuffer(_gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[influenceIndex]);
                state.enableAttribute(attribute);
                _gl.vertexAttribPointer(attribute, 3, _gl.FLOAT, false, 0, 0);
              }
              object.__webglMorphTargetInfluences[m] = influences[influenceIndex];
            } else {
              object.__webglMorphTargetInfluences[m] = 0;
            }
          }
        }
        if (material.program.uniforms.morphTargetInfluences !== null) {
          _gl.uniform1fv(material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences);
        }
      }
      function painterSortStable(a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
          return a.object.renderOrder - b.object.renderOrder;
        } else if (a.material.id !== b.material.id) {
          return a.material.id - b.material.id;
        } else if (a.z !== b.z) {
          return a.z - b.z;
        } else {
          return a.id - b.id;
        }
      }
      function reversePainterSortStable(a, b) {
        if (a.object.renderOrder !== b.object.renderOrder) {
          return a.object.renderOrder - b.object.renderOrder;
        }
        if (a.z !== b.z) {
          return b.z - a.z;
        } else {
          return a.id - b.id;
        }
      }
      function numericalSort(a, b) {
        return b[0] - a[0];
      }
      this.render = function(scene, camera, renderTarget, forceClear) {
        if (camera instanceof THREE.Camera === false) {
          THREE.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
          return;
        }
        var fog = scene.fog;
        _currentGeometryProgram = '';
        _currentMaterialId = -1;
        _currentCamera = null;
        _lightsNeedUpdate = true;
        if (scene.autoUpdate === true)
          scene.updateMatrixWorld();
        if (camera.parent === undefined)
          camera.updateMatrixWorld();
        scene.traverse(function(object) {
          if (object instanceof THREE.SkinnedMesh) {
            object.skeleton.update();
          }
        });
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromMatrix(_projScreenMatrix);
        lights.length = 0;
        opaqueObjects.length = 0;
        transparentObjects.length = 0;
        sprites.length = 0;
        lensFlares.length = 0;
        projectObject(scene);
        if (_this.sortObjects === true) {
          opaqueObjects.sort(painterSortStable);
          transparentObjects.sort(reversePainterSortStable);
        }
        shadowMapPlugin.render(scene, camera);
        _this.info.render.calls = 0;
        _this.info.render.vertices = 0;
        _this.info.render.faces = 0;
        _this.info.render.points = 0;
        this.setRenderTarget(renderTarget);
        if (this.autoClear || forceClear) {
          this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
        }
        for (var i = 0,
            il = _webglObjectsImmediate.length; i < il; i++) {
          var webglObject = _webglObjectsImmediate[i];
          var object = webglObject.object;
          if (object.visible) {
            setupMatrices(object, camera);
            unrollImmediateBufferMaterial(webglObject);
          }
        }
        if (scene.overrideMaterial) {
          var overrideMaterial = scene.overrideMaterial;
          setMaterial(overrideMaterial);
          renderObjects(opaqueObjects, camera, lights, fog, overrideMaterial);
          renderObjects(transparentObjects, camera, lights, fog, overrideMaterial);
          renderObjectsImmediate(_webglObjectsImmediate, '', camera, lights, fog, overrideMaterial);
        } else {
          state.setBlending(THREE.NoBlending);
          renderObjects(opaqueObjects, camera, lights, fog, null);
          renderObjectsImmediate(_webglObjectsImmediate, 'opaque', camera, lights, fog, null);
          renderObjects(transparentObjects, camera, lights, fog, null);
          renderObjectsImmediate(_webglObjectsImmediate, 'transparent', camera, lights, fog, null);
        }
        spritePlugin.render(scene, camera);
        lensFlarePlugin.render(scene, camera, _currentWidth, _currentHeight);
        if (renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter) {
          updateRenderTargetMipmap(renderTarget);
        }
        state.setDepthTest(true);
        state.setDepthWrite(true);
        state.setColorWrite(true);
      };
      function projectObject(object) {
        if (object.visible === false)
          return;
        if (object instanceof THREE.Scene || object instanceof THREE.Group) {} else {
          initObject(object);
          if (object instanceof THREE.Light) {
            lights.push(object);
          } else if (object instanceof THREE.Sprite) {
            sprites.push(object);
          } else if (object instanceof THREE.LensFlare) {
            lensFlares.push(object);
          } else {
            var webglObjects = _webglObjects[object.id];
            if (webglObjects && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
              for (var i = 0,
                  l = webglObjects.length; i < l; i++) {
                var webglObject = webglObjects[i];
                unrollBufferMaterial(webglObject);
                webglObject.render = true;
                if (_this.sortObjects === true) {
                  _vector3.setFromMatrixPosition(object.matrixWorld);
                  _vector3.applyProjection(_projScreenMatrix);
                  webglObject.z = _vector3.z;
                }
              }
            }
          }
        }
        for (var i = 0,
            l = object.children.length; i < l; i++) {
          projectObject(object.children[i]);
        }
      }
      function renderObjects(renderList, camera, lights, fog, overrideMaterial) {
        var material;
        for (var i = 0,
            l = renderList.length; i < l; i++) {
          var webglObject = renderList[i];
          var object = webglObject.object;
          var buffer = webglObject.buffer;
          setupMatrices(object, camera);
          if (overrideMaterial) {
            material = overrideMaterial;
          } else {
            material = webglObject.material;
            if (!material)
              continue;
            setMaterial(material);
          }
          _this.setMaterialFaces(material);
          if (buffer instanceof THREE.BufferGeometry) {
            _this.renderBufferDirect(camera, lights, fog, material, buffer, object);
          } else {
            _this.renderBuffer(camera, lights, fog, material, buffer, object);
          }
        }
      }
      function renderObjectsImmediate(renderList, materialType, camera, lights, fog, overrideMaterial) {
        var material;
        for (var i = 0,
            l = renderList.length; i < l; i++) {
          var webglObject = renderList[i];
          var object = webglObject.object;
          if (object.visible) {
            if (overrideMaterial) {
              material = overrideMaterial;
            } else {
              material = webglObject[materialType];
              if (!material)
                continue;
              setMaterial(material);
            }
            _this.renderImmediateObject(camera, lights, fog, material, object);
          }
        }
      }
      this.renderImmediateObject = function(camera, lights, fog, material, object) {
        var program = setProgram(camera, lights, fog, material, object);
        _currentGeometryProgram = '';
        _this.setMaterialFaces(material);
        if (object.immediateRenderCallback) {
          object.immediateRenderCallback(program, _gl, _frustum);
        } else {
          object.render(function(object) {
            _this.renderBufferImmediate(object, program, material);
          });
        }
      };
      function unrollImmediateBufferMaterial(globject) {
        var object = globject.object,
            material = object.material;
        if (material.transparent) {
          globject.transparent = material;
          globject.opaque = null;
        } else {
          globject.opaque = material;
          globject.transparent = null;
        }
      }
      function unrollBufferMaterial(globject) {
        var object = globject.object;
        var buffer = globject.buffer;
        var geometry = object.geometry;
        var material = object.material;
        if (material instanceof THREE.MeshFaceMaterial) {
          var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;
          material = material.materials[materialIndex];
          globject.material = material;
          if (material.transparent) {
            transparentObjects.push(globject);
          } else {
            opaqueObjects.push(globject);
          }
        } else if (material) {
          globject.material = material;
          if (material.transparent) {
            transparentObjects.push(globject);
          } else {
            opaqueObjects.push(globject);
          }
        }
      }
      function initObject(object) {
        if (object.__webglInit === undefined) {
          object.__webglInit = true;
          object._modelViewMatrix = new THREE.Matrix4();
          object._normalMatrix = new THREE.Matrix3();
          object.addEventListener('removed', onObjectRemoved);
        }
        var geometry = object.geometry;
        if (geometry === undefined) {} else if (geometry.__webglInit === undefined) {
          geometry.__webglInit = true;
          geometry.addEventListener('dispose', onGeometryDispose);
          if (geometry instanceof THREE.BufferGeometry) {
            _this.info.memory.geometries++;
          } else if (object instanceof THREE.Mesh) {
            initGeometryGroups(object, geometry);
          } else if (object instanceof THREE.Line) {
            if (geometry.__webglVertexBuffer === undefined) {
              createLineBuffers(geometry);
              initLineBuffers(geometry, object);
              geometry.verticesNeedUpdate = true;
              geometry.colorsNeedUpdate = true;
              geometry.lineDistancesNeedUpdate = true;
            }
          } else if (object instanceof THREE.PointCloud) {
            if (geometry.__webglVertexBuffer === undefined) {
              createParticleBuffers(geometry);
              initParticleBuffers(geometry, object);
              geometry.verticesNeedUpdate = true;
              geometry.colorsNeedUpdate = true;
            }
          }
        }
        if (object.__webglActive === undefined) {
          object.__webglActive = true;
          if (object instanceof THREE.Mesh) {
            if (geometry instanceof THREE.BufferGeometry) {
              addBuffer(_webglObjects, geometry, object);
            } else if (geometry instanceof THREE.Geometry) {
              var geometryGroupsList = geometryGroups[geometry.id];
              for (var i = 0,
                  l = geometryGroupsList.length; i < l; i++) {
                addBuffer(_webglObjects, geometryGroupsList[i], object);
              }
            }
          } else if (object instanceof THREE.Line || object instanceof THREE.PointCloud) {
            addBuffer(_webglObjects, geometry, object);
          } else if (object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback) {
            addBufferImmediate(_webglObjectsImmediate, object);
          }
        }
      }
      var geometryGroups = {};
      var geometryGroupCounter = 0;
      function makeGroups(geometry, usesFaceMaterial) {
        var maxVerticesInGroup = extensions.get('OES_element_index_uint') ? 4294967296 : 65535;
        var groupHash,
            hash_map = {};
        var numMorphTargets = geometry.morphTargets.length;
        var numMorphNormals = geometry.morphNormals.length;
        var group;
        var groups = {};
        var groupsList = [];
        for (var f = 0,
            fl = geometry.faces.length; f < fl; f++) {
          var face = geometry.faces[f];
          var materialIndex = usesFaceMaterial ? face.materialIndex : 0;
          if (!(materialIndex in hash_map)) {
            hash_map[materialIndex] = {
              hash: materialIndex,
              counter: 0
            };
          }
          groupHash = hash_map[materialIndex].hash + '_' + hash_map[materialIndex].counter;
          if (!(groupHash in groups)) {
            group = {
              id: geometryGroupCounter++,
              faces3: [],
              materialIndex: materialIndex,
              vertices: 0,
              numMorphTargets: numMorphTargets,
              numMorphNormals: numMorphNormals
            };
            groups[groupHash] = group;
            groupsList.push(group);
          }
          if (groups[groupHash].vertices + 3 > maxVerticesInGroup) {
            hash_map[materialIndex].counter += 1;
            groupHash = hash_map[materialIndex].hash + '_' + hash_map[materialIndex].counter;
            if (!(groupHash in groups)) {
              group = {
                id: geometryGroupCounter++,
                faces3: [],
                materialIndex: materialIndex,
                vertices: 0,
                numMorphTargets: numMorphTargets,
                numMorphNormals: numMorphNormals
              };
              groups[groupHash] = group;
              groupsList.push(group);
            }
          }
          groups[groupHash].faces3.push(f);
          groups[groupHash].vertices += 3;
        }
        return groupsList;
      }
      function initGeometryGroups(object, geometry) {
        var material = object.material,
            addBuffers = false;
        if (geometryGroups[geometry.id] === undefined || geometry.groupsNeedUpdate === true) {
          delete _webglObjects[object.id];
          geometryGroups[geometry.id] = makeGroups(geometry, material instanceof THREE.MeshFaceMaterial);
          geometry.groupsNeedUpdate = false;
        }
        var geometryGroupsList = geometryGroups[geometry.id];
        for (var i = 0,
            il = geometryGroupsList.length; i < il; i++) {
          var geometryGroup = geometryGroupsList[i];
          if (geometryGroup.__webglVertexBuffer === undefined) {
            createMeshBuffers(geometryGroup);
            initMeshBuffers(geometryGroup, object);
            geometry.verticesNeedUpdate = true;
            geometry.morphTargetsNeedUpdate = true;
            geometry.elementsNeedUpdate = true;
            geometry.uvsNeedUpdate = true;
            geometry.normalsNeedUpdate = true;
            geometry.tangentsNeedUpdate = true;
            geometry.colorsNeedUpdate = true;
            addBuffers = true;
          } else {
            addBuffers = false;
          }
          if (addBuffers || object.__webglActive === undefined) {
            addBuffer(_webglObjects, geometryGroup, object);
          }
        }
        object.__webglActive = true;
      }
      function addBuffer(objlist, buffer, object) {
        var id = object.id;
        objlist[id] = objlist[id] || [];
        objlist[id].push({
          id: id,
          buffer: buffer,
          object: object,
          material: null,
          z: 0
        });
      }
      ;
      function addBufferImmediate(objlist, object) {
        objlist.push({
          id: null,
          object: object,
          opaque: null,
          transparent: null,
          z: 0
        });
      }
      ;
      function updateObject(object) {
        var geometry = object.geometry;
        if (geometry instanceof THREE.BufferGeometry) {
          var attributes = geometry.attributes;
          var attributesKeys = geometry.attributesKeys;
          for (var i = 0,
              l = attributesKeys.length; i < l; i++) {
            var key = attributesKeys[i];
            var attribute = attributes[key];
            var bufferType = (key === 'index') ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;
            if (attribute.buffer === undefined) {
              attribute.buffer = _gl.createBuffer();
              _gl.bindBuffer(bufferType, attribute.buffer);
              _gl.bufferData(bufferType, attribute.array, (attribute instanceof THREE.DynamicBufferAttribute) ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);
              attribute.needsUpdate = false;
            } else if (attribute.needsUpdate === true) {
              _gl.bindBuffer(bufferType, attribute.buffer);
              if (attribute.updateRange === undefined || attribute.updateRange.count === -1) {
                _gl.bufferSubData(bufferType, 0, attribute.array);
              } else if (attribute.updateRange.count === 0) {
                console.error('THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.');
              } else {
                _gl.bufferSubData(bufferType, attribute.updateRange.offset * attribute.array.BYTES_PER_ELEMENT, attribute.array.subarray(attribute.updateRange.offset, attribute.updateRange.offset + attribute.updateRange.count));
                attribute.updateRange.count = 0;
              }
              attribute.needsUpdate = false;
            }
          }
        } else if (object instanceof THREE.Mesh) {
          if (geometry.groupsNeedUpdate === true) {
            initGeometryGroups(object, geometry);
          }
          var geometryGroupsList = geometryGroups[geometry.id];
          for (var i = 0,
              il = geometryGroupsList.length; i < il; i++) {
            var geometryGroup = geometryGroupsList[i];
            var material = getBufferMaterial(object, geometryGroup);
            var customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
            if (geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate || geometry.uvsNeedUpdate || geometry.normalsNeedUpdate || geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty) {
              setMeshBuffers(geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material);
            }
          }
          geometry.verticesNeedUpdate = false;
          geometry.morphTargetsNeedUpdate = false;
          geometry.elementsNeedUpdate = false;
          geometry.uvsNeedUpdate = false;
          geometry.normalsNeedUpdate = false;
          geometry.colorsNeedUpdate = false;
          geometry.tangentsNeedUpdate = false;
          material.attributes && clearCustomAttributes(material);
        } else if (object instanceof THREE.Line) {
          var material = getBufferMaterial(object, geometry);
          var customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
          if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty) {
            setLineBuffers(geometry, _gl.DYNAMIC_DRAW);
          }
          geometry.verticesNeedUpdate = false;
          geometry.colorsNeedUpdate = false;
          geometry.lineDistancesNeedUpdate = false;
          material.attributes && clearCustomAttributes(material);
        } else if (object instanceof THREE.PointCloud) {
          var material = getBufferMaterial(object, geometry);
          var customAttributesDirty = material.attributes && areCustomAttributesDirty(material);
          if (geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || customAttributesDirty) {
            setParticleBuffers(geometry, _gl.DYNAMIC_DRAW, object);
          }
          geometry.verticesNeedUpdate = false;
          geometry.colorsNeedUpdate = false;
          material.attributes && clearCustomAttributes(material);
        }
      }
      function areCustomAttributesDirty(material) {
        for (var name in material.attributes) {
          if (material.attributes[name].needsUpdate)
            return true;
        }
        return false;
      }
      function clearCustomAttributes(material) {
        for (var name in material.attributes) {
          material.attributes[name].needsUpdate = false;
        }
      }
      function removeObject(object) {
        if (object instanceof THREE.Mesh || object instanceof THREE.PointCloud || object instanceof THREE.Line) {
          delete _webglObjects[object.id];
        } else if (object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback) {
          removeInstances(_webglObjectsImmediate, object);
        }
        delete object.__webglInit;
        delete object._modelViewMatrix;
        delete object._normalMatrix;
        delete object.__webglActive;
      }
      function removeInstances(objlist, object) {
        for (var o = objlist.length - 1; o >= 0; o--) {
          if (objlist[o].object === object) {
            objlist.splice(o, 1);
          }
        }
      }
      var shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointCloudMaterial: 'particle_basic'
      };
      function initMaterial(material, lights, fog, object) {
        material.addEventListener('dispose', onMaterialDispose);
        var shaderID = shaderIDs[material.type];
        if (shaderID) {
          var shader = THREE.ShaderLib[shaderID];
          material.__webglShader = {
            uniforms: THREE.UniformsUtils.clone(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
          };
        } else {
          material.__webglShader = {
            uniforms: material.uniforms,
            vertexShader: material.vertexShader,
            fragmentShader: material.fragmentShader
          };
        }
        var maxLightCount = allocateLights(lights);
        var maxShadows = allocateShadows(lights);
        var maxBones = allocateBones(object);
        var parameters = {
          precision: _precision,
          supportsVertexTextures: _supportsVertexTextures,
          map: !!material.map,
          envMap: !!material.envMap,
          envMapMode: material.envMap && material.envMap.mapping,
          lightMap: !!material.lightMap,
          bumpMap: !!material.bumpMap,
          normalMap: !!material.normalMap,
          specularMap: !!material.specularMap,
          alphaMap: !!material.alphaMap,
          combine: material.combine,
          vertexColors: material.vertexColors,
          fog: fog,
          useFog: material.fog,
          fogExp: fog instanceof THREE.FogExp2,
          flatShading: material.shading === THREE.FlatShading,
          sizeAttenuation: material.sizeAttenuation,
          logarithmicDepthBuffer: _logarithmicDepthBuffer,
          skinning: material.skinning,
          maxBones: maxBones,
          useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,
          morphTargets: material.morphTargets,
          morphNormals: material.morphNormals,
          maxMorphTargets: _this.maxMorphTargets,
          maxMorphNormals: _this.maxMorphNormals,
          maxDirLights: maxLightCount.directional,
          maxPointLights: maxLightCount.point,
          maxSpotLights: maxLightCount.spot,
          maxHemiLights: maxLightCount.hemi,
          maxShadows: maxShadows,
          shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
          shadowMapType: _this.shadowMapType,
          shadowMapDebug: _this.shadowMapDebug,
          shadowMapCascade: _this.shadowMapCascade,
          alphaTest: material.alphaTest,
          metal: material.metal,
          wrapAround: material.wrapAround,
          doubleSided: material.side === THREE.DoubleSide,
          flipSided: material.side === THREE.BackSide
        };
        var chunks = [];
        if (shaderID) {
          chunks.push(shaderID);
        } else {
          chunks.push(material.fragmentShader);
          chunks.push(material.vertexShader);
        }
        if (material.defines !== undefined) {
          for (var name in material.defines) {
            chunks.push(name);
            chunks.push(material.defines[name]);
          }
        }
        for (var name in parameters) {
          chunks.push(name);
          chunks.push(parameters[name]);
        }
        var code = chunks.join();
        var program;
        for (var p = 0,
            pl = _programs.length; p < pl; p++) {
          var programInfo = _programs[p];
          if (programInfo.code === code) {
            program = programInfo;
            program.usedTimes++;
            break;
          }
        }
        if (program === undefined) {
          program = new THREE.WebGLProgram(_this, code, material, parameters);
          _programs.push(program);
          _this.info.memory.programs = _programs.length;
        }
        material.program = program;
        var attributes = program.attributes;
        if (material.morphTargets) {
          material.numSupportedMorphTargets = 0;
          var id,
              base = 'morphTarget';
          for (var i = 0; i < _this.maxMorphTargets; i++) {
            id = base + i;
            if (attributes[id] >= 0) {
              material.numSupportedMorphTargets++;
            }
          }
        }
        if (material.morphNormals) {
          material.numSupportedMorphNormals = 0;
          var id,
              base = 'morphNormal';
          for (i = 0; i < _this.maxMorphNormals; i++) {
            id = base + i;
            if (attributes[id] >= 0) {
              material.numSupportedMorphNormals++;
            }
          }
        }
        material.uniformsList = [];
        for (var u in material.__webglShader.uniforms) {
          var location = material.program.uniforms[u];
          if (location) {
            material.uniformsList.push([material.__webglShader.uniforms[u], location]);
          }
        }
      }
      function setMaterial(material) {
        if (material.transparent === true) {
          state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha);
        } else {
          state.setBlending(THREE.NoBlending);
        }
        state.setDepthTest(material.depthTest);
        state.setDepthWrite(material.depthWrite);
        state.setColorWrite(material.colorWrite);
        state.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      }
      function setProgram(camera, lights, fog, material, object) {
        _usedTextureUnits = 0;
        if (material.needsUpdate) {
          if (material.program)
            deallocateMaterial(material);
          initMaterial(material, lights, fog, object);
          material.needsUpdate = false;
        }
        if (material.morphTargets) {
          if (!object.__webglMorphTargetInfluences) {
            object.__webglMorphTargetInfluences = new Float32Array(_this.maxMorphTargets);
          }
        }
        var refreshProgram = false;
        var refreshMaterial = false;
        var refreshLights = false;
        var program = material.program,
            p_uniforms = program.uniforms,
            m_uniforms = material.__webglShader.uniforms;
        if (program.id !== _currentProgram) {
          _gl.useProgram(program.program);
          _currentProgram = program.id;
          refreshProgram = true;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
          if (_currentMaterialId === -1)
            refreshLights = true;
          _currentMaterialId = material.id;
          refreshMaterial = true;
        }
        if (refreshProgram || camera !== _currentCamera) {
          _gl.uniformMatrix4fv(p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
          if (_logarithmicDepthBuffer) {
            _gl.uniform1f(p_uniforms.logDepthBufFC, 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
          }
          if (camera !== _currentCamera)
            _currentCamera = camera;
          if (material instanceof THREE.ShaderMaterial || material instanceof THREE.MeshPhongMaterial || material.envMap) {
            if (p_uniforms.cameraPosition !== null) {
              _vector3.setFromMatrixPosition(camera.matrixWorld);
              _gl.uniform3f(p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z);
            }
          }
          if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshBasicMaterial || material instanceof THREE.ShaderMaterial || material.skinning) {
            if (p_uniforms.viewMatrix !== null) {
              _gl.uniformMatrix4fv(p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);
            }
          }
        }
        if (material.skinning) {
          if (object.bindMatrix && p_uniforms.bindMatrix !== null) {
            _gl.uniformMatrix4fv(p_uniforms.bindMatrix, false, object.bindMatrix.elements);
          }
          if (object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null) {
            _gl.uniformMatrix4fv(p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements);
          }
          if (_supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture) {
            if (p_uniforms.boneTexture !== null) {
              var textureUnit = getTextureUnit();
              _gl.uniform1i(p_uniforms.boneTexture, textureUnit);
              _this.setTexture(object.skeleton.boneTexture, textureUnit);
            }
            if (p_uniforms.boneTextureWidth !== null) {
              _gl.uniform1i(p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth);
            }
            if (p_uniforms.boneTextureHeight !== null) {
              _gl.uniform1i(p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight);
            }
          } else if (object.skeleton && object.skeleton.boneMatrices) {
            if (p_uniforms.boneGlobalMatrices !== null) {
              _gl.uniformMatrix4fv(p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices);
            }
          }
        }
        if (refreshMaterial) {
          if (fog && material.fog) {
            refreshUniformsFog(m_uniforms, fog);
          }
          if (material instanceof THREE.MeshPhongMaterial || material instanceof THREE.MeshLambertMaterial || material.lights) {
            if (_lightsNeedUpdate) {
              refreshLights = true;
              setupLights(lights);
              _lightsNeedUpdate = false;
            }
            if (refreshLights) {
              refreshUniformsLights(m_uniforms, _lights);
              markUniformsLightsNeedsUpdate(m_uniforms, true);
            } else {
              markUniformsLightsNeedsUpdate(m_uniforms, false);
            }
          }
          if (material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial) {
            refreshUniformsCommon(m_uniforms, material);
          }
          if (material instanceof THREE.LineBasicMaterial) {
            refreshUniformsLine(m_uniforms, material);
          } else if (material instanceof THREE.LineDashedMaterial) {
            refreshUniformsLine(m_uniforms, material);
            refreshUniformsDash(m_uniforms, material);
          } else if (material instanceof THREE.PointCloudMaterial) {
            refreshUniformsParticle(m_uniforms, material);
          } else if (material instanceof THREE.MeshPhongMaterial) {
            refreshUniformsPhong(m_uniforms, material);
          } else if (material instanceof THREE.MeshLambertMaterial) {
            refreshUniformsLambert(m_uniforms, material);
          } else if (material instanceof THREE.MeshDepthMaterial) {
            m_uniforms.mNear.value = camera.near;
            m_uniforms.mFar.value = camera.far;
            m_uniforms.opacity.value = material.opacity;
          } else if (material instanceof THREE.MeshNormalMaterial) {
            m_uniforms.opacity.value = material.opacity;
          }
          if (object.receiveShadow && !material._shadowPass) {
            refreshUniformsShadow(m_uniforms, lights);
          }
          loadUniformsGeneric(material.uniformsList);
        }
        loadUniformsMatrices(p_uniforms, object);
        if (p_uniforms.modelMatrix !== null) {
          _gl.uniformMatrix4fv(p_uniforms.modelMatrix, false, object.matrixWorld.elements);
        }
        return program;
      }
      function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        uniforms.diffuse.value = material.color;
        uniforms.map.value = material.map;
        uniforms.lightMap.value = material.lightMap;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;
        if (material.bumpMap) {
          uniforms.bumpMap.value = material.bumpMap;
          uniforms.bumpScale.value = material.bumpScale;
        }
        if (material.normalMap) {
          uniforms.normalMap.value = material.normalMap;
          uniforms.normalScale.value.copy(material.normalScale);
        }
        var uvScaleMap;
        if (material.map) {
          uvScaleMap = material.map;
        } else if (material.specularMap) {
          uvScaleMap = material.specularMap;
        } else if (material.normalMap) {
          uvScaleMap = material.normalMap;
        } else if (material.bumpMap) {
          uvScaleMap = material.bumpMap;
        } else if (material.alphaMap) {
          uvScaleMap = material.alphaMap;
        }
        if (uvScaleMap !== undefined) {
          var offset = uvScaleMap.offset;
          var repeat = uvScaleMap.repeat;
          uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
        uniforms.envMap.value = material.envMap;
        uniforms.flipEnvMap.value = (material.envMap instanceof THREE.WebGLRenderTargetCube) ? 1 : -1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;
      }
      function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value = material.color;
        uniforms.opacity.value = material.opacity;
      }
      function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
      }
      function refreshUniformsParticle(uniforms, material) {
        uniforms.psColor.value = material.color;
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size;
        uniforms.scale.value = _canvas.height / 2.0;
        uniforms.map.value = material.map;
        if (material.map !== null) {
          var offset = material.map.offset;
          var repeat = material.map.repeat;
          uniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);
        }
      }
      function refreshUniformsFog(uniforms, fog) {
        uniforms.fogColor.value = fog.color;
        if (fog instanceof THREE.Fog) {
          uniforms.fogNear.value = fog.near;
          uniforms.fogFar.value = fog.far;
        } else if (fog instanceof THREE.FogExp2) {
          uniforms.fogDensity.value = fog.density;
        }
      }
      function refreshUniformsPhong(uniforms, material) {
        uniforms.shininess.value = material.shininess;
        uniforms.emissive.value = material.emissive;
        uniforms.specular.value = material.specular;
        if (material.wrapAround) {
          uniforms.wrapRGB.value.copy(material.wrapRGB);
        }
      }
      function refreshUniformsLambert(uniforms, material) {
        uniforms.emissive.value = material.emissive;
        if (material.wrapAround) {
          uniforms.wrapRGB.value.copy(material.wrapRGB);
        }
      }
      function refreshUniformsLights(uniforms, lights) {
        uniforms.ambientLightColor.value = lights.ambient;
        uniforms.directionalLightColor.value = lights.directional.colors;
        uniforms.directionalLightDirection.value = lights.directional.positions;
        uniforms.pointLightColor.value = lights.point.colors;
        uniforms.pointLightPosition.value = lights.point.positions;
        uniforms.pointLightDistance.value = lights.point.distances;
        uniforms.pointLightDecay.value = lights.point.decays;
        uniforms.spotLightColor.value = lights.spot.colors;
        uniforms.spotLightPosition.value = lights.spot.positions;
        uniforms.spotLightDistance.value = lights.spot.distances;
        uniforms.spotLightDirection.value = lights.spot.directions;
        uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
        uniforms.spotLightExponent.value = lights.spot.exponents;
        uniforms.spotLightDecay.value = lights.spot.decays;
        uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
        uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
        uniforms.hemisphereLightDirection.value = lights.hemi.positions;
      }
      function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.directionalLightColor.needsUpdate = value;
        uniforms.directionalLightDirection.needsUpdate = value;
        uniforms.pointLightColor.needsUpdate = value;
        uniforms.pointLightPosition.needsUpdate = value;
        uniforms.pointLightDistance.needsUpdate = value;
        uniforms.pointLightDecay.needsUpdate = value;
        uniforms.spotLightColor.needsUpdate = value;
        uniforms.spotLightPosition.needsUpdate = value;
        uniforms.spotLightDistance.needsUpdate = value;
        uniforms.spotLightDirection.needsUpdate = value;
        uniforms.spotLightAngleCos.needsUpdate = value;
        uniforms.spotLightExponent.needsUpdate = value;
        uniforms.spotLightDecay.needsUpdate = value;
        uniforms.hemisphereLightSkyColor.needsUpdate = value;
        uniforms.hemisphereLightGroundColor.needsUpdate = value;
        uniforms.hemisphereLightDirection.needsUpdate = value;
      }
      function refreshUniformsShadow(uniforms, lights) {
        if (uniforms.shadowMatrix) {
          var j = 0;
          for (var i = 0,
              il = lights.length; i < il; i++) {
            var light = lights[i];
            if (!light.castShadow)
              continue;
            if (light instanceof THREE.SpotLight || (light instanceof THREE.DirectionalLight && !light.shadowCascade)) {
              uniforms.shadowMap.value[j] = light.shadowMap;
              uniforms.shadowMapSize.value[j] = light.shadowMapSize;
              uniforms.shadowMatrix.value[j] = light.shadowMatrix;
              uniforms.shadowDarkness.value[j] = light.shadowDarkness;
              uniforms.shadowBias.value[j] = light.shadowBias;
              j++;
            }
          }
        }
      }
      function loadUniformsMatrices(uniforms, object) {
        _gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, object._modelViewMatrix.elements);
        if (uniforms.normalMatrix) {
          _gl.uniformMatrix3fv(uniforms.normalMatrix, false, object._normalMatrix.elements);
        }
      }
      function getTextureUnit() {
        var textureUnit = _usedTextureUnits;
        if (textureUnit >= _maxTextures) {
          THREE.warn('WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures);
        }
        _usedTextureUnits += 1;
        return textureUnit;
      }
      function loadUniformsGeneric(uniforms) {
        var texture,
            textureUnit,
            offset;
        for (var j = 0,
            jl = uniforms.length; j < jl; j++) {
          var uniform = uniforms[j][0];
          if (uniform.needsUpdate === false)
            continue;
          var type = uniform.type;
          var value = uniform.value;
          var location = uniforms[j][1];
          switch (type) {
            case '1i':
              _gl.uniform1i(location, value);
              break;
            case '1f':
              _gl.uniform1f(location, value);
              break;
            case '2f':
              _gl.uniform2f(location, value[0], value[1]);
              break;
            case '3f':
              _gl.uniform3f(location, value[0], value[1], value[2]);
              break;
            case '4f':
              _gl.uniform4f(location, value[0], value[1], value[2], value[3]);
              break;
            case '1iv':
              _gl.uniform1iv(location, value);
              break;
            case '3iv':
              _gl.uniform3iv(location, value);
              break;
            case '1fv':
              _gl.uniform1fv(location, value);
              break;
            case '2fv':
              _gl.uniform2fv(location, value);
              break;
            case '3fv':
              _gl.uniform3fv(location, value);
              break;
            case '4fv':
              _gl.uniform4fv(location, value);
              break;
            case 'Matrix3fv':
              _gl.uniformMatrix3fv(location, false, value);
              break;
            case 'Matrix4fv':
              _gl.uniformMatrix4fv(location, false, value);
              break;
            case 'i':
              _gl.uniform1i(location, value);
              break;
            case 'f':
              _gl.uniform1f(location, value);
              break;
            case 'v2':
              _gl.uniform2f(location, value.x, value.y);
              break;
            case 'v3':
              _gl.uniform3f(location, value.x, value.y, value.z);
              break;
            case 'v4':
              _gl.uniform4f(location, value.x, value.y, value.z, value.w);
              break;
            case 'c':
              _gl.uniform3f(location, value.r, value.g, value.b);
              break;
            case 'iv1':
              _gl.uniform1iv(location, value);
              break;
            case 'iv':
              _gl.uniform3iv(location, value);
              break;
            case 'fv1':
              _gl.uniform1fv(location, value);
              break;
            case 'fv':
              _gl.uniform3fv(location, value);
              break;
            case 'v2v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(2 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                offset = i * 2;
                uniform._array[offset] = value[i].x;
                uniform._array[offset + 1] = value[i].y;
              }
              _gl.uniform2fv(location, uniform._array);
              break;
            case 'v3v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(3 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                offset = i * 3;
                uniform._array[offset] = value[i].x;
                uniform._array[offset + 1] = value[i].y;
                uniform._array[offset + 2] = value[i].z;
              }
              _gl.uniform3fv(location, uniform._array);
              break;
            case 'v4v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(4 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                offset = i * 4;
                uniform._array[offset] = value[i].x;
                uniform._array[offset + 1] = value[i].y;
                uniform._array[offset + 2] = value[i].z;
                uniform._array[offset + 3] = value[i].w;
              }
              _gl.uniform4fv(location, uniform._array);
              break;
            case 'm3':
              _gl.uniformMatrix3fv(location, false, value.elements);
              break;
            case 'm3v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(9 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                value[i].flattenToArrayOffset(uniform._array, i * 9);
              }
              _gl.uniformMatrix3fv(location, false, uniform._array);
              break;
            case 'm4':
              _gl.uniformMatrix4fv(location, false, value.elements);
              break;
            case 'm4v':
              if (uniform._array === undefined) {
                uniform._array = new Float32Array(16 * value.length);
              }
              for (var i = 0,
                  il = value.length; i < il; i++) {
                value[i].flattenToArrayOffset(uniform._array, i * 16);
              }
              _gl.uniformMatrix4fv(location, false, uniform._array);
              break;
            case 't':
              texture = value;
              textureUnit = getTextureUnit();
              _gl.uniform1i(location, textureUnit);
              if (!texture)
                continue;
              if (texture instanceof THREE.CubeTexture || (texture.image instanceof Array && texture.image.length === 6)) {
                setCubeTexture(texture, textureUnit);
              } else if (texture instanceof THREE.WebGLRenderTargetCube) {
                setCubeTextureDynamic(texture, textureUnit);
              } else {
                _this.setTexture(texture, textureUnit);
              }
              break;
            case 'tv':
              if (uniform._array === undefined) {
                uniform._array = [];
              }
              for (var i = 0,
                  il = uniform.value.length; i < il; i++) {
                uniform._array[i] = getTextureUnit();
              }
              _gl.uniform1iv(location, uniform._array);
              for (var i = 0,
                  il = uniform.value.length; i < il; i++) {
                texture = uniform.value[i];
                textureUnit = uniform._array[i];
                if (!texture)
                  continue;
                _this.setTexture(texture, textureUnit);
              }
              break;
            default:
              THREE.warn('THREE.WebGLRenderer: Unknown uniform type: ' + type);
          }
        }
      }
      function setupMatrices(object, camera) {
        object._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object._normalMatrix.getNormalMatrix(object._modelViewMatrix);
      }
      function setColorLinear(array, offset, color, intensity) {
        array[offset] = color.r * intensity;
        array[offset + 1] = color.g * intensity;
        array[offset + 2] = color.b * intensity;
      }
      function setupLights(lights) {
        var l,
            ll,
            light,
            r = 0,
            g = 0,
            b = 0,
            color,
            skyColor,
            groundColor,
            intensity,
            distance,
            zlights = _lights,
            dirColors = zlights.directional.colors,
            dirPositions = zlights.directional.positions,
            pointColors = zlights.point.colors,
            pointPositions = zlights.point.positions,
            pointDistances = zlights.point.distances,
            pointDecays = zlights.point.decays,
            spotColors = zlights.spot.colors,
            spotPositions = zlights.spot.positions,
            spotDistances = zlights.spot.distances,
            spotDirections = zlights.spot.directions,
            spotAnglesCos = zlights.spot.anglesCos,
            spotExponents = zlights.spot.exponents,
            spotDecays = zlights.spot.decays,
            hemiSkyColors = zlights.hemi.skyColors,
            hemiGroundColors = zlights.hemi.groundColors,
            hemiPositions = zlights.hemi.positions,
            dirLength = 0,
            pointLength = 0,
            spotLength = 0,
            hemiLength = 0,
            dirCount = 0,
            pointCount = 0,
            spotCount = 0,
            hemiCount = 0,
            dirOffset = 0,
            pointOffset = 0,
            spotOffset = 0,
            hemiOffset = 0;
        for (l = 0, ll = lights.length; l < ll; l++) {
          light = lights[l];
          if (light.onlyShadow)
            continue;
          color = light.color;
          intensity = light.intensity;
          distance = light.distance;
          if (light instanceof THREE.AmbientLight) {
            if (!light.visible)
              continue;
            r += color.r;
            g += color.g;
            b += color.b;
          } else if (light instanceof THREE.DirectionalLight) {
            dirCount += 1;
            if (!light.visible)
              continue;
            _direction.setFromMatrixPosition(light.matrixWorld);
            _vector3.setFromMatrixPosition(light.target.matrixWorld);
            _direction.sub(_vector3);
            _direction.normalize();
            dirOffset = dirLength * 3;
            dirPositions[dirOffset] = _direction.x;
            dirPositions[dirOffset + 1] = _direction.y;
            dirPositions[dirOffset + 2] = _direction.z;
            setColorLinear(dirColors, dirOffset, color, intensity);
            dirLength += 1;
          } else if (light instanceof THREE.PointLight) {
            pointCount += 1;
            if (!light.visible)
              continue;
            pointOffset = pointLength * 3;
            setColorLinear(pointColors, pointOffset, color, intensity);
            _vector3.setFromMatrixPosition(light.matrixWorld);
            pointPositions[pointOffset] = _vector3.x;
            pointPositions[pointOffset + 1] = _vector3.y;
            pointPositions[pointOffset + 2] = _vector3.z;
            pointDistances[pointLength] = distance;
            pointDecays[pointLength] = (light.distance === 0) ? 0.0 : light.decay;
            pointLength += 1;
          } else if (light instanceof THREE.SpotLight) {
            spotCount += 1;
            if (!light.visible)
              continue;
            spotOffset = spotLength * 3;
            setColorLinear(spotColors, spotOffset, color, intensity);
            _direction.setFromMatrixPosition(light.matrixWorld);
            spotPositions[spotOffset] = _direction.x;
            spotPositions[spotOffset + 1] = _direction.y;
            spotPositions[spotOffset + 2] = _direction.z;
            spotDistances[spotLength] = distance;
            _vector3.setFromMatrixPosition(light.target.matrixWorld);
            _direction.sub(_vector3);
            _direction.normalize();
            spotDirections[spotOffset] = _direction.x;
            spotDirections[spotOffset + 1] = _direction.y;
            spotDirections[spotOffset + 2] = _direction.z;
            spotAnglesCos[spotLength] = Math.cos(light.angle);
            spotExponents[spotLength] = light.exponent;
            spotDecays[spotLength] = (light.distance === 0) ? 0.0 : light.decay;
            spotLength += 1;
          } else if (light instanceof THREE.HemisphereLight) {
            hemiCount += 1;
            if (!light.visible)
              continue;
            _direction.setFromMatrixPosition(light.matrixWorld);
            _direction.normalize();
            hemiOffset = hemiLength * 3;
            hemiPositions[hemiOffset] = _direction.x;
            hemiPositions[hemiOffset + 1] = _direction.y;
            hemiPositions[hemiOffset + 2] = _direction.z;
            skyColor = light.color;
            groundColor = light.groundColor;
            setColorLinear(hemiSkyColors, hemiOffset, skyColor, intensity);
            setColorLinear(hemiGroundColors, hemiOffset, groundColor, intensity);
            hemiLength += 1;
          }
        }
        for (l = dirLength * 3, ll = Math.max(dirColors.length, dirCount * 3); l < ll; l++)
          dirColors[l] = 0.0;
        for (l = pointLength * 3, ll = Math.max(pointColors.length, pointCount * 3); l < ll; l++)
          pointColors[l] = 0.0;
        for (l = spotLength * 3, ll = Math.max(spotColors.length, spotCount * 3); l < ll; l++)
          spotColors[l] = 0.0;
        for (l = hemiLength * 3, ll = Math.max(hemiSkyColors.length, hemiCount * 3); l < ll; l++)
          hemiSkyColors[l] = 0.0;
        for (l = hemiLength * 3, ll = Math.max(hemiGroundColors.length, hemiCount * 3); l < ll; l++)
          hemiGroundColors[l] = 0.0;
        zlights.directional.length = dirLength;
        zlights.point.length = pointLength;
        zlights.spot.length = spotLength;
        zlights.hemi.length = hemiLength;
        zlights.ambient[0] = r;
        zlights.ambient[1] = g;
        zlights.ambient[2] = b;
      }
      this.setFaceCulling = function(cullFace, frontFaceDirection) {
        if (cullFace === THREE.CullFaceNone) {
          _gl.disable(_gl.CULL_FACE);
        } else {
          if (frontFaceDirection === THREE.FrontFaceDirectionCW) {
            _gl.frontFace(_gl.CW);
          } else {
            _gl.frontFace(_gl.CCW);
          }
          if (cullFace === THREE.CullFaceBack) {
            _gl.cullFace(_gl.BACK);
          } else if (cullFace === THREE.CullFaceFront) {
            _gl.cullFace(_gl.FRONT);
          } else {
            _gl.cullFace(_gl.FRONT_AND_BACK);
          }
          _gl.enable(_gl.CULL_FACE);
        }
      };
      this.setMaterialFaces = function(material) {
        state.setDoubleSided(material.side === THREE.DoubleSide);
        state.setFlipSided(material.side === THREE.BackSide);
      };
      function setTextureParameters(textureType, texture, isImagePowerOfTwo) {
        var extension;
        if (isImagePowerOfTwo) {
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL(texture.wrapS));
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL(texture.wrapT));
          _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL(texture.magFilter));
          _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL(texture.minFilter));
        } else {
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
          _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
          if (texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping) {
            THREE.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )');
          }
          _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
          _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
          if (texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter) {
            THREE.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )');
          }
        }
        extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType) {
          if (texture.anisotropy > 1 || texture.__currentAnisotropy) {
            _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, _this.getMaxAnisotropy()));
            texture.__currentAnisotropy = texture.anisotropy;
          }
        }
      }
      this.uploadTexture = function(texture) {
        if (texture.__webglInit === undefined) {
          texture.__webglInit = true;
          texture.addEventListener('dispose', onTextureDispose);
          texture.__webglTexture = _gl.createTexture();
          _this.info.memory.textures++;
        }
        _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        texture.image = clampToMaxSize(texture.image, _maxTextureSize);
        var image = texture.image,
            isImagePowerOfTwo = THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height),
            glFormat = paramThreeToGL(texture.format),
            glType = paramThreeToGL(texture.type);
        setTextureParameters(_gl.TEXTURE_2D, texture, isImagePowerOfTwo);
        var mipmap,
            mipmaps = texture.mipmaps;
        if (texture instanceof THREE.DataTexture) {
          if (mipmaps.length > 0 && isImagePowerOfTwo) {
            for (var i = 0,
                il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            texture.generateMipmaps = false;
          } else {
            _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        } else if (texture instanceof THREE.CompressedTexture) {
          for (var i = 0,
              il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
              if (getCompressedTextureFormats().indexOf(glFormat) > -1) {
                _gl.compressedTexImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        } else {
          if (mipmaps.length > 0 && isImagePowerOfTwo) {
            for (var i = 0,
                il = mipmaps.length; i < il; i++) {
              mipmap = mipmaps[i];
              _gl.texImage2D(_gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
          } else {
            _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image);
          }
        }
        if (texture.generateMipmaps && isImagePowerOfTwo)
          _gl.generateMipmap(_gl.TEXTURE_2D);
        texture.needsUpdate = false;
        if (texture.onUpdate)
          texture.onUpdate();
      };
      this.setTexture = function(texture, slot) {
        _gl.activeTexture(_gl.TEXTURE0 + slot);
        if (texture.needsUpdate) {
          _this.uploadTexture(texture);
        } else {
          _gl.bindTexture(_gl.TEXTURE_2D, texture.__webglTexture);
        }
      };
      function clampToMaxSize(image, maxSize) {
        if (image.width > maxSize || image.height > maxSize) {
          var scale = maxSize / Math.max(image.width, image.height);
          var canvas = document.createElement('canvas');
          canvas.width = Math.floor(image.width * scale);
          canvas.height = Math.floor(image.height * scale);
          var context = canvas.getContext('2d');
          context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
          THREE.warn('THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image);
          return canvas;
        }
        return image;
      }
      function setCubeTexture(texture, slot) {
        if (texture.image.length === 6) {
          if (texture.needsUpdate) {
            if (!texture.image.__webglTextureCube) {
              texture.addEventListener('dispose', onTextureDispose);
              texture.image.__webglTextureCube = _gl.createTexture();
              _this.info.memory.textures++;
            }
            _gl.activeTexture(_gl.TEXTURE0 + slot);
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            var isCompressed = texture instanceof THREE.CompressedTexture;
            var isDataTexture = texture.image[0] instanceof THREE.DataTexture;
            var cubeImage = [];
            for (var i = 0; i < 6; i++) {
              if (_this.autoScaleCubemaps && !isCompressed && !isDataTexture) {
                cubeImage[i] = clampToMaxSize(texture.image[i], _maxCubemapSize);
              } else {
                cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
              }
            }
            var image = cubeImage[0],
                isImagePowerOfTwo = THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height),
                glFormat = paramThreeToGL(texture.format),
                glType = paramThreeToGL(texture.type);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo);
            for (var i = 0; i < 6; i++) {
              if (!isCompressed) {
                if (isDataTexture) {
                  _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                } else {
                  _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[i]);
                }
              } else {
                var mipmap,
                    mipmaps = cubeImage[i].mipmaps;
                for (var j = 0,
                    jl = mipmaps.length; j < jl; j++) {
                  mipmap = mipmaps[j];
                  if (texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat) {
                    if (getCompressedTextureFormats().indexOf(glFormat) > -1) {
                      _gl.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    } else {
                      THREE.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()");
                    }
                  } else {
                    _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                  }
                }
              }
            }
            if (texture.generateMipmaps && isImagePowerOfTwo) {
              _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
            }
            texture.needsUpdate = false;
            if (texture.onUpdate)
              texture.onUpdate();
          } else {
            _gl.activeTexture(_gl.TEXTURE0 + slot);
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube);
          }
        }
      }
      function setCubeTextureDynamic(texture, slot) {
        _gl.activeTexture(_gl.TEXTURE0 + slot);
        _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, texture.__webglTexture);
      }
      function setupFrameBuffer(framebuffer, renderTarget, textureTarget) {
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0);
      }
      function setupRenderBuffer(renderbuffer, renderTarget) {
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height);
        }
      }
      this.setRenderTarget = function(renderTarget) {
        var isCube = (renderTarget instanceof THREE.WebGLRenderTargetCube);
        if (renderTarget && renderTarget.__webglFramebuffer === undefined) {
          if (renderTarget.depthBuffer === undefined)
            renderTarget.depthBuffer = true;
          if (renderTarget.stencilBuffer === undefined)
            renderTarget.stencilBuffer = true;
          renderTarget.addEventListener('dispose', onRenderTargetDispose);
          renderTarget.__webglTexture = _gl.createTexture();
          _this.info.memory.textures++;
          var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo(renderTarget.width) && THREE.Math.isPowerOfTwo(renderTarget.height),
              glFormat = paramThreeToGL(renderTarget.format),
              glType = paramThreeToGL(renderTarget.type);
          if (isCube) {
            renderTarget.__webglFramebuffer = [];
            renderTarget.__webglRenderbuffer = [];
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo);
            for (var i = 0; i < 6; i++) {
              renderTarget.__webglFramebuffer[i] = _gl.createFramebuffer();
              renderTarget.__webglRenderbuffer[i] = _gl.createRenderbuffer();
              _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
              setupFrameBuffer(renderTarget.__webglFramebuffer[i], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
              setupRenderBuffer(renderTarget.__webglRenderbuffer[i], renderTarget);
            }
            if (isTargetPowerOfTwo)
              _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
          } else {
            renderTarget.__webglFramebuffer = _gl.createFramebuffer();
            if (renderTarget.shareDepthFrom) {
              renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;
            } else {
              renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();
            }
            _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);
            setTextureParameters(_gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo);
            _gl.texImage2D(_gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
            setupFrameBuffer(renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D);
            if (renderTarget.shareDepthFrom) {
              if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer);
              } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer);
              }
            } else {
              setupRenderBuffer(renderTarget.__webglRenderbuffer, renderTarget);
            }
            if (isTargetPowerOfTwo)
              _gl.generateMipmap(_gl.TEXTURE_2D);
          }
          if (isCube) {
            _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
          } else {
            _gl.bindTexture(_gl.TEXTURE_2D, null);
          }
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
        }
        var framebuffer,
            width,
            height,
            vx,
            vy;
        if (renderTarget) {
          if (isCube) {
            framebuffer = renderTarget.__webglFramebuffer[renderTarget.activeCubeFace];
          } else {
            framebuffer = renderTarget.__webglFramebuffer;
          }
          width = renderTarget.width;
          height = renderTarget.height;
          vx = 0;
          vy = 0;
        } else {
          framebuffer = null;
          width = _viewportWidth;
          height = _viewportHeight;
          vx = _viewportX;
          vy = _viewportY;
        }
        if (framebuffer !== _currentFramebuffer) {
          _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          _gl.viewport(vx, vy, width, height);
          _currentFramebuffer = framebuffer;
        }
        _currentWidth = width;
        _currentHeight = height;
      };
      this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer) {
        if (!(renderTarget instanceof THREE.WebGLRenderTarget)) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
          return;
        }
        if (renderTarget.__webglFramebuffer) {
          if (renderTarget.format !== THREE.RGBAFormat) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.');
            return;
          }
          var restore = false;
          if (renderTarget.__webglFramebuffer !== _currentFramebuffer) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTarget.__webglFramebuffer);
            restore = true;
          }
          if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
            _gl.readPixels(x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer);
          } else {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
          }
          if (restore) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
          }
        }
      };
      function updateRenderTargetMipmap(renderTarget) {
        if (renderTarget instanceof THREE.WebGLRenderTargetCube) {
          _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture);
          _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
          _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
        } else {
          _gl.bindTexture(_gl.TEXTURE_2D, renderTarget.__webglTexture);
          _gl.generateMipmap(_gl.TEXTURE_2D);
          _gl.bindTexture(_gl.TEXTURE_2D, null);
        }
      }
      function filterFallback(f) {
        if (f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter) {
          return _gl.NEAREST;
        }
        return _gl.LINEAR;
      }
      function paramThreeToGL(p) {
        var extension;
        if (p === THREE.RepeatWrapping)
          return _gl.REPEAT;
        if (p === THREE.ClampToEdgeWrapping)
          return _gl.CLAMP_TO_EDGE;
        if (p === THREE.MirroredRepeatWrapping)
          return _gl.MIRRORED_REPEAT;
        if (p === THREE.NearestFilter)
          return _gl.NEAREST;
        if (p === THREE.NearestMipMapNearestFilter)
          return _gl.NEAREST_MIPMAP_NEAREST;
        if (p === THREE.NearestMipMapLinearFilter)
          return _gl.NEAREST_MIPMAP_LINEAR;
        if (p === THREE.LinearFilter)
          return _gl.LINEAR;
        if (p === THREE.LinearMipMapNearestFilter)
          return _gl.LINEAR_MIPMAP_NEAREST;
        if (p === THREE.LinearMipMapLinearFilter)
          return _gl.LINEAR_MIPMAP_LINEAR;
        if (p === THREE.UnsignedByteType)
          return _gl.UNSIGNED_BYTE;
        if (p === THREE.UnsignedShort4444Type)
          return _gl.UNSIGNED_SHORT_4_4_4_4;
        if (p === THREE.UnsignedShort5551Type)
          return _gl.UNSIGNED_SHORT_5_5_5_1;
        if (p === THREE.UnsignedShort565Type)
          return _gl.UNSIGNED_SHORT_5_6_5;
        if (p === THREE.ByteType)
          return _gl.BYTE;
        if (p === THREE.ShortType)
          return _gl.SHORT;
        if (p === THREE.UnsignedShortType)
          return _gl.UNSIGNED_SHORT;
        if (p === THREE.IntType)
          return _gl.INT;
        if (p === THREE.UnsignedIntType)
          return _gl.UNSIGNED_INT;
        if (p === THREE.FloatType)
          return _gl.FLOAT;
        extension = extensions.get('OES_texture_half_float');
        if (extension !== null) {
          if (p === THREE.HalfFloatType)
            return extension.HALF_FLOAT_OES;
        }
        if (p === THREE.AlphaFormat)
          return _gl.ALPHA;
        if (p === THREE.RGBFormat)
          return _gl.RGB;
        if (p === THREE.RGBAFormat)
          return _gl.RGBA;
        if (p === THREE.LuminanceFormat)
          return _gl.LUMINANCE;
        if (p === THREE.LuminanceAlphaFormat)
          return _gl.LUMINANCE_ALPHA;
        if (p === THREE.AddEquation)
          return _gl.FUNC_ADD;
        if (p === THREE.SubtractEquation)
          return _gl.FUNC_SUBTRACT;
        if (p === THREE.ReverseSubtractEquation)
          return _gl.FUNC_REVERSE_SUBTRACT;
        if (p === THREE.ZeroFactor)
          return _gl.ZERO;
        if (p === THREE.OneFactor)
          return _gl.ONE;
        if (p === THREE.SrcColorFactor)
          return _gl.SRC_COLOR;
        if (p === THREE.OneMinusSrcColorFactor)
          return _gl.ONE_MINUS_SRC_COLOR;
        if (p === THREE.SrcAlphaFactor)
          return _gl.SRC_ALPHA;
        if (p === THREE.OneMinusSrcAlphaFactor)
          return _gl.ONE_MINUS_SRC_ALPHA;
        if (p === THREE.DstAlphaFactor)
          return _gl.DST_ALPHA;
        if (p === THREE.OneMinusDstAlphaFactor)
          return _gl.ONE_MINUS_DST_ALPHA;
        if (p === THREE.DstColorFactor)
          return _gl.DST_COLOR;
        if (p === THREE.OneMinusDstColorFactor)
          return _gl.ONE_MINUS_DST_COLOR;
        if (p === THREE.SrcAlphaSaturateFactor)
          return _gl.SRC_ALPHA_SATURATE;
        extension = extensions.get('WEBGL_compressed_texture_s3tc');
        if (extension !== null) {
          if (p === THREE.RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === THREE.RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === THREE.RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === THREE.RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        extension = extensions.get('WEBGL_compressed_texture_pvrtc');
        if (extension !== null) {
          if (p === THREE.RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p === THREE.RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p === THREE.RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p === THREE.RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        extension = extensions.get('EXT_blend_minmax');
        if (extension !== null) {
          if (p === THREE.MinEquation)
            return extension.MIN_EXT;
          if (p === THREE.MaxEquation)
            return extension.MAX_EXT;
        }
        return 0;
      }
      function allocateBones(object) {
        if (_supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture) {
          return 1024;
        } else {
          var nVertexUniforms = _gl.getParameter(_gl.MAX_VERTEX_UNIFORM_VECTORS);
          var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
          var maxBones = nVertexMatrices;
          if (object !== undefined && object instanceof THREE.SkinnedMesh) {
            maxBones = Math.min(object.skeleton.bones.length, maxBones);
            if (maxBones < object.skeleton.bones.length) {
              THREE.warn('WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)');
            }
          }
          return maxBones;
        }
      }
      function allocateLights(lights) {
        var dirLights = 0;
        var pointLights = 0;
        var spotLights = 0;
        var hemiLights = 0;
        for (var l = 0,
            ll = lights.length; l < ll; l++) {
          var light = lights[l];
          if (light.onlyShadow || light.visible === false)
            continue;
          if (light instanceof THREE.DirectionalLight)
            dirLights++;
          if (light instanceof THREE.PointLight)
            pointLights++;
          if (light instanceof THREE.SpotLight)
            spotLights++;
          if (light instanceof THREE.HemisphereLight)
            hemiLights++;
        }
        return {
          'directional': dirLights,
          'point': pointLights,
          'spot': spotLights,
          'hemi': hemiLights
        };
      }
      function allocateShadows(lights) {
        var maxShadows = 0;
        for (var l = 0,
            ll = lights.length; l < ll; l++) {
          var light = lights[l];
          if (!light.castShadow)
            continue;
          if (light instanceof THREE.SpotLight)
            maxShadows++;
          if (light instanceof THREE.DirectionalLight && !light.shadowCascade)
            maxShadows++;
        }
        return maxShadows;
      }
      this.initMaterial = function() {
        THREE.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
      };
      this.addPrePlugin = function() {
        THREE.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
      };
      this.addPostPlugin = function() {
        THREE.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
      };
      this.updateShadowMap = function() {
        THREE.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
      };
    };
    THREE.WebGLRenderTarget = function(width, height, options) {
      this.width = width;
      this.height = height;
      options = options || {};
      this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
      this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;
      this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
      this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;
      this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;
      this.offset = new THREE.Vector2(0, 0);
      this.repeat = new THREE.Vector2(1, 1);
      this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
      this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;
      this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
      this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
      this.generateMipmaps = true;
      this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;
    };
    THREE.WebGLRenderTarget.prototype = {
      constructor: THREE.WebGLRenderTarget,
      setSize: function(width, height) {
        this.width = width;
        this.height = height;
      },
      clone: function() {
        var tmp = new THREE.WebGLRenderTarget(this.width, this.height);
        tmp.wrapS = this.wrapS;
        tmp.wrapT = this.wrapT;
        tmp.magFilter = this.magFilter;
        tmp.minFilter = this.minFilter;
        tmp.anisotropy = this.anisotropy;
        tmp.offset.copy(this.offset);
        tmp.repeat.copy(this.repeat);
        tmp.format = this.format;
        tmp.type = this.type;
        tmp.depthBuffer = this.depthBuffer;
        tmp.stencilBuffer = this.stencilBuffer;
        tmp.generateMipmaps = this.generateMipmaps;
        tmp.shareDepthFrom = this.shareDepthFrom;
        return tmp;
      },
      dispose: function() {
        this.dispatchEvent({type: 'dispose'});
      }
    };
    THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
    THREE.WebGLRenderTargetCube = function(width, height, options) {
      THREE.WebGLRenderTarget.call(this, width, height, options);
      this.activeCubeFace = 0;
    };
    THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
    THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
    THREE.WebGLExtensions = function(gl) {
      var extensions = {};
      this.get = function(name) {
        if (extensions[name] !== undefined) {
          return extensions[name];
        }
        var extension;
        switch (name) {
          case 'EXT_texture_filter_anisotropic':
            extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            break;
          case 'WEBGL_compressed_texture_s3tc':
            extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
            break;
          case 'WEBGL_compressed_texture_pvrtc':
            extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
            break;
          default:
            extension = gl.getExtension(name);
        }
        if (extension === null) {
          THREE.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
        }
        extensions[name] = extension;
        return extension;
      };
    };
    THREE.WebGLProgram = (function() {
      var programIdCount = 0;
      var generateDefines = function(defines) {
        var value,
            chunk,
            chunks = [];
        for (var d in defines) {
          value = defines[d];
          if (value === false)
            continue;
          chunk = '#define ' + d + ' ' + value;
          chunks.push(chunk);
        }
        return chunks.join('\n');
      };
      var cacheUniformLocations = function(gl, program, identifiers) {
        var uniforms = {};
        for (var i = 0,
            l = identifiers.length; i < l; i++) {
          var id = identifiers[i];
          uniforms[id] = gl.getUniformLocation(program, id);
        }
        return uniforms;
      };
      var cacheAttributeLocations = function(gl, program, identifiers) {
        var attributes = {};
        for (var i = 0,
            l = identifiers.length; i < l; i++) {
          var id = identifiers[i];
          attributes[id] = gl.getAttribLocation(program, id);
        }
        return attributes;
      };
      return function(renderer, code, material, parameters) {
        var _this = renderer;
        var _gl = _this.context;
        var defines = material.defines;
        var uniforms = material.__webglShader.uniforms;
        var attributes = material.attributes;
        var vertexShader = material.__webglShader.vertexShader;
        var fragmentShader = material.__webglShader.fragmentShader;
        var index0AttributeName = material.index0AttributeName;
        if (index0AttributeName === undefined && parameters.morphTargets === true) {
          index0AttributeName = 'position';
        }
        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
        if (parameters.shadowMapType === THREE.PCFShadowMap) {
          shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
        } else if (parameters.shadowMapType === THREE.PCFSoftShadowMap) {
          shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
        }
        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
        var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        if (parameters.envMap) {
          switch (material.envMap.mapping) {
            case THREE.CubeReflectionMapping:
            case THREE.CubeRefractionMapping:
              envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
              break;
            case THREE.EquirectangularReflectionMapping:
            case THREE.EquirectangularRefractionMapping:
              envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
              break;
            case THREE.SphericalReflectionMapping:
              envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
              break;
          }
          switch (material.envMap.mapping) {
            case THREE.CubeRefractionMapping:
            case THREE.EquirectangularRefractionMapping:
              envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
              break;
          }
          switch (material.combine) {
            case THREE.MultiplyOperation:
              envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
              break;
            case THREE.MixOperation:
              envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
              break;
            case THREE.AddOperation:
              envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
              break;
          }
        }
        var gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;
        var customDefines = generateDefines(defines);
        var program = _gl.createProgram();
        var prefix_vertex,
            prefix_fragment;
        if (material instanceof THREE.RawShaderMaterial) {
          prefix_vertex = '';
          prefix_fragment = '';
        } else {
          prefix_vertex = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', customDefines, parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', _this.gammaInput ? '#define GAMMA_INPUT' : '', _this.gammaOutput ? '#define GAMMA_OUTPUT' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights, '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights, '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights, '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights, '#define MAX_SHADOWS ' + parameters.maxShadows, '#define MAX_BONES ' + parameters.maxBones, parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals ? '#define USE_MORPHNORMALS' : '', parameters.wrapAround ? '#define WRAP_AROUND' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '', parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', 'attribute vec2 uv2;', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', ''].join('\n');
          prefix_fragment = ['precision ' + parameters.precision + ' float;', 'precision ' + parameters.precision + ' int;', (parameters.bumpMap || parameters.normalMap || parameters.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '', customDefines, '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights, '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights, '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights, '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights, '#define MAX_SHADOWS ' + parameters.maxShadows, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '', _this.gammaInput ? '#define GAMMA_INPUT' : '', _this.gammaOutput ? '#define GAMMA_OUTPUT' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '', (parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.metal ? '#define METAL' : '', parameters.wrapAround ? '#define WRAP_AROUND' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '', parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', ''].join('\n');
        }
        var glVertexShader = new THREE.WebGLShader(_gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader);
        var glFragmentShader = new THREE.WebGLShader(_gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader);
        _gl.attachShader(program, glVertexShader);
        _gl.attachShader(program, glFragmentShader);
        if (index0AttributeName !== undefined) {
          _gl.bindAttribLocation(program, 0, index0AttributeName);
        }
        _gl.linkProgram(program);
        var programLogInfo = _gl.getProgramInfoLog(program);
        if (_gl.getProgramParameter(program, _gl.LINK_STATUS) === false) {
          THREE.error('THREE.WebGLProgram: shader error: ' + _gl.getError(), 'gl.VALIDATE_STATUS', _gl.getProgramParameter(program, _gl.VALIDATE_STATUS), 'gl.getPRogramInfoLog', programLogInfo);
        }
        if (programLogInfo !== '') {
          THREE.warn('THREE.WebGLProgram: gl.getProgramInfoLog()' + programLogInfo);
        }
        _gl.deleteShader(glVertexShader);
        _gl.deleteShader(glFragmentShader);
        var identifiers = ['viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition', 'morphTargetInfluences', 'bindMatrix', 'bindMatrixInverse'];
        if (parameters.useVertexTexture) {
          identifiers.push('boneTexture');
          identifiers.push('boneTextureWidth');
          identifiers.push('boneTextureHeight');
        } else {
          identifiers.push('boneGlobalMatrices');
        }
        if (parameters.logarithmicDepthBuffer) {
          identifiers.push('logDepthBufFC');
        }
        for (var u in uniforms) {
          identifiers.push(u);
        }
        this.uniforms = cacheUniformLocations(_gl, program, identifiers);
        identifiers = ['position', 'normal', 'uv', 'uv2', 'tangent', 'color', 'skinIndex', 'skinWeight', 'lineDistance'];
        for (var i = 0; i < parameters.maxMorphTargets; i++) {
          identifiers.push('morphTarget' + i);
        }
        for (var i = 0; i < parameters.maxMorphNormals; i++) {
          identifiers.push('morphNormal' + i);
        }
        for (var a in attributes) {
          identifiers.push(a);
        }
        this.attributes = cacheAttributeLocations(_gl, program, identifiers);
        this.attributesKeys = Object.keys(this.attributes);
        this.id = programIdCount++;
        this.code = code;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
        return this;
      };
    })();
    THREE.WebGLShader = (function() {
      var addLineNumbers = function(string) {
        var lines = string.split('\n');
        for (var i = 0; i < lines.length; i++) {
          lines[i] = (i + 1) + ': ' + lines[i];
        }
        return lines.join('\n');
      };
      return function(gl, type, string) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, string);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
          THREE.error('THREE.WebGLShader: Shader couldn\'t compile.');
        }
        if (gl.getShaderInfoLog(shader) !== '') {
          THREE.warn('THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog(shader), addLineNumbers(string));
        }
        return shader;
      };
    })();
    THREE.WebGLState = function(gl, paramThreeToGL) {
      var newAttributes = new Uint8Array(16);
      var enabledAttributes = new Uint8Array(16);
      var currentBlending = null;
      var currentBlendEquation = null;
      var currentBlendSrc = null;
      var currentBlendDst = null;
      var currentBlendEquationAlpha = null;
      var currentBlendSrcAlpha = null;
      var currentBlendDstAlpha = null;
      var currentDepthTest = null;
      var currentDepthWrite = null;
      var currentColorWrite = null;
      var currentDoubleSided = null;
      var currentFlipSided = null;
      var currentLineWidth = null;
      var currentPolygonOffset = null;
      var currentPolygonOffsetFactor = null;
      var currentPolygonOffsetUnits = null;
      this.initAttributes = function() {
        for (var i = 0,
            l = newAttributes.length; i < l; i++) {
          newAttributes[i] = 0;
        }
      };
      this.enableAttribute = function(attribute) {
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
          gl.enableVertexAttribArray(attribute);
          enabledAttributes[attribute] = 1;
        }
      };
      this.disableUnusedAttributes = function() {
        for (var i = 0,
            l = enabledAttributes.length; i < l; i++) {
          if (enabledAttributes[i] !== newAttributes[i]) {
            gl.disableVertexAttribArray(i);
            enabledAttributes[i] = 0;
          }
        }
      };
      this.setBlending = function(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha) {
        if (blending !== currentBlending) {
          if (blending === THREE.NoBlending) {
            gl.disable(gl.BLEND);
          } else if (blending === THREE.AdditiveBlending) {
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
          } else if (blending === THREE.SubtractiveBlending) {
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
          } else if (blending === THREE.MultiplyBlending) {
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
          } else if (blending === THREE.CustomBlending) {
            gl.enable(gl.BLEND);
          } else {
            gl.enable(gl.BLEND);
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
          }
          currentBlending = blending;
        }
        if (blending === THREE.CustomBlending) {
          blendEquationAlpha = blendEquationAlpha || blendEquation;
          blendSrcAlpha = blendSrcAlpha || blendSrc;
          blendDstAlpha = blendDstAlpha || blendDst;
          if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(paramThreeToGL(blendEquation), paramThreeToGL(blendEquationAlpha));
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
          }
          if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(paramThreeToGL(blendSrc), paramThreeToGL(blendDst), paramThreeToGL(blendSrcAlpha), paramThreeToGL(blendDstAlpha));
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
          }
        } else {
          currentBlendEquation = null;
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendEquationAlpha = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
        }
      };
      this.setDepthTest = function(depthTest) {
        if (currentDepthTest !== depthTest) {
          if (depthTest) {
            gl.enable(gl.DEPTH_TEST);
          } else {
            gl.disable(gl.DEPTH_TEST);
          }
          currentDepthTest = depthTest;
        }
      };
      this.setDepthWrite = function(depthWrite) {
        if (currentDepthWrite !== depthWrite) {
          gl.depthMask(depthWrite);
          currentDepthWrite = depthWrite;
        }
      };
      this.setColorWrite = function(colorWrite) {
        if (currentColorWrite !== colorWrite) {
          gl.colorMask(colorWrite, colorWrite, colorWrite, colorWrite);
          currentColorWrite = colorWrite;
        }
      };
      this.setDoubleSided = function(doubleSided) {
        if (currentDoubleSided !== doubleSided) {
          if (doubleSided) {
            gl.disable(gl.CULL_FACE);
          } else {
            gl.enable(gl.CULL_FACE);
          }
          currentDoubleSided = doubleSided;
        }
      };
      this.setFlipSided = function(flipSided) {
        if (currentFlipSided !== flipSided) {
          if (flipSided) {
            gl.frontFace(gl.CW);
          } else {
            gl.frontFace(gl.CCW);
          }
          currentFlipSided = flipSided;
        }
      };
      this.setLineWidth = function(width) {
        if (width !== currentLineWidth) {
          gl.lineWidth(width);
          currentLineWidth = width;
        }
      };
      this.setPolygonOffset = function(polygonoffset, factor, units) {
        if (currentPolygonOffset !== polygonoffset) {
          if (polygonoffset) {
            gl.enable(gl.POLYGON_OFFSET_FILL);
          } else {
            gl.disable(gl.POLYGON_OFFSET_FILL);
          }
          currentPolygonOffset = polygonoffset;
        }
        if (polygonoffset && (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units)) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      };
      this.reset = function() {
        for (var i = 0; i < enabledAttributes.length; i++) {
          enabledAttributes[i] = 0;
        }
        currentBlending = null;
        currentDepthTest = null;
        currentDepthWrite = null;
        currentColorWrite = null;
        currentDoubleSided = null;
        currentFlipSided = null;
      };
    };
    THREE.LensFlarePlugin = function(renderer, flares) {
      var gl = renderer.context;
      var vertexBuffer,
          elementBuffer;
      var program,
          attributes,
          uniforms;
      var hasVertexTexture;
      var tempTexture,
          occlusionTexture;
      var init = function() {
        var vertices = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]);
        var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        tempTexture = gl.createTexture();
        occlusionTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tempTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, occlusionTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        hasVertexTexture = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
        var shader;
        if (hasVertexTexture) {
          shader = {
            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
            fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
          };
        } else {
          shader = {
            vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if( renderType == 2 ) {", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
            fragmentShader: ["precision mediump float;", "uniform lowp int renderType;", "uniform sampler2D map;", "uniform sampler2D occlusionMap;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {", "if( renderType == 0 ) {", "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );", "} else if( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;", "visibility = ( 1.0 - visibility / 4.0 );", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
          };
        }
        program = createProgram(shader);
        attributes = {
          vertex: gl.getAttribLocation(program, "position"),
          uv: gl.getAttribLocation(program, "uv")
        };
        uniforms = {
          renderType: gl.getUniformLocation(program, "renderType"),
          map: gl.getUniformLocation(program, "map"),
          occlusionMap: gl.getUniformLocation(program, "occlusionMap"),
          opacity: gl.getUniformLocation(program, "opacity"),
          color: gl.getUniformLocation(program, "color"),
          scale: gl.getUniformLocation(program, "scale"),
          rotation: gl.getUniformLocation(program, "rotation"),
          screenPosition: gl.getUniformLocation(program, "screenPosition")
        };
      };
      this.render = function(scene, camera, viewportWidth, viewportHeight) {
        if (flares.length === 0)
          return;
        var tempPosition = new THREE.Vector3();
        var invAspect = viewportHeight / viewportWidth,
            halfViewportWidth = viewportWidth * 0.5,
            halfViewportHeight = viewportHeight * 0.5;
        var size = 16 / viewportHeight,
            scale = new THREE.Vector2(size * invAspect, size);
        var screenPosition = new THREE.Vector3(1, 1, 0),
            screenPositionPixels = new THREE.Vector2(1, 1);
        if (program === undefined) {
          init();
        }
        gl.useProgram(program);
        gl.enableVertexAttribArray(attributes.vertex);
        gl.enableVertexAttribArray(attributes.uv);
        gl.uniform1i(uniforms.occlusionMap, 0);
        gl.uniform1i(uniforms.map, 1);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.disable(gl.CULL_FACE);
        gl.depthMask(false);
        for (var i = 0,
            l = flares.length; i < l; i++) {
          size = 16 / viewportHeight;
          scale.set(size * invAspect, size);
          var flare = flares[i];
          tempPosition.set(flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14]);
          tempPosition.applyMatrix4(camera.matrixWorldInverse);
          tempPosition.applyProjection(camera.projectionMatrix);
          screenPosition.copy(tempPosition);
          screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
          screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;
          if (hasVertexTexture || (screenPositionPixels.x > 0 && screenPositionPixels.x < viewportWidth && screenPositionPixels.y > 0 && screenPositionPixels.y < viewportHeight)) {
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
            gl.uniform1i(uniforms.renderType, 0);
            gl.uniform2f(uniforms.scale, scale.x, scale.y);
            gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
            gl.disable(gl.BLEND);
            gl.enable(gl.DEPTH_TEST);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, occlusionTexture);
            gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0);
            gl.uniform1i(uniforms.renderType, 1);
            gl.disable(gl.DEPTH_TEST);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, tempTexture);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            flare.positionScreen.copy(screenPosition);
            if (flare.customUpdateCallback) {
              flare.customUpdateCallback(flare);
            } else {
              flare.updateLensFlares();
            }
            gl.uniform1i(uniforms.renderType, 2);
            gl.enable(gl.BLEND);
            for (var j = 0,
                jl = flare.lensFlares.length; j < jl; j++) {
              var sprite = flare.lensFlares[j];
              if (sprite.opacity > 0.001 && sprite.scale > 0.001) {
                screenPosition.x = sprite.x;
                screenPosition.y = sprite.y;
                screenPosition.z = sprite.z;
                size = sprite.size * sprite.scale / viewportHeight;
                scale.x = size * invAspect;
                scale.y = size;
                gl.uniform3f(uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z);
                gl.uniform2f(uniforms.scale, scale.x, scale.y);
                gl.uniform1f(uniforms.rotation, sprite.rotation);
                gl.uniform1f(uniforms.opacity, sprite.opacity);
                gl.uniform3f(uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b);
                renderer.state.setBlending(sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst);
                renderer.setTexture(sprite.texture, 1);
                gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
              }
            }
          }
        }
        gl.enable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        renderer.resetGLState();
      };
      function createProgram(shader) {
        var program = gl.createProgram();
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var prefix = "precision " + renderer.getPrecision() + " float;\n";
        gl.shaderSource(fragmentShader, prefix + shader.fragmentShader);
        gl.shaderSource(vertexShader, prefix + shader.vertexShader);
        gl.compileShader(fragmentShader);
        gl.compileShader(vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.linkProgram(program);
        return program;
      }
    };
    THREE.ShadowMapPlugin = function(_renderer, _lights, _webglObjects, _webglObjectsImmediate) {
      var _gl = _renderer.context;
      var _depthMaterial,
          _depthMaterialMorph,
          _depthMaterialSkin,
          _depthMaterialMorphSkin,
          _frustum = new THREE.Frustum(),
          _projScreenMatrix = new THREE.Matrix4(),
          _min = new THREE.Vector3(),
          _max = new THREE.Vector3(),
          _matrixPosition = new THREE.Vector3(),
          _renderList = [];
      var depthShader = THREE.ShaderLib["depthRGBA"];
      var depthUniforms = THREE.UniformsUtils.clone(depthShader.uniforms);
      _depthMaterial = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader
      });
      _depthMaterialMorph = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: true
      });
      _depthMaterialSkin = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        skinning: true
      });
      _depthMaterialMorphSkin = new THREE.ShaderMaterial({
        uniforms: depthUniforms,
        vertexShader: depthShader.vertexShader,
        fragmentShader: depthShader.fragmentShader,
        morphTargets: true,
        skinning: true
      });
      _depthMaterial._shadowPass = true;
      _depthMaterialMorph._shadowPass = true;
      _depthMaterialSkin._shadowPass = true;
      _depthMaterialMorphSkin._shadowPass = true;
      this.render = function(scene, camera) {
        if (_renderer.shadowMapEnabled === false)
          return;
        var i,
            il,
            j,
            jl,
            n,
            shadowMap,
            shadowMatrix,
            shadowCamera,
            buffer,
            material,
            webglObject,
            object,
            light,
            lights = [],
            k = 0,
            fog = null;
        _gl.clearColor(1, 1, 1, 1);
        _gl.disable(_gl.BLEND);
        _gl.enable(_gl.CULL_FACE);
        _gl.frontFace(_gl.CCW);
        if (_renderer.shadowMapCullFace === THREE.CullFaceFront) {
          _gl.cullFace(_gl.FRONT);
        } else {
          _gl.cullFace(_gl.BACK);
        }
        _renderer.state.setDepthTest(true);
        for (i = 0, il = _lights.length; i < il; i++) {
          light = _lights[i];
          if (!light.castShadow)
            continue;
          if ((light instanceof THREE.DirectionalLight) && light.shadowCascade) {
            for (n = 0; n < light.shadowCascadeCount; n++) {
              var virtualLight;
              if (!light.shadowCascadeArray[n]) {
                virtualLight = createVirtualLight(light, n);
                virtualLight.originalCamera = camera;
                var gyro = new THREE.Gyroscope();
                gyro.position.copy(light.shadowCascadeOffset);
                gyro.add(virtualLight);
                gyro.add(virtualLight.target);
                camera.add(gyro);
                light.shadowCascadeArray[n] = virtualLight;
              } else {
                virtualLight = light.shadowCascadeArray[n];
              }
              updateVirtualLight(light, n);
              lights[k] = virtualLight;
              k++;
            }
          } else {
            lights[k] = light;
            k++;
          }
        }
        for (i = 0, il = lights.length; i < il; i++) {
          light = lights[i];
          if (!light.shadowMap) {
            var shadowFilter = THREE.LinearFilter;
            if (_renderer.shadowMapType === THREE.PCFSoftShadowMap) {
              shadowFilter = THREE.NearestFilter;
            }
            var pars = {
              minFilter: shadowFilter,
              magFilter: shadowFilter,
              format: THREE.RGBAFormat
            };
            light.shadowMap = new THREE.WebGLRenderTarget(light.shadowMapWidth, light.shadowMapHeight, pars);
            light.shadowMapSize = new THREE.Vector2(light.shadowMapWidth, light.shadowMapHeight);
            light.shadowMatrix = new THREE.Matrix4();
          }
          if (!light.shadowCamera) {
            if (light instanceof THREE.SpotLight) {
              light.shadowCamera = new THREE.PerspectiveCamera(light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar);
            } else if (light instanceof THREE.DirectionalLight) {
              light.shadowCamera = new THREE.OrthographicCamera(light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar);
            } else {
              THREE.error("THREE.ShadowMapPlugin: Unsupported light type for shadow", light);
              continue;
            }
            scene.add(light.shadowCamera);
            if (scene.autoUpdate === true)
              scene.updateMatrixWorld();
          }
          if (light.shadowCameraVisible && !light.cameraHelper) {
            light.cameraHelper = new THREE.CameraHelper(light.shadowCamera);
            scene.add(light.cameraHelper);
          }
          if (light.isVirtual && virtualLight.originalCamera == camera) {
            updateShadowCamera(camera, light);
          }
          shadowMap = light.shadowMap;
          shadowMatrix = light.shadowMatrix;
          shadowCamera = light.shadowCamera;
          shadowCamera.position.setFromMatrixPosition(light.matrixWorld);
          _matrixPosition.setFromMatrixPosition(light.target.matrixWorld);
          shadowCamera.lookAt(_matrixPosition);
          shadowCamera.updateMatrixWorld();
          shadowCamera.matrixWorldInverse.getInverse(shadowCamera.matrixWorld);
          if (light.cameraHelper)
            light.cameraHelper.visible = light.shadowCameraVisible;
          if (light.shadowCameraVisible)
            light.cameraHelper.update();
          shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
          shadowMatrix.multiply(shadowCamera.projectionMatrix);
          shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
          _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
          _frustum.setFromMatrix(_projScreenMatrix);
          _renderer.setRenderTarget(shadowMap);
          _renderer.clear();
          _renderList.length = 0;
          projectObject(scene, scene, shadowCamera);
          var objectMaterial,
              useMorphing,
              useSkinning;
          for (j = 0, jl = _renderList.length; j < jl; j++) {
            webglObject = _renderList[j];
            object = webglObject.object;
            buffer = webglObject.buffer;
            objectMaterial = getObjectMaterial(object);
            useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
            useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;
            if (object.customDepthMaterial) {
              material = object.customDepthMaterial;
            } else if (useSkinning) {
              material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;
            } else if (useMorphing) {
              material = _depthMaterialMorph;
            } else {
              material = _depthMaterial;
            }
            _renderer.setMaterialFaces(objectMaterial);
            if (buffer instanceof THREE.BufferGeometry) {
              _renderer.renderBufferDirect(shadowCamera, _lights, fog, material, buffer, object);
            } else {
              _renderer.renderBuffer(shadowCamera, _lights, fog, material, buffer, object);
            }
          }
          for (j = 0, jl = _webglObjectsImmediate.length; j < jl; j++) {
            webglObject = _webglObjectsImmediate[j];
            object = webglObject.object;
            if (object.visible && object.castShadow) {
              object._modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
              _renderer.renderImmediateObject(shadowCamera, _lights, fog, _depthMaterial, object);
            }
          }
        }
        var clearColor = _renderer.getClearColor(),
            clearAlpha = _renderer.getClearAlpha();
        _gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearAlpha);
        _gl.enable(_gl.BLEND);
        if (_renderer.shadowMapCullFace === THREE.CullFaceFront) {
          _gl.cullFace(_gl.BACK);
        }
        _renderer.resetGLState();
      };
      function projectObject(scene, object, shadowCamera) {
        if (object.visible) {
          var webglObjects = _webglObjects[object.id];
          if (webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject(object) === true)) {
            for (var i = 0,
                l = webglObjects.length; i < l; i++) {
              var webglObject = webglObjects[i];
              object._modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
              _renderList.push(webglObject);
            }
          }
          for (var i = 0,
              l = object.children.length; i < l; i++) {
            projectObject(scene, object.children[i], shadowCamera);
          }
        }
      }
      function createVirtualLight(light, cascade) {
        var virtualLight = new THREE.DirectionalLight();
        virtualLight.isVirtual = true;
        virtualLight.onlyShadow = true;
        virtualLight.castShadow = true;
        virtualLight.shadowCameraNear = light.shadowCameraNear;
        virtualLight.shadowCameraFar = light.shadowCameraFar;
        virtualLight.shadowCameraLeft = light.shadowCameraLeft;
        virtualLight.shadowCameraRight = light.shadowCameraRight;
        virtualLight.shadowCameraBottom = light.shadowCameraBottom;
        virtualLight.shadowCameraTop = light.shadowCameraTop;
        virtualLight.shadowCameraVisible = light.shadowCameraVisible;
        virtualLight.shadowDarkness = light.shadowDarkness;
        virtualLight.shadowBias = light.shadowCascadeBias[cascade];
        virtualLight.shadowMapWidth = light.shadowCascadeWidth[cascade];
        virtualLight.shadowMapHeight = light.shadowCascadeHeight[cascade];
        virtualLight.pointsWorld = [];
        virtualLight.pointsFrustum = [];
        var pointsWorld = virtualLight.pointsWorld,
            pointsFrustum = virtualLight.pointsFrustum;
        for (var i = 0; i < 8; i++) {
          pointsWorld[i] = new THREE.Vector3();
          pointsFrustum[i] = new THREE.Vector3();
        }
        var nearZ = light.shadowCascadeNearZ[cascade];
        var farZ = light.shadowCascadeFarZ[cascade];
        pointsFrustum[0].set(-1, -1, nearZ);
        pointsFrustum[1].set(1, -1, nearZ);
        pointsFrustum[2].set(-1, 1, nearZ);
        pointsFrustum[3].set(1, 1, nearZ);
        pointsFrustum[4].set(-1, -1, farZ);
        pointsFrustum[5].set(1, -1, farZ);
        pointsFrustum[6].set(-1, 1, farZ);
        pointsFrustum[7].set(1, 1, farZ);
        return virtualLight;
      }
      function updateVirtualLight(light, cascade) {
        var virtualLight = light.shadowCascadeArray[cascade];
        virtualLight.position.copy(light.position);
        virtualLight.target.position.copy(light.target.position);
        virtualLight.lookAt(virtualLight.target);
        virtualLight.shadowCameraVisible = light.shadowCameraVisible;
        virtualLight.shadowDarkness = light.shadowDarkness;
        virtualLight.shadowBias = light.shadowCascadeBias[cascade];
        var nearZ = light.shadowCascadeNearZ[cascade];
        var farZ = light.shadowCascadeFarZ[cascade];
        var pointsFrustum = virtualLight.pointsFrustum;
        pointsFrustum[0].z = nearZ;
        pointsFrustum[1].z = nearZ;
        pointsFrustum[2].z = nearZ;
        pointsFrustum[3].z = nearZ;
        pointsFrustum[4].z = farZ;
        pointsFrustum[5].z = farZ;
        pointsFrustum[6].z = farZ;
        pointsFrustum[7].z = farZ;
      }
      function updateShadowCamera(camera, light) {
        var shadowCamera = light.shadowCamera,
            pointsFrustum = light.pointsFrustum,
            pointsWorld = light.pointsWorld;
        _min.set(Infinity, Infinity, Infinity);
        _max.set(-Infinity, -Infinity, -Infinity);
        for (var i = 0; i < 8; i++) {
          var p = pointsWorld[i];
          p.copy(pointsFrustum[i]);
          p.unproject(camera);
          p.applyMatrix4(shadowCamera.matrixWorldInverse);
          if (p.x < _min.x)
            _min.x = p.x;
          if (p.x > _max.x)
            _max.x = p.x;
          if (p.y < _min.y)
            _min.y = p.y;
          if (p.y > _max.y)
            _max.y = p.y;
          if (p.z < _min.z)
            _min.z = p.z;
          if (p.z > _max.z)
            _max.z = p.z;
        }
        shadowCamera.left = _min.x;
        shadowCamera.right = _max.x;
        shadowCamera.top = _max.y;
        shadowCamera.bottom = _min.y;
        shadowCamera.updateProjectionMatrix();
      }
      function getObjectMaterial(object) {
        return object.material instanceof THREE.MeshFaceMaterial ? object.material.materials[0] : object.material;
      }
      ;
    };
    THREE.SpritePlugin = function(renderer, sprites) {
      var gl = renderer.context;
      var vertexBuffer,
          elementBuffer;
      var program,
          attributes,
          uniforms;
      var texture;
      var spritePosition = new THREE.Vector3();
      var spriteRotation = new THREE.Quaternion();
      var spriteScale = new THREE.Vector3();
      var init = function() {
        var vertices = new Float32Array([-0.5, -0.5, 0, 0, 0.5, -0.5, 1, 0, 0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1]);
        var faces = new Uint16Array([0, 1, 2, 0, 2, 3]);
        vertexBuffer = gl.createBuffer();
        elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW);
        program = createProgram();
        attributes = {
          position: gl.getAttribLocation(program, 'position'),
          uv: gl.getAttribLocation(program, 'uv')
        };
        uniforms = {
          uvOffset: gl.getUniformLocation(program, 'uvOffset'),
          uvScale: gl.getUniformLocation(program, 'uvScale'),
          rotation: gl.getUniformLocation(program, 'rotation'),
          scale: gl.getUniformLocation(program, 'scale'),
          color: gl.getUniformLocation(program, 'color'),
          map: gl.getUniformLocation(program, 'map'),
          opacity: gl.getUniformLocation(program, 'opacity'),
          modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
          projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
          fogType: gl.getUniformLocation(program, 'fogType'),
          fogDensity: gl.getUniformLocation(program, 'fogDensity'),
          fogNear: gl.getUniformLocation(program, 'fogNear'),
          fogFar: gl.getUniformLocation(program, 'fogFar'),
          fogColor: gl.getUniformLocation(program, 'fogColor'),
          alphaTest: gl.getUniformLocation(program, 'alphaTest')
        };
        var canvas = document.createElement('canvas');
        canvas.width = 8;
        canvas.height = 8;
        var context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.fillRect(0, 0, 8, 8);
        texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
      };
      this.render = function(scene, camera) {
        if (sprites.length === 0)
          return;
        if (program === undefined) {
          init();
        }
        gl.useProgram(program);
        gl.enableVertexAttribArray(attributes.position);
        gl.enableVertexAttribArray(attributes.uv);
        gl.disable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 2 * 8, 0);
        gl.vertexAttribPointer(attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementBuffer);
        gl.uniformMatrix4fv(uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(uniforms.map, 0);
        var oldFogType = 0;
        var sceneFogType = 0;
        var fog = scene.fog;
        if (fog) {
          gl.uniform3f(uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b);
          if (fog instanceof THREE.Fog) {
            gl.uniform1f(uniforms.fogNear, fog.near);
            gl.uniform1f(uniforms.fogFar, fog.far);
            gl.uniform1i(uniforms.fogType, 1);
            oldFogType = 1;
            sceneFogType = 1;
          } else if (fog instanceof THREE.FogExp2) {
            gl.uniform1f(uniforms.fogDensity, fog.density);
            gl.uniform1i(uniforms.fogType, 2);
            oldFogType = 2;
            sceneFogType = 2;
          }
        } else {
          gl.uniform1i(uniforms.fogType, 0);
          oldFogType = 0;
          sceneFogType = 0;
        }
        for (var i = 0,
            l = sprites.length; i < l; i++) {
          var sprite = sprites[i];
          sprite._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, sprite.matrixWorld);
          sprite.z = -sprite._modelViewMatrix.elements[14];
        }
        sprites.sort(painterSortStable);
        var scale = [];
        for (var i = 0,
            l = sprites.length; i < l; i++) {
          var sprite = sprites[i];
          var material = sprite.material;
          gl.uniform1f(uniforms.alphaTest, material.alphaTest);
          gl.uniformMatrix4fv(uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements);
          sprite.matrixWorld.decompose(spritePosition, spriteRotation, spriteScale);
          scale[0] = spriteScale.x;
          scale[1] = spriteScale.y;
          var fogType = 0;
          if (scene.fog && material.fog) {
            fogType = sceneFogType;
          }
          if (oldFogType !== fogType) {
            gl.uniform1i(uniforms.fogType, fogType);
            oldFogType = fogType;
          }
          if (material.map !== null) {
            gl.uniform2f(uniforms.uvOffset, material.map.offset.x, material.map.offset.y);
            gl.uniform2f(uniforms.uvScale, material.map.repeat.x, material.map.repeat.y);
          } else {
            gl.uniform2f(uniforms.uvOffset, 0, 0);
            gl.uniform2f(uniforms.uvScale, 1, 1);
          }
          gl.uniform1f(uniforms.opacity, material.opacity);
          gl.uniform3f(uniforms.color, material.color.r, material.color.g, material.color.b);
          gl.uniform1f(uniforms.rotation, material.rotation);
          gl.uniform2fv(uniforms.scale, scale);
          renderer.state.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst);
          renderer.state.setDepthTest(material.depthTest);
          renderer.state.setDepthWrite(material.depthWrite);
          if (material.map && material.map.image && material.map.image.width) {
            renderer.setTexture(material.map, 0);
          } else {
            renderer.setTexture(texture, 0);
          }
          gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }
        gl.enable(gl.CULL_FACE);
        renderer.resetGLState();
      };
      function createProgram() {
        var program = gl.createProgram();
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vertexShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform float rotation;', 'uniform vec2 scale;', 'uniform vec2 uvOffset;', 'uniform vec2 uvScale;', 'attribute vec2 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'void main() {', 'vUV = uvOffset + uv * uvScale;', 'vec2 alignedPosition = position * scale;', 'vec2 rotatedPosition;', 'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;', 'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;', 'vec4 finalPosition;', 'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );', 'finalPosition.xy += rotatedPosition;', 'finalPosition = projectionMatrix * finalPosition;', 'gl_Position = finalPosition;', '}'].join('\n'));
        gl.shaderSource(fragmentShader, ['precision ' + renderer.getPrecision() + ' float;', 'uniform vec3 color;', 'uniform sampler2D map;', 'uniform float opacity;', 'uniform int fogType;', 'uniform vec3 fogColor;', 'uniform float fogDensity;', 'uniform float fogNear;', 'uniform float fogFar;', 'uniform float alphaTest;', 'varying vec2 vUV;', 'void main() {', 'vec4 texture = texture2D( map, vUV );', 'if ( texture.a < alphaTest ) discard;', 'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );', 'if ( fogType > 0 ) {', 'float depth = gl_FragCoord.z / gl_FragCoord.w;', 'float fogFactor = 0.0;', 'if ( fogType == 1 ) {', 'fogFactor = smoothstep( fogNear, fogFar, depth );', '} else {', 'const float LOG2 = 1.442695;', 'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );', 'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );', '}', 'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );', '}', '}'].join('\n'));
        gl.compileShader(vertexShader);
        gl.compileShader(fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        return program;
      }
      ;
      function painterSortStable(a, b) {
        if (a.z !== b.z) {
          return b.z - a.z;
        } else {
          return b.id - a.id;
        }
      }
      ;
    };
    THREE.GeometryUtils = {
      merge: function(geometry1, geometry2, materialIndexOffset) {
        THREE.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
        var matrix;
        if (geometry2 instanceof THREE.Mesh) {
          geometry2.matrixAutoUpdate && geometry2.updateMatrix();
          matrix = geometry2.matrix;
          geometry2 = geometry2.geometry;
        }
        geometry1.merge(geometry2, matrix, materialIndexOffset);
      },
      center: function(geometry) {
        THREE.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
        return geometry.center();
      }
    };
    THREE.ImageUtils = {
      crossOrigin: undefined,
      loadTexture: function(url, mapping, onLoad, onError) {
        var loader = new THREE.ImageLoader();
        loader.crossOrigin = this.crossOrigin;
        var texture = new THREE.Texture(undefined, mapping);
        loader.load(url, function(image) {
          texture.image = image;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }, undefined, function(event) {
          if (onError)
            onError(event);
        });
        texture.sourceFile = url;
        return texture;
      },
      loadTextureCube: function(array, mapping, onLoad, onError) {
        var images = [];
        var loader = new THREE.ImageLoader();
        loader.crossOrigin = this.crossOrigin;
        var texture = new THREE.CubeTexture(images, mapping);
        texture.flipY = false;
        var loaded = 0;
        var loadTexture = function(i) {
          loader.load(array[i], function(image) {
            texture.images[i] = image;
            loaded += 1;
            if (loaded === 6) {
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, undefined, onError);
        };
        for (var i = 0,
            il = array.length; i < il; ++i) {
          loadTexture(i);
        }
        return texture;
      },
      loadCompressedTexture: function() {
        THREE.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
      },
      loadCompressedTextureCube: function() {
        THREE.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
      },
      getNormalMap: function(image, depth) {
        var cross = function(a, b) {
          return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
        };
        var subtract = function(a, b) {
          return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
        };
        var normalize = function(a) {
          var l = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
          return [a[0] / l, a[1] / l, a[2] / l];
        };
        depth = depth | 1;
        var width = image.width;
        var height = image.height;
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext('2d');
        context.drawImage(image, 0, 0);
        var data = context.getImageData(0, 0, width, height).data;
        var imageData = context.createImageData(width, height);
        var output = imageData.data;
        for (var x = 0; x < width; x++) {
          for (var y = 0; y < height; y++) {
            var ly = y - 1 < 0 ? 0 : y - 1;
            var uy = y + 1 > height - 1 ? height - 1 : y + 1;
            var lx = x - 1 < 0 ? 0 : x - 1;
            var ux = x + 1 > width - 1 ? width - 1 : x + 1;
            var points = [];
            var origin = [0, 0, data[(y * width + x) * 4] / 255 * depth];
            points.push([-1, 0, data[(y * width + lx) * 4] / 255 * depth]);
            points.push([-1, -1, data[(ly * width + lx) * 4] / 255 * depth]);
            points.push([0, -1, data[(ly * width + x) * 4] / 255 * depth]);
            points.push([1, -1, data[(ly * width + ux) * 4] / 255 * depth]);
            points.push([1, 0, data[(y * width + ux) * 4] / 255 * depth]);
            points.push([1, 1, data[(uy * width + ux) * 4] / 255 * depth]);
            points.push([0, 1, data[(uy * width + x) * 4] / 255 * depth]);
            points.push([-1, 1, data[(uy * width + lx) * 4] / 255 * depth]);
            var normals = [];
            var num_points = points.length;
            for (var i = 0; i < num_points; i++) {
              var v1 = points[i];
              var v2 = points[(i + 1) % num_points];
              v1 = subtract(v1, origin);
              v2 = subtract(v2, origin);
              normals.push(normalize(cross(v1, v2)));
            }
            var normal = [0, 0, 0];
            for (var i = 0; i < normals.length; i++) {
              normal[0] += normals[i][0];
              normal[1] += normals[i][1];
              normal[2] += normals[i][2];
            }
            normal[0] /= normals.length;
            normal[1] /= normals.length;
            normal[2] /= normals.length;
            var idx = (y * width + x) * 4;
            output[idx] = ((normal[0] + 1.0) / 2.0 * 255) | 0;
            output[idx + 1] = ((normal[1] + 1.0) / 2.0 * 255) | 0;
            output[idx + 2] = (normal[2] * 255) | 0;
            output[idx + 3] = 255;
          }
        }
        context.putImageData(imageData, 0, 0);
        return canvas;
      },
      generateDataTexture: function(width, height, color) {
        var size = width * height;
        var data = new Uint8Array(3 * size);
        var r = Math.floor(color.r * 255);
        var g = Math.floor(color.g * 255);
        var b = Math.floor(color.b * 255);
        for (var i = 0; i < size; i++) {
          data[i * 3] = r;
          data[i * 3 + 1] = g;
          data[i * 3 + 2] = b;
        }
        var texture = new THREE.DataTexture(data, width, height, THREE.RGBFormat);
        texture.needsUpdate = true;
        return texture;
      }
    };
    THREE.SceneUtils = {
      createMultiMaterialObject: function(geometry, materials) {
        var group = new THREE.Object3D();
        for (var i = 0,
            l = materials.length; i < l; i++) {
          group.add(new THREE.Mesh(geometry, materials[i]));
        }
        return group;
      },
      detach: function(child, parent, scene) {
        child.applyMatrix(parent.matrixWorld);
        parent.remove(child);
        scene.add(child);
      },
      attach: function(child, scene, parent) {
        var matrixWorldInverse = new THREE.Matrix4();
        matrixWorldInverse.getInverse(parent.matrixWorld);
        child.applyMatrix(matrixWorldInverse);
        scene.remove(child);
        parent.add(child);
      }
    };
    THREE.FontUtils = {
      faces: {},
      face: 'helvetiker',
      weight: 'normal',
      style: 'normal',
      size: 150,
      divisions: 10,
      getFace: function() {
        try {
          return this.faces[this.face][this.weight][this.style];
        } catch (e) {
          throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing.";
        }
        ;
      },
      loadFace: function(data) {
        var family = data.familyName.toLowerCase();
        var ThreeFont = this;
        ThreeFont.faces[family] = ThreeFont.faces[family] || {};
        ThreeFont.faces[family][data.cssFontWeight] = ThreeFont.faces[family][data.cssFontWeight] || {};
        ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;
        ThreeFont.faces[family][data.cssFontWeight][data.cssFontStyle] = data;
        return data;
      },
      drawText: function(text) {
        var i,
            face = this.getFace(),
            scale = this.size / face.resolution,
            offset = 0,
            chars = String(text).split(''),
            length = chars.length;
        var fontPaths = [];
        for (i = 0; i < length; i++) {
          var path = new THREE.Path();
          var ret = this.extractGlyphPoints(chars[i], face, scale, offset, path);
          offset += ret.offset;
          fontPaths.push(ret.path);
        }
        var width = offset / 2;
        return {
          paths: fontPaths,
          offset: width
        };
      },
      extractGlyphPoints: function(c, face, scale, offset, path) {
        var pts = [];
        var i,
            i2,
            divisions,
            outline,
            action,
            length,
            scaleX,
            scaleY,
            x,
            y,
            cpx,
            cpy,
            cpx0,
            cpy0,
            cpx1,
            cpy1,
            cpx2,
            cpy2,
            laste,
            glyph = face.glyphs[c] || face.glyphs['?'];
        if (!glyph)
          return;
        if (glyph.o) {
          outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
          length = outline.length;
          scaleX = scale;
          scaleY = scale;
          for (i = 0; i < length; ) {
            action = outline[i++];
            switch (action) {
              case 'm':
                x = outline[i++] * scaleX + offset;
                y = outline[i++] * scaleY;
                path.moveTo(x, y);
                break;
              case 'l':
                x = outline[i++] * scaleX + offset;
                y = outline[i++] * scaleY;
                path.lineTo(x, y);
                break;
              case 'q':
                cpx = outline[i++] * scaleX + offset;
                cpy = outline[i++] * scaleY;
                cpx1 = outline[i++] * scaleX + offset;
                cpy1 = outline[i++] * scaleY;
                path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                laste = pts[pts.length - 1];
                if (laste) {
                  cpx0 = laste.x;
                  cpy0 = laste.y;
                  for (i2 = 1, divisions = this.divisions; i2 <= divisions; i2++) {
                    var t = i2 / divisions;
                    THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);
                    THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);
                  }
                }
                break;
              case 'b':
                cpx = outline[i++] * scaleX + offset;
                cpy = outline[i++] * scaleY;
                cpx1 = outline[i++] * scaleX + offset;
                cpy1 = outline[i++] * scaleY;
                cpx2 = outline[i++] * scaleX + offset;
                cpy2 = outline[i++] * scaleY;
                path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                laste = pts[pts.length - 1];
                if (laste) {
                  cpx0 = laste.x;
                  cpy0 = laste.y;
                  for (i2 = 1, divisions = this.divisions; i2 <= divisions; i2++) {
                    var t = i2 / divisions;
                    THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);
                    THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);
                  }
                }
                break;
            }
          }
        }
        return {
          offset: glyph.ha * scale,
          path: path
        };
      }
    };
    THREE.FontUtils.generateShapes = function(text, parameters) {
      parameters = parameters || {};
      var size = parameters.size !== undefined ? parameters.size : 100;
      var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;
      var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
      var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
      var style = parameters.style !== undefined ? parameters.style : 'normal';
      THREE.FontUtils.size = size;
      THREE.FontUtils.divisions = curveSegments;
      THREE.FontUtils.face = font;
      THREE.FontUtils.weight = weight;
      THREE.FontUtils.style = style;
      var data = THREE.FontUtils.drawText(text);
      var paths = data.paths;
      var shapes = [];
      for (var p = 0,
          pl = paths.length; p < pl; p++) {
        Array.prototype.push.apply(shapes, paths[p].toShapes());
      }
      return shapes;
    };
    (function(namespace) {
      var EPSILON = 0.0000000001;
      var process = function(contour, indices) {
        var n = contour.length;
        if (n < 3)
          return null;
        var result = [],
            verts = [],
            vertIndices = [];
        var u,
            v,
            w;
        if (area(contour) > 0.0) {
          for (v = 0; v < n; v++)
            verts[v] = v;
        } else {
          for (v = 0; v < n; v++)
            verts[v] = (n - 1) - v;
        }
        var nv = n;
        var count = 2 * nv;
        for (v = nv - 1; nv > 2; ) {
          if ((count--) <= 0) {
            THREE.warn('THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()');
            if (indices)
              return vertIndices;
            return result;
          }
          u = v;
          if (nv <= u)
            u = 0;
          v = u + 1;
          if (nv <= v)
            v = 0;
          w = v + 1;
          if (nv <= w)
            w = 0;
          if (snip(contour, u, v, w, nv, verts)) {
            var a,
                b,
                c,
                s,
                t;
            a = verts[u];
            b = verts[v];
            c = verts[w];
            result.push([contour[a], contour[b], contour[c]]);
            vertIndices.push([verts[u], verts[v], verts[w]]);
            for (s = v, t = v + 1; t < nv; s++, t++) {
              verts[s] = verts[t];
            }
            nv--;
            count = 2 * nv;
          }
        }
        if (indices)
          return vertIndices;
        return result;
      };
      var area = function(contour) {
        var n = contour.length;
        var a = 0.0;
        for (var p = n - 1,
            q = 0; q < n; p = q++) {
          a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
      };
      var snip = function(contour, u, v, w, n, verts) {
        var p;
        var ax,
            ay,
            bx,
            by;
        var cx,
            cy,
            px,
            py;
        ax = contour[verts[u]].x;
        ay = contour[verts[u]].y;
        bx = contour[verts[v]].x;
        by = contour[verts[v]].y;
        cx = contour[verts[w]].x;
        cy = contour[verts[w]].y;
        if (EPSILON > (((bx - ax) * (cy - ay)) - ((by - ay) * (cx - ax))))
          return false;
        var aX,
            aY,
            bX,
            bY,
            cX,
            cY;
        var apx,
            apy,
            bpx,
            bpy,
            cpx,
            cpy;
        var cCROSSap,
            bCROSScp,
            aCROSSbp;
        aX = cx - bx;
        aY = cy - by;
        bX = ax - cx;
        bY = ay - cy;
        cX = bx - ax;
        cY = by - ay;
        for (p = 0; p < n; p++) {
          px = contour[verts[p]].x;
          py = contour[verts[p]].y;
          if (((px === ax) && (py === ay)) || ((px === bx) && (py === by)) || ((px === cx) && (py === cy)))
            continue;
          apx = px - ax;
          apy = py - ay;
          bpx = px - bx;
          bpy = py - by;
          cpx = px - cx;
          cpy = py - cy;
          aCROSSbp = aX * bpy - aY * bpx;
          cCROSSap = cX * apy - cY * apx;
          bCROSScp = bX * cpy - bY * cpx;
          if ((aCROSSbp >= -EPSILON) && (bCROSScp >= -EPSILON) && (cCROSSap >= -EPSILON))
            return false;
        }
        return true;
      };
      namespace.Triangulate = process;
      namespace.Triangulate.area = area;
      return namespace;
    })(THREE.FontUtils);
    self._typeface_js = {
      faces: THREE.FontUtils.faces,
      loadFace: THREE.FontUtils.loadFace
    };
    THREE.typeface_js = self._typeface_js;
    THREE.Audio = function(listener) {
      THREE.Object3D.call(this);
      this.type = 'Audio';
      this.context = listener.context;
      this.source = this.context.createBufferSource();
      this.source.onended = this.onEnded.bind(this);
      this.gain = this.context.createGain();
      this.gain.connect(this.context.destination);
      this.panner = this.context.createPanner();
      this.panner.connect(this.gain);
      this.autoplay = false;
      this.startTime = 0;
      this.isPlaying = false;
    };
    THREE.Audio.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Audio.prototype.constructor = THREE.Audio;
    THREE.Audio.prototype.load = function(file) {
      var scope = this;
      var request = new XMLHttpRequest();
      request.open('GET', file, true);
      request.responseType = 'arraybuffer';
      request.onload = function(e) {
        scope.context.decodeAudioData(this.response, function(buffer) {
          scope.source.buffer = buffer;
          if (scope.autoplay)
            scope.play();
        });
      };
      request.send();
      return this;
    };
    THREE.Audio.prototype.play = function() {
      if (this.isPlaying === true) {
        THREE.warn('THREE.Audio: Audio is already playing.');
        return;
      }
      var source = this.context.createBufferSource();
      source.buffer = this.source.buffer;
      source.loop = this.source.loop;
      source.onended = this.source.onended;
      source.connect(this.panner);
      source.start(0, this.startTime);
      this.isPlaying = true;
      this.source = source;
    };
    THREE.Audio.prototype.pause = function() {
      this.source.stop();
      this.startTime = this.context.currentTime;
    };
    THREE.Audio.prototype.stop = function() {
      this.source.stop();
      this.startTime = 0;
    };
    THREE.Audio.prototype.onEnded = function() {
      this.isPlaying = false;
    };
    THREE.Audio.prototype.setLoop = function(value) {
      this.source.loop = value;
    };
    THREE.Audio.prototype.setRefDistance = function(value) {
      this.panner.refDistance = value;
    };
    THREE.Audio.prototype.setRolloffFactor = function(value) {
      this.panner.rolloffFactor = value;
    };
    THREE.Audio.prototype.setVolume = function(value) {
      this.gain.gain.value = value;
    };
    THREE.Audio.prototype.updateMatrixWorld = (function() {
      var position = new THREE.Vector3();
      return function(force) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
        position.setFromMatrixPosition(this.matrixWorld);
        this.panner.setPosition(position.x, position.y, position.z);
      };
    })();
    THREE.AudioListener = function() {
      THREE.Object3D.call(this);
      this.type = 'AudioListener';
      this.context = new (window.AudioContext || window.webkitAudioContext)();
    };
    THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);
    THREE.AudioListener.prototype.constructor = THREE.AudioListener;
    THREE.AudioListener.prototype.updateMatrixWorld = (function() {
      var position = new THREE.Vector3();
      var quaternion = new THREE.Quaternion();
      var scale = new THREE.Vector3();
      var orientation = new THREE.Vector3();
      var velocity = new THREE.Vector3();
      var positionPrev = new THREE.Vector3();
      return function(force) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, force);
        var listener = this.context.listener;
        var up = this.up;
        this.matrixWorld.decompose(position, quaternion, scale);
        orientation.set(0, 0, -1).applyQuaternion(quaternion);
        velocity.subVectors(position, positionPrev);
        listener.setPosition(position.x, position.y, position.z);
        listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
        listener.setVelocity(velocity.x, velocity.y, velocity.z);
        positionPrev.copy(position);
      };
    })();
    THREE.Curve = function() {};
    THREE.Curve.prototype.getPoint = function(t) {
      THREE.warn("THREE.Curve: Warning, getPoint() not implemented!");
      return null;
    };
    THREE.Curve.prototype.getPointAt = function(u) {
      var t = this.getUtoTmapping(u);
      return this.getPoint(t);
    };
    THREE.Curve.prototype.getPoints = function(divisions) {
      if (!divisions)
        divisions = 5;
      var d,
          pts = [];
      for (d = 0; d <= divisions; d++) {
        pts.push(this.getPoint(d / divisions));
      }
      return pts;
    };
    THREE.Curve.prototype.getSpacedPoints = function(divisions) {
      if (!divisions)
        divisions = 5;
      var d,
          pts = [];
      for (d = 0; d <= divisions; d++) {
        pts.push(this.getPointAt(d / divisions));
      }
      return pts;
    };
    THREE.Curve.prototype.getLength = function() {
      var lengths = this.getLengths();
      return lengths[lengths.length - 1];
    };
    THREE.Curve.prototype.getLengths = function(divisions) {
      if (!divisions)
        divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;
      if (this.cacheArcLengths && (this.cacheArcLengths.length == divisions + 1) && !this.needsUpdate) {
        return this.cacheArcLengths;
      }
      this.needsUpdate = false;
      var cache = [];
      var current,
          last = this.getPoint(0);
      var p,
          sum = 0;
      cache.push(0);
      for (p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        sum += current.distanceTo(last);
        cache.push(sum);
        last = current;
      }
      this.cacheArcLengths = cache;
      return cache;
    };
    THREE.Curve.prototype.updateArcLengths = function() {
      this.needsUpdate = true;
      this.getLengths();
    };
    THREE.Curve.prototype.getUtoTmapping = function(u, distance) {
      var arcLengths = this.getLengths();
      var i = 0,
          il = arcLengths.length;
      var targetArcLength;
      if (distance) {
        targetArcLength = distance;
      } else {
        targetArcLength = u * arcLengths[il - 1];
      }
      var low = 0,
          high = il - 1,
          comparison;
      while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
          low = i + 1;
        } else if (comparison > 0) {
          high = i - 1;
        } else {
          high = i;
          break;
        }
      }
      i = high;
      if (arcLengths[i] == targetArcLength) {
        var t = i / (il - 1);
        return t;
      }
      var lengthBefore = arcLengths[i];
      var lengthAfter = arcLengths[i + 1];
      var segmentLength = lengthAfter - lengthBefore;
      var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      var t = (i + segmentFraction) / (il - 1);
      return t;
    };
    THREE.Curve.prototype.getTangent = function(t) {
      var delta = 0.0001;
      var t1 = t - delta;
      var t2 = t + delta;
      if (t1 < 0)
        t1 = 0;
      if (t2 > 1)
        t2 = 1;
      var pt1 = this.getPoint(t1);
      var pt2 = this.getPoint(t2);
      var vec = pt2.clone().sub(pt1);
      return vec.normalize();
    };
    THREE.Curve.prototype.getTangentAt = function(u) {
      var t = this.getUtoTmapping(u);
      return this.getTangent(t);
    };
    THREE.Curve.Utils = {
      tangentQuadraticBezier: function(t, p0, p1, p2) {
        return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
      },
      tangentCubicBezier: function(t, p0, p1, p2, p3) {
        return -3 * p0 * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) + 6 * t * p2 * (1 - t) - 3 * t * t * p2 + 3 * t * t * p3;
      },
      tangentSpline: function(t, p0, p1, p2, p3) {
        var h00 = 6 * t * t - 6 * t;
        var h10 = 3 * t * t - 4 * t + 1;
        var h01 = -6 * t * t + 6 * t;
        var h11 = 3 * t * t - 2 * t;
        return h00 + h10 + h01 + h11;
      },
      interpolate: function(p0, p1, p2, p3, t) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
      }
    };
    THREE.Curve.create = function(constructor, getPointFunc) {
      constructor.prototype = Object.create(THREE.Curve.prototype);
      constructor.prototype.constructor = constructor;
      constructor.prototype.getPoint = getPointFunc;
      return constructor;
    };
    THREE.CurvePath = function() {
      this.curves = [];
      this.bends = [];
      this.autoClose = false;
    };
    THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
    THREE.CurvePath.prototype.constructor = THREE.CurvePath;
    THREE.CurvePath.prototype.add = function(curve) {
      this.curves.push(curve);
    };
    THREE.CurvePath.prototype.checkConnection = function() {};
    THREE.CurvePath.prototype.closePath = function() {
      var startPoint = this.curves[0].getPoint(0);
      var endPoint = this.curves[this.curves.length - 1].getPoint(1);
      if (!startPoint.equals(endPoint)) {
        this.curves.push(new THREE.LineCurve(endPoint, startPoint));
      }
    };
    THREE.CurvePath.prototype.getPoint = function(t) {
      var d = t * this.getLength();
      var curveLengths = this.getCurveLengths();
      var i = 0,
          diff,
          curve;
      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          diff = curveLengths[i] - d;
          curve = this.curves[i];
          var u = 1 - diff / curve.getLength();
          return curve.getPointAt(u);
        }
        i++;
      }
      return null;
    };
    THREE.CurvePath.prototype.getLength = function() {
      var lens = this.getCurveLengths();
      return lens[lens.length - 1];
    };
    THREE.CurvePath.prototype.getCurveLengths = function() {
      if (this.cacheLengths && this.cacheLengths.length == this.curves.length) {
        return this.cacheLengths;
      }
      ;
      var lengths = [],
          sums = 0;
      var i,
          il = this.curves.length;
      for (i = 0; i < il; i++) {
        sums += this.curves[i].getLength();
        lengths.push(sums);
      }
      this.cacheLengths = lengths;
      return lengths;
    };
    THREE.CurvePath.prototype.getBoundingBox = function() {
      var points = this.getPoints();
      var maxX,
          maxY,
          maxZ;
      var minX,
          minY,
          minZ;
      maxX = maxY = Number.NEGATIVE_INFINITY;
      minX = minY = Number.POSITIVE_INFINITY;
      var p,
          i,
          il,
          sum;
      var v3 = points[0] instanceof THREE.Vector3;
      sum = v3 ? new THREE.Vector3() : new THREE.Vector2();
      for (i = 0, il = points.length; i < il; i++) {
        p = points[i];
        if (p.x > maxX)
          maxX = p.x;
        else if (p.x < minX)
          minX = p.x;
        if (p.y > maxY)
          maxY = p.y;
        else if (p.y < minY)
          minY = p.y;
        if (v3) {
          if (p.z > maxZ)
            maxZ = p.z;
          else if (p.z < minZ)
            minZ = p.z;
        }
        sum.add(p);
      }
      var ret = {
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY
      };
      if (v3) {
        ret.maxZ = maxZ;
        ret.minZ = minZ;
      }
      return ret;
    };
    THREE.CurvePath.prototype.createPointsGeometry = function(divisions) {
      var pts = this.getPoints(divisions, true);
      return this.createGeometry(pts);
    };
    THREE.CurvePath.prototype.createSpacedPointsGeometry = function(divisions) {
      var pts = this.getSpacedPoints(divisions, true);
      return this.createGeometry(pts);
    };
    THREE.CurvePath.prototype.createGeometry = function(points) {
      var geometry = new THREE.Geometry();
      for (var i = 0; i < points.length; i++) {
        geometry.vertices.push(new THREE.Vector3(points[i].x, points[i].y, points[i].z || 0));
      }
      return geometry;
    };
    THREE.CurvePath.prototype.addWrapPath = function(bendpath) {
      this.bends.push(bendpath);
    };
    THREE.CurvePath.prototype.getTransformedPoints = function(segments, bends) {
      var oldPts = this.getPoints(segments);
      var i,
          il;
      if (!bends) {
        bends = this.bends;
      }
      for (i = 0, il = bends.length; i < il; i++) {
        oldPts = this.getWrapPoints(oldPts, bends[i]);
      }
      return oldPts;
    };
    THREE.CurvePath.prototype.getTransformedSpacedPoints = function(segments, bends) {
      var oldPts = this.getSpacedPoints(segments);
      var i,
          il;
      if (!bends) {
        bends = this.bends;
      }
      for (i = 0, il = bends.length; i < il; i++) {
        oldPts = this.getWrapPoints(oldPts, bends[i]);
      }
      return oldPts;
    };
    THREE.CurvePath.prototype.getWrapPoints = function(oldPts, path) {
      var bounds = this.getBoundingBox();
      var i,
          il,
          p,
          oldX,
          oldY,
          xNorm;
      for (i = 0, il = oldPts.length; i < il; i++) {
        p = oldPts[i];
        oldX = p.x;
        oldY = p.y;
        xNorm = oldX / bounds.maxX;
        xNorm = path.getUtoTmapping(xNorm, oldX);
        var pathPt = path.getPoint(xNorm);
        var normal = path.getTangent(xNorm);
        normal.set(-normal.y, normal.x).multiplyScalar(oldY);
        p.x = pathPt.x + normal.x;
        p.y = pathPt.y + normal.y;
      }
      return oldPts;
    };
    THREE.Gyroscope = function() {
      THREE.Object3D.call(this);
    };
    THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
    THREE.Gyroscope.prototype.constructor = THREE.Gyroscope;
    THREE.Gyroscope.prototype.updateMatrixWorld = (function() {
      var translationObject = new THREE.Vector3();
      var quaternionObject = new THREE.Quaternion();
      var scaleObject = new THREE.Vector3();
      var translationWorld = new THREE.Vector3();
      var quaternionWorld = new THREE.Quaternion();
      var scaleWorld = new THREE.Vector3();
      return function(force) {
        this.matrixAutoUpdate && this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
          if (this.parent) {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            this.matrixWorld.decompose(translationWorld, quaternionWorld, scaleWorld);
            this.matrix.decompose(translationObject, quaternionObject, scaleObject);
            this.matrixWorld.compose(translationWorld, quaternionObject, scaleWorld);
          } else {
            this.matrixWorld.copy(this.matrix);
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        for (var i = 0,
            l = this.children.length; i < l; i++) {
          this.children[i].updateMatrixWorld(force);
        }
      };
    }());
    THREE.Path = function(points) {
      THREE.CurvePath.call(this);
      this.actions = [];
      if (points) {
        this.fromPoints(points);
      }
    };
    THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
    THREE.Path.prototype.constructor = THREE.Path;
    THREE.PathActions = {
      MOVE_TO: 'moveTo',
      LINE_TO: 'lineTo',
      QUADRATIC_CURVE_TO: 'quadraticCurveTo',
      BEZIER_CURVE_TO: 'bezierCurveTo',
      CSPLINE_THRU: 'splineThru',
      ARC: 'arc',
      ELLIPSE: 'ellipse'
    };
    THREE.Path.prototype.fromPoints = function(vectors) {
      this.moveTo(vectors[0].x, vectors[0].y);
      for (var v = 1,
          vlen = vectors.length; v < vlen; v++) {
        this.lineTo(vectors[v].x, vectors[v].y);
      }
      ;
    };
    THREE.Path.prototype.moveTo = function(x, y) {
      var args = Array.prototype.slice.call(arguments);
      this.actions.push({
        action: THREE.PathActions.MOVE_TO,
        args: args
      });
    };
    THREE.Path.prototype.lineTo = function(x, y) {
      var args = Array.prototype.slice.call(arguments);
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var curve = new THREE.LineCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(x, y));
      this.curves.push(curve);
      this.actions.push({
        action: THREE.PathActions.LINE_TO,
        args: args
      });
    };
    THREE.Path.prototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
      var args = Array.prototype.slice.call(arguments);
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var curve = new THREE.QuadraticBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCPx, aCPy), new THREE.Vector2(aX, aY));
      this.curves.push(curve);
      this.actions.push({
        action: THREE.PathActions.QUADRATIC_CURVE_TO,
        args: args
      });
    };
    THREE.Path.prototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      var args = Array.prototype.slice.call(arguments);
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var curve = new THREE.CubicBezierCurve(new THREE.Vector2(x0, y0), new THREE.Vector2(aCP1x, aCP1y), new THREE.Vector2(aCP2x, aCP2y), new THREE.Vector2(aX, aY));
      this.curves.push(curve);
      this.actions.push({
        action: THREE.PathActions.BEZIER_CURVE_TO,
        args: args
      });
    };
    THREE.Path.prototype.splineThru = function(pts) {
      var args = Array.prototype.slice.call(arguments);
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      var npts = [new THREE.Vector2(x0, y0)];
      Array.prototype.push.apply(npts, pts);
      var curve = new THREE.SplineCurve(npts);
      this.curves.push(curve);
      this.actions.push({
        action: THREE.PathActions.CSPLINE_THRU,
        args: args
      });
    };
    THREE.Path.prototype.arc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.Path.prototype.absarc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.Path.prototype.ellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
      var lastargs = this.actions[this.actions.length - 1].args;
      var x0 = lastargs[lastargs.length - 2];
      var y0 = lastargs[lastargs.length - 1];
      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.Path.prototype.absellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
      var args = Array.prototype.slice.call(arguments);
      var curve = new THREE.EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise);
      this.curves.push(curve);
      var lastPoint = curve.getPoint(1);
      args.push(lastPoint.x);
      args.push(lastPoint.y);
      this.actions.push({
        action: THREE.PathActions.ELLIPSE,
        args: args
      });
    };
    THREE.Path.prototype.getSpacedPoints = function(divisions, closedPath) {
      if (!divisions)
        divisions = 40;
      var points = [];
      for (var i = 0; i < divisions; i++) {
        points.push(this.getPoint(i / divisions));
      }
      return points;
    };
    THREE.Path.prototype.getPoints = function(divisions, closedPath) {
      if (this.useSpacedPoints) {
        console.log('tata');
        return this.getSpacedPoints(divisions, closedPath);
      }
      divisions = divisions || 12;
      var points = [];
      var i,
          il,
          item,
          action,
          args;
      var cpx,
          cpy,
          cpx2,
          cpy2,
          cpx1,
          cpy1,
          cpx0,
          cpy0,
          laste,
          j,
          t,
          tx,
          ty;
      for (i = 0, il = this.actions.length; i < il; i++) {
        item = this.actions[i];
        action = item.action;
        args = item.args;
        switch (action) {
          case THREE.PathActions.MOVE_TO:
            points.push(new THREE.Vector2(args[0], args[1]));
            break;
          case THREE.PathActions.LINE_TO:
            points.push(new THREE.Vector2(args[0], args[1]));
            break;
          case THREE.PathActions.QUADRATIC_CURVE_TO:
            cpx = args[2];
            cpy = args[3];
            cpx1 = args[0];
            cpy1 = args[1];
            if (points.length > 0) {
              laste = points[points.length - 1];
              cpx0 = laste.x;
              cpy0 = laste.y;
            } else {
              laste = this.actions[i - 1].args;
              cpx0 = laste[laste.length - 2];
              cpy0 = laste[laste.length - 1];
            }
            for (j = 1; j <= divisions; j++) {
              t = j / divisions;
              tx = THREE.Shape.Utils.b2(t, cpx0, cpx1, cpx);
              ty = THREE.Shape.Utils.b2(t, cpy0, cpy1, cpy);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
          case THREE.PathActions.BEZIER_CURVE_TO:
            cpx = args[4];
            cpy = args[5];
            cpx1 = args[0];
            cpy1 = args[1];
            cpx2 = args[2];
            cpy2 = args[3];
            if (points.length > 0) {
              laste = points[points.length - 1];
              cpx0 = laste.x;
              cpy0 = laste.y;
            } else {
              laste = this.actions[i - 1].args;
              cpx0 = laste[laste.length - 2];
              cpy0 = laste[laste.length - 1];
            }
            for (j = 1; j <= divisions; j++) {
              t = j / divisions;
              tx = THREE.Shape.Utils.b3(t, cpx0, cpx1, cpx2, cpx);
              ty = THREE.Shape.Utils.b3(t, cpy0, cpy1, cpy2, cpy);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
          case THREE.PathActions.CSPLINE_THRU:
            laste = this.actions[i - 1].args;
            var last = new THREE.Vector2(laste[laste.length - 2], laste[laste.length - 1]);
            var spts = [last];
            var n = divisions * args[0].length;
            spts = spts.concat(args[0]);
            var spline = new THREE.SplineCurve(spts);
            for (j = 1; j <= n; j++) {
              points.push(spline.getPointAt(j / n));
            }
            break;
          case THREE.PathActions.ARC:
            var aX = args[0],
                aY = args[1],
                aRadius = args[2],
                aStartAngle = args[3],
                aEndAngle = args[4],
                aClockwise = !!args[5];
            var deltaAngle = aEndAngle - aStartAngle;
            var angle;
            var tdivisions = divisions * 2;
            for (j = 1; j <= tdivisions; j++) {
              t = j / tdivisions;
              if (!aClockwise) {
                t = 1 - t;
              }
              angle = aStartAngle + t * deltaAngle;
              tx = aX + aRadius * Math.cos(angle);
              ty = aY + aRadius * Math.sin(angle);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
          case THREE.PathActions.ELLIPSE:
            var aX = args[0],
                aY = args[1],
                xRadius = args[2],
                yRadius = args[3],
                aStartAngle = args[4],
                aEndAngle = args[5],
                aClockwise = !!args[6];
            var deltaAngle = aEndAngle - aStartAngle;
            var angle;
            var tdivisions = divisions * 2;
            for (j = 1; j <= tdivisions; j++) {
              t = j / tdivisions;
              if (!aClockwise) {
                t = 1 - t;
              }
              angle = aStartAngle + t * deltaAngle;
              tx = aX + xRadius * Math.cos(angle);
              ty = aY + yRadius * Math.sin(angle);
              points.push(new THREE.Vector2(tx, ty));
            }
            break;
        }
      }
      var lastPoint = points[points.length - 1];
      var EPSILON = 0.0000000001;
      if (Math.abs(lastPoint.x - points[0].x) < EPSILON && Math.abs(lastPoint.y - points[0].y) < EPSILON)
        points.splice(points.length - 1, 1);
      if (closedPath) {
        points.push(points[0]);
      }
      return points;
    };
    THREE.Path.prototype.toShapes = function(isCCW, noHoles) {
      function extractSubpaths(inActions) {
        var i,
            il,
            item,
            action,
            args;
        var subPaths = [],
            lastPath = new THREE.Path();
        for (i = 0, il = inActions.length; i < il; i++) {
          item = inActions[i];
          args = item.args;
          action = item.action;
          if (action == THREE.PathActions.MOVE_TO) {
            if (lastPath.actions.length != 0) {
              subPaths.push(lastPath);
              lastPath = new THREE.Path();
            }
          }
          lastPath[action].apply(lastPath, args);
        }
        if (lastPath.actions.length != 0) {
          subPaths.push(lastPath);
        }
        return subPaths;
      }
      function toShapesNoHoles(inSubpaths) {
        var shapes = [];
        for (var i = 0,
            il = inSubpaths.length; i < il; i++) {
          var tmpPath = inSubpaths[i];
          var tmpShape = new THREE.Shape();
          tmpShape.actions = tmpPath.actions;
          tmpShape.curves = tmpPath.curves;
          shapes.push(tmpShape);
        }
        return shapes;
      }
      ;
      function isPointInsidePolygon(inPt, inPolygon) {
        var EPSILON = 0.0000000001;
        var polyLen = inPolygon.length;
        var inside = false;
        for (var p = polyLen - 1,
            q = 0; q < polyLen; p = q++) {
          var edgeLowPt = inPolygon[p];
          var edgeHighPt = inPolygon[q];
          var edgeDx = edgeHighPt.x - edgeLowPt.x;
          var edgeDy = edgeHighPt.y - edgeLowPt.y;
          if (Math.abs(edgeDy) > EPSILON) {
            if (edgeDy < 0) {
              edgeLowPt = inPolygon[q];
              edgeDx = -edgeDx;
              edgeHighPt = inPolygon[p];
              edgeDy = -edgeDy;
            }
            if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
              continue;
            if (inPt.y == edgeLowPt.y) {
              if (inPt.x == edgeLowPt.x)
                return true;
            } else {
              var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
              if (perpEdge == 0)
                return true;
              if (perpEdge < 0)
                continue;
              inside = !inside;
            }
          } else {
            if (inPt.y != edgeLowPt.y)
              continue;
            if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) || ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))
              return true;
          }
        }
        return inside;
      }
      var subPaths = extractSubpaths(this.actions);
      if (subPaths.length == 0)
        return [];
      if (noHoles === true)
        return toShapesNoHoles(subPaths);
      var solid,
          tmpPath,
          tmpShape,
          shapes = [];
      if (subPaths.length == 1) {
        tmpPath = subPaths[0];
        tmpShape = new THREE.Shape();
        tmpShape.actions = tmpPath.actions;
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        return shapes;
      }
      var holesFirst = !THREE.Shape.Utils.isClockWise(subPaths[0].getPoints());
      holesFirst = isCCW ? !holesFirst : holesFirst;
      var betterShapeHoles = [];
      var newShapes = [];
      var newShapeHoles = [];
      var mainIdx = 0;
      var tmpPoints;
      newShapes[mainIdx] = undefined;
      newShapeHoles[mainIdx] = [];
      var i,
          il;
      for (i = 0, il = subPaths.length; i < il; i++) {
        tmpPath = subPaths[i];
        tmpPoints = tmpPath.getPoints();
        solid = THREE.Shape.Utils.isClockWise(tmpPoints);
        solid = isCCW ? !solid : solid;
        if (solid) {
          if ((!holesFirst) && (newShapes[mainIdx]))
            mainIdx++;
          newShapes[mainIdx] = {
            s: new THREE.Shape(),
            p: tmpPoints
          };
          newShapes[mainIdx].s.actions = tmpPath.actions;
          newShapes[mainIdx].s.curves = tmpPath.curves;
          if (holesFirst)
            mainIdx++;
          newShapeHoles[mainIdx] = [];
        } else {
          newShapeHoles[mainIdx].push({
            h: tmpPath,
            p: tmpPoints[0]
          });
        }
      }
      if (!newShapes[0])
        return toShapesNoHoles(subPaths);
      if (newShapes.length > 1) {
        var ambigious = false;
        var toChange = [];
        for (var sIdx = 0,
            sLen = newShapes.length; sIdx < sLen; sIdx++) {
          betterShapeHoles[sIdx] = [];
        }
        for (var sIdx = 0,
            sLen = newShapes.length; sIdx < sLen; sIdx++) {
          var sho = newShapeHoles[sIdx];
          for (var hIdx = 0; hIdx < sho.length; hIdx++) {
            var ho = sho[hIdx];
            var hole_unassigned = true;
            for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
              if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                if (sIdx != s2Idx)
                  toChange.push({
                    froms: sIdx,
                    tos: s2Idx,
                    hole: hIdx
                  });
                if (hole_unassigned) {
                  hole_unassigned = false;
                  betterShapeHoles[s2Idx].push(ho);
                } else {
                  ambigious = true;
                }
              }
            }
            if (hole_unassigned) {
              betterShapeHoles[sIdx].push(ho);
            }
          }
        }
        if (toChange.length > 0) {
          if (!ambigious)
            newShapeHoles = betterShapeHoles;
        }
      }
      var tmpHoles,
          j,
          jl;
      for (i = 0, il = newShapes.length; i < il; i++) {
        tmpShape = newShapes[i].s;
        shapes.push(tmpShape);
        tmpHoles = newShapeHoles[i];
        for (j = 0, jl = tmpHoles.length; j < jl; j++) {
          tmpShape.holes.push(tmpHoles[j].h);
        }
      }
      return shapes;
    };
    THREE.Shape = function() {
      THREE.Path.apply(this, arguments);
      this.holes = [];
    };
    THREE.Shape.prototype = Object.create(THREE.Path.prototype);
    THREE.Shape.prototype.constructor = THREE.Shape;
    THREE.Shape.prototype.extrude = function(options) {
      var extruded = new THREE.ExtrudeGeometry(this, options);
      return extruded;
    };
    THREE.Shape.prototype.makeGeometry = function(options) {
      var geometry = new THREE.ShapeGeometry(this, options);
      return geometry;
    };
    THREE.Shape.prototype.getPointsHoles = function(divisions) {
      var i,
          il = this.holes.length,
          holesPts = [];
      for (i = 0; i < il; i++) {
        holesPts[i] = this.holes[i].getTransformedPoints(divisions, this.bends);
      }
      return holesPts;
    };
    THREE.Shape.prototype.getSpacedPointsHoles = function(divisions) {
      var i,
          il = this.holes.length,
          holesPts = [];
      for (i = 0; i < il; i++) {
        holesPts[i] = this.holes[i].getTransformedSpacedPoints(divisions, this.bends);
      }
      return holesPts;
    };
    THREE.Shape.prototype.extractAllPoints = function(divisions) {
      return {
        shape: this.getTransformedPoints(divisions),
        holes: this.getPointsHoles(divisions)
      };
    };
    THREE.Shape.prototype.extractPoints = function(divisions) {
      if (this.useSpacedPoints) {
        return this.extractAllSpacedPoints(divisions);
      }
      return this.extractAllPoints(divisions);
    };
    THREE.Shape.prototype.extractAllSpacedPoints = function(divisions) {
      return {
        shape: this.getTransformedSpacedPoints(divisions),
        holes: this.getSpacedPointsHoles(divisions)
      };
    };
    THREE.Shape.Utils = {
      triangulateShape: function(contour, holes) {
        function point_in_segment_2D_colin(inSegPt1, inSegPt2, inOtherPt) {
          if (inSegPt1.x != inSegPt2.x) {
            if (inSegPt1.x < inSegPt2.x) {
              return ((inSegPt1.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt2.x));
            } else {
              return ((inSegPt2.x <= inOtherPt.x) && (inOtherPt.x <= inSegPt1.x));
            }
          } else {
            if (inSegPt1.y < inSegPt2.y) {
              return ((inSegPt1.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt2.y));
            } else {
              return ((inSegPt2.y <= inOtherPt.y) && (inOtherPt.y <= inSegPt1.y));
            }
          }
        }
        function intersect_segments_2D(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs) {
          var EPSILON = 0.0000000001;
          var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,
              seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
          var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,
              seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
          var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
          var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
          var limit = seg1dy * seg2dx - seg1dx * seg2dy;
          var perpSeg1 = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
          if (Math.abs(limit) > EPSILON) {
            var perpSeg2;
            if (limit > 0) {
              if ((perpSeg1 < 0) || (perpSeg1 > limit))
                return [];
              perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
              if ((perpSeg2 < 0) || (perpSeg2 > limit))
                return [];
            } else {
              if ((perpSeg1 > 0) || (perpSeg1 < limit))
                return [];
              perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
              if ((perpSeg2 > 0) || (perpSeg2 < limit))
                return [];
            }
            if (perpSeg2 == 0) {
              if ((inExcludeAdjacentSegs) && ((perpSeg1 == 0) || (perpSeg1 == limit)))
                return [];
              return [inSeg1Pt1];
            }
            if (perpSeg2 == limit) {
              if ((inExcludeAdjacentSegs) && ((perpSeg1 == 0) || (perpSeg1 == limit)))
                return [];
              return [inSeg1Pt2];
            }
            if (perpSeg1 == 0)
              return [inSeg2Pt1];
            if (perpSeg1 == limit)
              return [inSeg2Pt2];
            var factorSeg1 = perpSeg2 / limit;
            return [{
              x: inSeg1Pt1.x + factorSeg1 * seg1dx,
              y: inSeg1Pt1.y + factorSeg1 * seg1dy
            }];
          } else {
            if ((perpSeg1 != 0) || (seg2dy * seg1seg2dx != seg2dx * seg1seg2dy))
              return [];
            var seg1Pt = ((seg1dx == 0) && (seg1dy == 0));
            var seg2Pt = ((seg2dx == 0) && (seg2dy == 0));
            if (seg1Pt && seg2Pt) {
              if ((inSeg1Pt1.x != inSeg2Pt1.x) || (inSeg1Pt1.y != inSeg2Pt1.y))
                return [];
              return [inSeg1Pt1];
            }
            if (seg1Pt) {
              if (!point_in_segment_2D_colin(inSeg2Pt1, inSeg2Pt2, inSeg1Pt1))
                return [];
              return [inSeg1Pt1];
            }
            if (seg2Pt) {
              if (!point_in_segment_2D_colin(inSeg1Pt1, inSeg1Pt2, inSeg2Pt1))
                return [];
              return [inSeg2Pt1];
            }
            var seg1min,
                seg1max,
                seg1minVal,
                seg1maxVal;
            var seg2min,
                seg2max,
                seg2minVal,
                seg2maxVal;
            if (seg1dx != 0) {
              if (inSeg1Pt1.x < inSeg1Pt2.x) {
                seg1min = inSeg1Pt1;
                seg1minVal = inSeg1Pt1.x;
                seg1max = inSeg1Pt2;
                seg1maxVal = inSeg1Pt2.x;
              } else {
                seg1min = inSeg1Pt2;
                seg1minVal = inSeg1Pt2.x;
                seg1max = inSeg1Pt1;
                seg1maxVal = inSeg1Pt1.x;
              }
              if (inSeg2Pt1.x < inSeg2Pt2.x) {
                seg2min = inSeg2Pt1;
                seg2minVal = inSeg2Pt1.x;
                seg2max = inSeg2Pt2;
                seg2maxVal = inSeg2Pt2.x;
              } else {
                seg2min = inSeg2Pt2;
                seg2minVal = inSeg2Pt2.x;
                seg2max = inSeg2Pt1;
                seg2maxVal = inSeg2Pt1.x;
              }
            } else {
              if (inSeg1Pt1.y < inSeg1Pt2.y) {
                seg1min = inSeg1Pt1;
                seg1minVal = inSeg1Pt1.y;
                seg1max = inSeg1Pt2;
                seg1maxVal = inSeg1Pt2.y;
              } else {
                seg1min = inSeg1Pt2;
                seg1minVal = inSeg1Pt2.y;
                seg1max = inSeg1Pt1;
                seg1maxVal = inSeg1Pt1.y;
              }
              if (inSeg2Pt1.y < inSeg2Pt2.y) {
                seg2min = inSeg2Pt1;
                seg2minVal = inSeg2Pt1.y;
                seg2max = inSeg2Pt2;
                seg2maxVal = inSeg2Pt2.y;
              } else {
                seg2min = inSeg2Pt2;
                seg2minVal = inSeg2Pt2.y;
                seg2max = inSeg2Pt1;
                seg2maxVal = inSeg2Pt1.y;
              }
            }
            if (seg1minVal <= seg2minVal) {
              if (seg1maxVal < seg2minVal)
                return [];
              if (seg1maxVal == seg2minVal) {
                if (inExcludeAdjacentSegs)
                  return [];
                return [seg2min];
              }
              if (seg1maxVal <= seg2maxVal)
                return [seg2min, seg1max];
              return [seg2min, seg2max];
            } else {
              if (seg1minVal > seg2maxVal)
                return [];
              if (seg1minVal == seg2maxVal) {
                if (inExcludeAdjacentSegs)
                  return [];
                return [seg1min];
              }
              if (seg1maxVal <= seg2maxVal)
                return [seg1min, seg1max];
              return [seg1min, seg2max];
            }
          }
        }
        function isPointInsideAngle(inVertex, inLegFromPt, inLegToPt, inOtherPt) {
          var EPSILON = 0.0000000001;
          var legFromPtX = inLegFromPt.x - inVertex.x,
              legFromPtY = inLegFromPt.y - inVertex.y;
          var legToPtX = inLegToPt.x - inVertex.x,
              legToPtY = inLegToPt.y - inVertex.y;
          var otherPtX = inOtherPt.x - inVertex.x,
              otherPtY = inOtherPt.y - inVertex.y;
          var from2toAngle = legFromPtX * legToPtY - legFromPtY * legToPtX;
          var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;
          if (Math.abs(from2toAngle) > EPSILON) {
            var other2toAngle = otherPtX * legToPtY - otherPtY * legToPtX;
            if (from2toAngle > 0) {
              return ((from2otherAngle >= 0) && (other2toAngle >= 0));
            } else {
              return ((from2otherAngle >= 0) || (other2toAngle >= 0));
            }
          } else {
            return (from2otherAngle > 0);
          }
        }
        function removeHoles(contour, holes) {
          var shape = contour.concat();
          var hole;
          function isCutLineInsideAngles(inShapeIdx, inHoleIdx) {
            var lastShapeIdx = shape.length - 1;
            var prevShapeIdx = inShapeIdx - 1;
            if (prevShapeIdx < 0)
              prevShapeIdx = lastShapeIdx;
            var nextShapeIdx = inShapeIdx + 1;
            if (nextShapeIdx > lastShapeIdx)
              nextShapeIdx = 0;
            var insideAngle = isPointInsideAngle(shape[inShapeIdx], shape[prevShapeIdx], shape[nextShapeIdx], hole[inHoleIdx]);
            if (!insideAngle) {
              return false;
            }
            var lastHoleIdx = hole.length - 1;
            var prevHoleIdx = inHoleIdx - 1;
            if (prevHoleIdx < 0)
              prevHoleIdx = lastHoleIdx;
            var nextHoleIdx = inHoleIdx + 1;
            if (nextHoleIdx > lastHoleIdx)
              nextHoleIdx = 0;
            insideAngle = isPointInsideAngle(hole[inHoleIdx], hole[prevHoleIdx], hole[nextHoleIdx], shape[inShapeIdx]);
            if (!insideAngle) {
              return false;
            }
            return true;
          }
          function intersectsShapeEdge(inShapePt, inHolePt) {
            var sIdx,
                nextIdx,
                intersection;
            for (sIdx = 0; sIdx < shape.length; sIdx++) {
              nextIdx = sIdx + 1;
              nextIdx %= shape.length;
              intersection = intersect_segments_2D(inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true);
              if (intersection.length > 0)
                return true;
            }
            return false;
          }
          var indepHoles = [];
          function intersectsHoleEdge(inShapePt, inHolePt) {
            var ihIdx,
                chkHole,
                hIdx,
                nextIdx,
                intersection;
            for (ihIdx = 0; ihIdx < indepHoles.length; ihIdx++) {
              chkHole = holes[indepHoles[ihIdx]];
              for (hIdx = 0; hIdx < chkHole.length; hIdx++) {
                nextIdx = hIdx + 1;
                nextIdx %= chkHole.length;
                intersection = intersect_segments_2D(inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true);
                if (intersection.length > 0)
                  return true;
              }
            }
            return false;
          }
          var holeIndex,
              shapeIndex,
              shapePt,
              holePt,
              holeIdx,
              cutKey,
              failedCuts = [],
              tmpShape1,
              tmpShape2,
              tmpHole1,
              tmpHole2;
          for (var h = 0,
              hl = holes.length; h < hl; h++) {
            indepHoles.push(h);
          }
          var minShapeIndex = 0;
          var counter = indepHoles.length * 2;
          while (indepHoles.length > 0) {
            counter--;
            if (counter < 0) {
              console.log("Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!");
              break;
            }
            for (shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex++) {
              shapePt = shape[shapeIndex];
              holeIndex = -1;
              for (var h = 0; h < indepHoles.length; h++) {
                holeIdx = indepHoles[h];
                cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
                if (failedCuts[cutKey] !== undefined)
                  continue;
                hole = holes[holeIdx];
                for (var h2 = 0; h2 < hole.length; h2++) {
                  holePt = hole[h2];
                  if (!isCutLineInsideAngles(shapeIndex, h2))
                    continue;
                  if (intersectsShapeEdge(shapePt, holePt))
                    continue;
                  if (intersectsHoleEdge(shapePt, holePt))
                    continue;
                  holeIndex = h2;
                  indepHoles.splice(h, 1);
                  tmpShape1 = shape.slice(0, shapeIndex + 1);
                  tmpShape2 = shape.slice(shapeIndex);
                  tmpHole1 = hole.slice(holeIndex);
                  tmpHole2 = hole.slice(0, holeIndex + 1);
                  shape = tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);
                  minShapeIndex = shapeIndex;
                  break;
                }
                if (holeIndex >= 0)
                  break;
                failedCuts[cutKey] = true;
              }
              if (holeIndex >= 0)
                break;
            }
          }
          return shape;
        }
        var i,
            il,
            f,
            face,
            key,
            index,
            allPointsMap = {};
        var allpoints = contour.concat();
        for (var h = 0,
            hl = holes.length; h < hl; h++) {
          Array.prototype.push.apply(allpoints, holes[h]);
        }
        for (i = 0, il = allpoints.length; i < il; i++) {
          key = allpoints[i].x + ":" + allpoints[i].y;
          if (allPointsMap[key] !== undefined) {
            THREE.warn("THREE.Shape: Duplicate point", key);
          }
          allPointsMap[key] = i;
        }
        var shapeWithoutHoles = removeHoles(contour, holes);
        var triangles = THREE.FontUtils.Triangulate(shapeWithoutHoles, false);
        for (i = 0, il = triangles.length; i < il; i++) {
          face = triangles[i];
          for (f = 0; f < 3; f++) {
            key = face[f].x + ":" + face[f].y;
            index = allPointsMap[key];
            if (index !== undefined) {
              face[f] = index;
            }
          }
        }
        return triangles.concat();
      },
      isClockWise: function(pts) {
        return THREE.FontUtils.Triangulate.area(pts) < 0;
      },
      b2p0: function(t, p) {
        var k = 1 - t;
        return k * k * p;
      },
      b2p1: function(t, p) {
        return 2 * (1 - t) * t * p;
      },
      b2p2: function(t, p) {
        return t * t * p;
      },
      b2: function(t, p0, p1, p2) {
        return this.b2p0(t, p0) + this.b2p1(t, p1) + this.b2p2(t, p2);
      },
      b3p0: function(t, p) {
        var k = 1 - t;
        return k * k * k * p;
      },
      b3p1: function(t, p) {
        var k = 1 - t;
        return 3 * k * k * t * p;
      },
      b3p2: function(t, p) {
        var k = 1 - t;
        return 3 * k * t * t * p;
      },
      b3p3: function(t, p) {
        return t * t * t * p;
      },
      b3: function(t, p0, p1, p2, p3) {
        return this.b3p0(t, p0) + this.b3p1(t, p1) + this.b3p2(t, p2) + this.b3p3(t, p3);
      }
    };
    THREE.LineCurve = function(v1, v2) {
      this.v1 = v1;
      this.v2 = v2;
    };
    THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.LineCurve.prototype.constructor = THREE.LineCurve;
    THREE.LineCurve.prototype.getPoint = function(t) {
      var point = this.v2.clone().sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
      return point;
    };
    THREE.LineCurve.prototype.getPointAt = function(u) {
      return this.getPoint(u);
    };
    THREE.LineCurve.prototype.getTangent = function(t) {
      var tangent = this.v2.clone().sub(this.v1);
      return tangent.normalize();
    };
    THREE.QuadraticBezierCurve = function(v0, v1, v2) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    };
    THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
    THREE.QuadraticBezierCurve.prototype.getPoint = function(t) {
      var vector = new THREE.Vector2();
      vector.x = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);
      vector.y = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);
      return vector;
    };
    THREE.QuadraticBezierCurve.prototype.getTangent = function(t) {
      var vector = new THREE.Vector2();
      vector.x = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.x, this.v1.x, this.v2.x);
      vector.y = THREE.Curve.Utils.tangentQuadraticBezier(t, this.v0.y, this.v1.y, this.v2.y);
      return vector.normalize();
    };
    THREE.CubicBezierCurve = function(v0, v1, v2, v3) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    };
    THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
    THREE.CubicBezierCurve.prototype.getPoint = function(t) {
      var tx,
          ty;
      tx = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
      ty = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
      return new THREE.Vector2(tx, ty);
    };
    THREE.CubicBezierCurve.prototype.getTangent = function(t) {
      var tx,
          ty;
      tx = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
      ty = THREE.Curve.Utils.tangentCubicBezier(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
      var tangent = new THREE.Vector2(tx, ty);
      tangent.normalize();
      return tangent;
    };
    THREE.SplineCurve = function(points) {
      this.points = (points == undefined) ? [] : points;
    };
    THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
    THREE.SplineCurve.prototype.getPoint = function(t) {
      var points = this.points;
      var point = (points.length - 1) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
      var point1 = points[intPoint];
      var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      var vector = new THREE.Vector2();
      vector.x = THREE.Curve.Utils.interpolate(point0.x, point1.x, point2.x, point3.x, weight);
      vector.y = THREE.Curve.Utils.interpolate(point0.y, point1.y, point2.y, point3.y, weight);
      return vector;
    };
    THREE.EllipseCurve = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise) {
      this.aX = aX;
      this.aY = aY;
      this.xRadius = xRadius;
      this.yRadius = yRadius;
      this.aStartAngle = aStartAngle;
      this.aEndAngle = aEndAngle;
      this.aClockwise = aClockwise;
    };
    THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
    THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
    THREE.EllipseCurve.prototype.getPoint = function(t) {
      var deltaAngle = this.aEndAngle - this.aStartAngle;
      if (deltaAngle < 0)
        deltaAngle += Math.PI * 2;
      if (deltaAngle > Math.PI * 2)
        deltaAngle -= Math.PI * 2;
      var angle;
      if (this.aClockwise === true) {
        angle = this.aEndAngle + (1 - t) * (Math.PI * 2 - deltaAngle);
      } else {
        angle = this.aStartAngle + t * deltaAngle;
      }
      var vector = new THREE.Vector2();
      vector.x = this.aX + this.xRadius * Math.cos(angle);
      vector.y = this.aY + this.yRadius * Math.sin(angle);
      return vector;
    };
    THREE.ArcCurve = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      THREE.EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    };
    THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
    THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
    THREE.LineCurve3 = THREE.Curve.create(function(v1, v2) {
      this.v1 = v1;
      this.v2 = v2;
    }, function(t) {
      var vector = new THREE.Vector3();
      vector.subVectors(this.v2, this.v1);
      vector.multiplyScalar(t);
      vector.add(this.v1);
      return vector;
    });
    THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(v0, v1, v2) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    }, function(t) {
      var vector = new THREE.Vector3();
      vector.x = THREE.Shape.Utils.b2(t, this.v0.x, this.v1.x, this.v2.x);
      vector.y = THREE.Shape.Utils.b2(t, this.v0.y, this.v1.y, this.v2.y);
      vector.z = THREE.Shape.Utils.b2(t, this.v0.z, this.v1.z, this.v2.z);
      return vector;
    });
    THREE.CubicBezierCurve3 = THREE.Curve.create(function(v0, v1, v2, v3) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }, function(t) {
      var vector = new THREE.Vector3();
      vector.x = THREE.Shape.Utils.b3(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
      vector.y = THREE.Shape.Utils.b3(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
      vector.z = THREE.Shape.Utils.b3(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z);
      return vector;
    });
    THREE.SplineCurve3 = THREE.Curve.create(function(points) {
      this.points = (points == undefined) ? [] : points;
    }, function(t) {
      var points = this.points;
      var point = (points.length - 1) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      var point0 = points[intPoint == 0 ? intPoint : intPoint - 1];
      var point1 = points[intPoint];
      var point2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      var point3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      var vector = new THREE.Vector3();
      vector.x = THREE.Curve.Utils.interpolate(point0.x, point1.x, point2.x, point3.x, weight);
      vector.y = THREE.Curve.Utils.interpolate(point0.y, point1.y, point2.y, point3.y, weight);
      vector.z = THREE.Curve.Utils.interpolate(point0.z, point1.z, point2.z, point3.z, weight);
      return vector;
    });
    THREE.ClosedSplineCurve3 = THREE.Curve.create(function(points) {
      this.points = (points == undefined) ? [] : points;
    }, function(t) {
      var points = this.points;
      var point = (points.length - 0) * t;
      var intPoint = Math.floor(point);
      var weight = point - intPoint;
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / points.length) + 1) * points.length;
      var point0 = points[(intPoint - 1) % points.length];
      var point1 = points[(intPoint) % points.length];
      var point2 = points[(intPoint + 1) % points.length];
      var point3 = points[(intPoint + 2) % points.length];
      var vector = new THREE.Vector3();
      vector.x = THREE.Curve.Utils.interpolate(point0.x, point1.x, point2.x, point3.x, weight);
      vector.y = THREE.Curve.Utils.interpolate(point0.y, point1.y, point2.y, point3.y, weight);
      vector.z = THREE.Curve.Utils.interpolate(point0.z, point1.z, point2.z, point3.z, weight);
      return vector;
    });
    THREE.AnimationHandler = {
      LINEAR: 0,
      CATMULLROM: 1,
      CATMULLROM_FORWARD: 2,
      add: function() {
        THREE.warn('THREE.AnimationHandler.add() has been deprecated.');
      },
      get: function() {
        THREE.warn('THREE.AnimationHandler.get() has been deprecated.');
      },
      remove: function() {
        THREE.warn('THREE.AnimationHandler.remove() has been deprecated.');
      },
      animations: [],
      init: function(data) {
        if (data.initialized === true)
          return data;
        for (var h = 0; h < data.hierarchy.length; h++) {
          for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
            if (data.hierarchy[h].keys[k].time < 0) {
              data.hierarchy[h].keys[k].time = 0;
            }
            if (data.hierarchy[h].keys[k].rot !== undefined && !(data.hierarchy[h].keys[k].rot instanceof THREE.Quaternion)) {
              var quat = data.hierarchy[h].keys[k].rot;
              data.hierarchy[h].keys[k].rot = new THREE.Quaternion().fromArray(quat);
            }
          }
          if (data.hierarchy[h].keys.length && data.hierarchy[h].keys[0].morphTargets !== undefined) {
            var usedMorphTargets = {};
            for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
              for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {
                var morphTargetName = data.hierarchy[h].keys[k].morphTargets[m];
                usedMorphTargets[morphTargetName] = -1;
              }
            }
            data.hierarchy[h].usedMorphTargets = usedMorphTargets;
            for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
              var influences = {};
              for (var morphTargetName in usedMorphTargets) {
                for (var m = 0; m < data.hierarchy[h].keys[k].morphTargets.length; m++) {
                  if (data.hierarchy[h].keys[k].morphTargets[m] === morphTargetName) {
                    influences[morphTargetName] = data.hierarchy[h].keys[k].morphTargetsInfluences[m];
                    break;
                  }
                }
                if (m === data.hierarchy[h].keys[k].morphTargets.length) {
                  influences[morphTargetName] = 0;
                }
              }
              data.hierarchy[h].keys[k].morphTargetsInfluences = influences;
            }
          }
          for (var k = 1; k < data.hierarchy[h].keys.length; k++) {
            if (data.hierarchy[h].keys[k].time === data.hierarchy[h].keys[k - 1].time) {
              data.hierarchy[h].keys.splice(k, 1);
              k--;
            }
          }
          for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
            data.hierarchy[h].keys[k].index = k;
          }
        }
        data.initialized = true;
        return data;
      },
      parse: function(root) {
        var parseRecurseHierarchy = function(root, hierarchy) {
          hierarchy.push(root);
          for (var c = 0; c < root.children.length; c++)
            parseRecurseHierarchy(root.children[c], hierarchy);
        };
        var hierarchy = [];
        if (root instanceof THREE.SkinnedMesh) {
          for (var b = 0; b < root.skeleton.bones.length; b++) {
            hierarchy.push(root.skeleton.bones[b]);
          }
        } else {
          parseRecurseHierarchy(root, hierarchy);
        }
        return hierarchy;
      },
      play: function(animation) {
        if (this.animations.indexOf(animation) === -1) {
          this.animations.push(animation);
        }
      },
      stop: function(animation) {
        var index = this.animations.indexOf(animation);
        if (index !== -1) {
          this.animations.splice(index, 1);
        }
      },
      update: function(deltaTimeMS) {
        for (var i = 0; i < this.animations.length; i++) {
          this.animations[i].resetBlendWeights();
        }
        for (var i = 0; i < this.animations.length; i++) {
          this.animations[i].update(deltaTimeMS);
        }
      }
    };
    THREE.Animation = function(root, data) {
      this.root = root;
      this.data = THREE.AnimationHandler.init(data);
      this.hierarchy = THREE.AnimationHandler.parse(root);
      this.currentTime = 0;
      this.timeScale = 1;
      this.isPlaying = false;
      this.loop = true;
      this.weight = 0;
      this.interpolationType = THREE.AnimationHandler.LINEAR;
    };
    THREE.Animation.prototype = {
      constructor: THREE.Animation,
      keyTypes: ["pos", "rot", "scl"],
      play: function(startTime, weight) {
        this.currentTime = startTime !== undefined ? startTime : 0;
        this.weight = weight !== undefined ? weight : 1;
        this.isPlaying = true;
        this.reset();
        THREE.AnimationHandler.play(this);
      },
      stop: function() {
        this.isPlaying = false;
        THREE.AnimationHandler.stop(this);
      },
      reset: function() {
        for (var h = 0,
            hl = this.hierarchy.length; h < hl; h++) {
          var object = this.hierarchy[h];
          if (object.animationCache === undefined) {
            object.animationCache = {
              animations: {},
              blending: {
                positionWeight: 0.0,
                quaternionWeight: 0.0,
                scaleWeight: 0.0
              }
            };
          }
          var name = this.data.name;
          var animations = object.animationCache.animations;
          var animationCache = animations[name];
          if (animationCache === undefined) {
            animationCache = {
              prevKey: {
                pos: 0,
                rot: 0,
                scl: 0
              },
              nextKey: {
                pos: 0,
                rot: 0,
                scl: 0
              },
              originalMatrix: object.matrix
            };
            animations[name] = animationCache;
          }
          for (var t = 0; t < 3; t++) {
            var type = this.keyTypes[t];
            var prevKey = this.data.hierarchy[h].keys[0];
            var nextKey = this.getNextKeyWith(type, h, 1);
            while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
              prevKey = nextKey;
              nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
            }
            animationCache.prevKey[type] = prevKey;
            animationCache.nextKey[type] = nextKey;
          }
        }
      },
      resetBlendWeights: function() {
        for (var h = 0,
            hl = this.hierarchy.length; h < hl; h++) {
          var object = this.hierarchy[h];
          var animationCache = object.animationCache;
          if (animationCache !== undefined) {
            var blending = animationCache.blending;
            blending.positionWeight = 0.0;
            blending.quaternionWeight = 0.0;
            blending.scaleWeight = 0.0;
          }
        }
      },
      update: (function() {
        var points = [];
        var target = new THREE.Vector3();
        var newVector = new THREE.Vector3();
        var newQuat = new THREE.Quaternion();
        var interpolateCatmullRom = function(points, scale) {
          var c = [],
              v3 = [],
              point,
              intPoint,
              weight,
              w2,
              w3,
              pa,
              pb,
              pc,
              pd;
          point = (points.length - 1) * scale;
          intPoint = Math.floor(point);
          weight = point - intPoint;
          c[0] = intPoint === 0 ? intPoint : intPoint - 1;
          c[1] = intPoint;
          c[2] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
          c[3] = intPoint > points.length - 3 ? intPoint : intPoint + 2;
          pa = points[c[0]];
          pb = points[c[1]];
          pc = points[c[2]];
          pd = points[c[3]];
          w2 = weight * weight;
          w3 = weight * w2;
          v3[0] = interpolate(pa[0], pb[0], pc[0], pd[0], weight, w2, w3);
          v3[1] = interpolate(pa[1], pb[1], pc[1], pd[1], weight, w2, w3);
          v3[2] = interpolate(pa[2], pb[2], pc[2], pd[2], weight, w2, w3);
          return v3;
        };
        var interpolate = function(p0, p1, p2, p3, t, t2, t3) {
          var v0 = (p2 - p0) * 0.5,
              v1 = (p3 - p1) * 0.5;
          return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
        };
        return function(delta) {
          if (this.isPlaying === false)
            return;
          this.currentTime += delta * this.timeScale;
          if (this.weight === 0)
            return;
          var duration = this.data.length;
          if (this.currentTime > duration || this.currentTime < 0) {
            if (this.loop) {
              this.currentTime %= duration;
              if (this.currentTime < 0)
                this.currentTime += duration;
              this.reset();
            } else {
              this.stop();
            }
          }
          for (var h = 0,
              hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache.animations[this.data.name];
            var blending = object.animationCache.blending;
            for (var t = 0; t < 3; t++) {
              var type = this.keyTypes[t];
              var prevKey = animationCache.prevKey[type];
              var nextKey = animationCache.nextKey[type];
              if ((this.timeScale > 0 && nextKey.time <= this.currentTime) || (this.timeScale < 0 && prevKey.time >= this.currentTime)) {
                prevKey = this.data.hierarchy[h].keys[0];
                nextKey = this.getNextKeyWith(type, h, 1);
                while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                  prevKey = nextKey;
                  nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                }
                animationCache.prevKey[type] = prevKey;
                animationCache.nextKey[type] = nextKey;
              }
              var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
              var prevXYZ = prevKey[type];
              var nextXYZ = nextKey[type];
              if (scale < 0)
                scale = 0;
              if (scale > 1)
                scale = 1;
              if (type === "pos") {
                if (this.interpolationType === THREE.AnimationHandler.LINEAR) {
                  newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                  newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                  newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                  var proportionalWeight = this.weight / (this.weight + blending.positionWeight);
                  object.position.lerp(newVector, proportionalWeight);
                  blending.positionWeight += this.weight;
                } else if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
                  points[0] = this.getPrevKeyWith("pos", h, prevKey.index - 1)["pos"];
                  points[1] = prevXYZ;
                  points[2] = nextXYZ;
                  points[3] = this.getNextKeyWith("pos", h, nextKey.index + 1)["pos"];
                  scale = scale * 0.33 + 0.33;
                  var currentPoint = interpolateCatmullRom(points, scale);
                  var proportionalWeight = this.weight / (this.weight + blending.positionWeight);
                  blending.positionWeight += this.weight;
                  var vector = object.position;
                  vector.x = vector.x + (currentPoint[0] - vector.x) * proportionalWeight;
                  vector.y = vector.y + (currentPoint[1] - vector.y) * proportionalWeight;
                  vector.z = vector.z + (currentPoint[2] - vector.z) * proportionalWeight;
                  if (this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
                    var forwardPoint = interpolateCatmullRom(points, scale * 1.01);
                    target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
                    target.sub(vector);
                    target.y = 0;
                    target.normalize();
                    var angle = Math.atan2(target.x, target.z);
                    object.rotation.set(0, angle, 0);
                  }
                }
              } else if (type === "rot") {
                THREE.Quaternion.slerp(prevXYZ, nextXYZ, newQuat, scale);
                if (blending.quaternionWeight === 0) {
                  object.quaternion.copy(newQuat);
                  blending.quaternionWeight = this.weight;
                } else {
                  var proportionalWeight = this.weight / (this.weight + blending.quaternionWeight);
                  THREE.Quaternion.slerp(object.quaternion, newQuat, object.quaternion, proportionalWeight);
                  blending.quaternionWeight += this.weight;
                }
              } else if (type === "scl") {
                newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                var proportionalWeight = this.weight / (this.weight + blending.scaleWeight);
                object.scale.lerp(newVector, proportionalWeight);
                blending.scaleWeight += this.weight;
              }
            }
          }
          return true;
        };
      })(),
      getNextKeyWith: function(type, h, key) {
        var keys = this.data.hierarchy[h].keys;
        if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
          key = key < keys.length - 1 ? key : keys.length - 1;
        } else {
          key = key % keys.length;
        }
        for (; key < keys.length; key++) {
          if (keys[key][type] !== undefined) {
            return keys[key];
          }
        }
        return this.data.hierarchy[h].keys[0];
      },
      getPrevKeyWith: function(type, h, key) {
        var keys = this.data.hierarchy[h].keys;
        if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) {
          key = key > 0 ? key : 0;
        } else {
          key = key >= 0 ? key : key + keys.length;
        }
        for (; key >= 0; key--) {
          if (keys[key][type] !== undefined) {
            return keys[key];
          }
        }
        return this.data.hierarchy[h].keys[keys.length - 1];
      }
    };
    THREE.KeyFrameAnimation = function(data) {
      this.root = data.node;
      this.data = THREE.AnimationHandler.init(data);
      this.hierarchy = THREE.AnimationHandler.parse(this.root);
      this.currentTime = 0;
      this.timeScale = 0.001;
      this.isPlaying = false;
      this.isPaused = true;
      this.loop = true;
      for (var h = 0,
          hl = this.hierarchy.length; h < hl; h++) {
        var keys = this.data.hierarchy[h].keys,
            sids = this.data.hierarchy[h].sids,
            obj = this.hierarchy[h];
        if (keys.length && sids) {
          for (var s = 0; s < sids.length; s++) {
            var sid = sids[s],
                next = this.getNextKeyWith(sid, h, 0);
            if (next) {
              next.apply(sid);
            }
          }
          obj.matrixAutoUpdate = false;
          this.data.hierarchy[h].node.updateMatrix();
          obj.matrixWorldNeedsUpdate = true;
        }
      }
    };
    THREE.KeyFrameAnimation.prototype = {
      constructor: THREE.KeyFrameAnimation,
      play: function(startTime) {
        this.currentTime = startTime !== undefined ? startTime : 0;
        if (this.isPlaying === false) {
          this.isPlaying = true;
          var h,
              hl = this.hierarchy.length,
              object,
              node;
          for (h = 0; h < hl; h++) {
            object = this.hierarchy[h];
            node = this.data.hierarchy[h];
            if (node.animationCache === undefined) {
              node.animationCache = {};
              node.animationCache.prevKey = null;
              node.animationCache.nextKey = null;
              node.animationCache.originalMatrix = object.matrix;
            }
            var keys = this.data.hierarchy[h].keys;
            if (keys.length) {
              node.animationCache.prevKey = keys[0];
              node.animationCache.nextKey = keys[1];
              this.startTime = Math.min(keys[0].time, this.startTime);
              this.endTime = Math.max(keys[keys.length - 1].time, this.endTime);
            }
          }
          this.update(0);
        }
        this.isPaused = false;
        THREE.AnimationHandler.play(this);
      },
      stop: function() {
        this.isPlaying = false;
        this.isPaused = false;
        THREE.AnimationHandler.stop(this);
        for (var h = 0; h < this.data.hierarchy.length; h++) {
          var obj = this.hierarchy[h];
          var node = this.data.hierarchy[h];
          if (node.animationCache !== undefined) {
            var original = node.animationCache.originalMatrix;
            original.copy(obj.matrix);
            obj.matrix = original;
            delete node.animationCache;
          }
        }
      },
      update: function(delta) {
        if (this.isPlaying === false)
          return;
        this.currentTime += delta * this.timeScale;
        var duration = this.data.length;
        if (this.loop === true && this.currentTime > duration) {
          this.currentTime %= duration;
        }
        this.currentTime = Math.min(this.currentTime, duration);
        for (var h = 0,
            hl = this.hierarchy.length; h < hl; h++) {
          var object = this.hierarchy[h];
          var node = this.data.hierarchy[h];
          var keys = node.keys,
              animationCache = node.animationCache;
          if (keys.length) {
            var prevKey = animationCache.prevKey;
            var nextKey = animationCache.nextKey;
            if (nextKey.time <= this.currentTime) {
              while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                prevKey = nextKey;
                nextKey = keys[prevKey.index + 1];
              }
              animationCache.prevKey = prevKey;
              animationCache.nextKey = nextKey;
            }
            if (nextKey.time >= this.currentTime) {
              prevKey.interpolate(nextKey, this.currentTime);
            } else {
              prevKey.interpolate(nextKey, nextKey.time);
            }
            this.data.hierarchy[h].node.updateMatrix();
            object.matrixWorldNeedsUpdate = true;
          }
        }
      },
      getNextKeyWith: function(sid, h, key) {
        var keys = this.data.hierarchy[h].keys;
        key = key % keys.length;
        for (; key < keys.length; key++) {
          if (keys[key].hasTarget(sid)) {
            return keys[key];
          }
        }
        return keys[0];
      },
      getPrevKeyWith: function(sid, h, key) {
        var keys = this.data.hierarchy[h].keys;
        key = key >= 0 ? key : key + keys.length;
        for (; key >= 0; key--) {
          if (keys[key].hasTarget(sid)) {
            return keys[key];
          }
        }
        return keys[keys.length - 1];
      }
    };
    THREE.MorphAnimation = function(mesh) {
      this.mesh = mesh;
      this.frames = mesh.morphTargetInfluences.length;
      this.currentTime = 0;
      this.duration = 1000;
      this.loop = true;
      this.lastFrame = 0;
      this.currentFrame = 0;
      this.isPlaying = false;
    };
    THREE.MorphAnimation.prototype = {
      constructor: THREE.MorphAnimation,
      play: function() {
        this.isPlaying = true;
      },
      pause: function() {
        this.isPlaying = false;
      },
      update: function(delta) {
        if (this.isPlaying === false)
          return;
        this.currentTime += delta;
        if (this.loop === true && this.currentTime > this.duration) {
          this.currentTime %= this.duration;
        }
        this.currentTime = Math.min(this.currentTime, this.duration);
        var interpolation = this.duration / this.frames;
        var frame = Math.floor(this.currentTime / interpolation);
        var influences = this.mesh.morphTargetInfluences;
        if (frame != this.currentFrame) {
          influences[this.lastFrame] = 0;
          influences[this.currentFrame] = 1;
          influences[frame] = 0;
          this.lastFrame = this.currentFrame;
          this.currentFrame = frame;
        }
        influences[frame] = (this.currentTime % interpolation) / interpolation;
        influences[this.lastFrame] = 1 - influences[frame];
      }
    };
    THREE.BoxGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
      THREE.Geometry.call(this);
      this.type = 'BoxGeometry';
      this.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
      };
      this.widthSegments = widthSegments || 1;
      this.heightSegments = heightSegments || 1;
      this.depthSegments = depthSegments || 1;
      var scope = this;
      var width_half = width / 2;
      var height_half = height / 2;
      var depth_half = depth / 2;
      buildPlane('z', 'y', -1, -1, depth, height, width_half, 0);
      buildPlane('z', 'y', 1, -1, depth, height, -width_half, 1);
      buildPlane('x', 'z', 1, 1, width, depth, height_half, 2);
      buildPlane('x', 'z', 1, -1, width, depth, -height_half, 3);
      buildPlane('x', 'y', 1, -1, width, height, depth_half, 4);
      buildPlane('x', 'y', -1, -1, width, height, -depth_half, 5);
      function buildPlane(u, v, udir, vdir, width, height, depth, materialIndex) {
        var w,
            ix,
            iy,
            gridX = scope.widthSegments,
            gridY = scope.heightSegments,
            width_half = width / 2,
            height_half = height / 2,
            offset = scope.vertices.length;
        if ((u === 'x' && v === 'y') || (u === 'y' && v === 'x')) {
          w = 'z';
        } else if ((u === 'x' && v === 'z') || (u === 'z' && v === 'x')) {
          w = 'y';
          gridY = scope.depthSegments;
        } else if ((u === 'z' && v === 'y') || (u === 'y' && v === 'z')) {
          w = 'x';
          gridX = scope.depthSegments;
        }
        var gridX1 = gridX + 1,
            gridY1 = gridY + 1,
            segment_width = width / gridX,
            segment_height = height / gridY,
            normal = new THREE.Vector3();
        normal[w] = depth > 0 ? 1 : -1;
        for (iy = 0; iy < gridY1; iy++) {
          for (ix = 0; ix < gridX1; ix++) {
            var vector = new THREE.Vector3();
            vector[u] = (ix * segment_width - width_half) * udir;
            vector[v] = (iy * segment_height - height_half) * vdir;
            vector[w] = depth;
            scope.vertices.push(vector);
          }
        }
        for (iy = 0; iy < gridY; iy++) {
          for (ix = 0; ix < gridX; ix++) {
            var a = ix + gridX1 * iy;
            var b = ix + gridX1 * (iy + 1);
            var c = (ix + 1) + gridX1 * (iy + 1);
            var d = (ix + 1) + gridX1 * iy;
            var uva = new THREE.Vector2(ix / gridX, 1 - iy / gridY);
            var uvb = new THREE.Vector2(ix / gridX, 1 - (iy + 1) / gridY);
            var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iy + 1) / gridY);
            var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iy / gridY);
            var face = new THREE.Face3(a + offset, b + offset, d + offset);
            face.normal.copy(normal);
            face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
            face.materialIndex = materialIndex;
            scope.faces.push(face);
            scope.faceVertexUvs[0].push([uva, uvb, uvd]);
            face = new THREE.Face3(b + offset, c + offset, d + offset);
            face.normal.copy(normal);
            face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
            face.materialIndex = materialIndex;
            scope.faces.push(face);
            scope.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
          }
        }
      }
      this.mergeVertices();
    };
    THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
    THREE.CircleGeometry = function(radius, segments, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'CircleGeometry';
      this.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      radius = radius || 50;
      segments = segments !== undefined ? Math.max(3, segments) : 8;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
      var i,
          uvs = [],
          center = new THREE.Vector3(),
          centerUV = new THREE.Vector2(0.5, 0.5);
      this.vertices.push(center);
      uvs.push(centerUV);
      for (i = 0; i <= segments; i++) {
        var vertex = new THREE.Vector3();
        var segment = thetaStart + i / segments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        this.vertices.push(vertex);
        uvs.push(new THREE.Vector2((vertex.x / radius + 1) / 2, (vertex.y / radius + 1) / 2));
      }
      var n = new THREE.Vector3(0, 0, 1);
      for (i = 1; i <= segments; i++) {
        this.faces.push(new THREE.Face3(i, i + 1, 0, [n.clone(), n.clone(), n.clone()]));
        this.faceVertexUvs[0].push([uvs[i].clone(), uvs[i + 1].clone(), centerUV.clone()]);
      }
      this.computeFaceNormals();
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    };
    THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
    THREE.CubeGeometry = function(width, height, depth, widthSegments, heightSegments, depthSegments) {
      THREE.warn('THREE.CubeGeometry has been renamed to THREE.BoxGeometry.');
      return new THREE.BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments);
    };
    THREE.CylinderGeometry = function(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'CylinderGeometry';
      this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      radiusTop = radiusTop !== undefined ? radiusTop : 20;
      radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
      height = height !== undefined ? height : 100;
      radialSegments = radialSegments || 8;
      heightSegments = heightSegments || 1;
      openEnded = openEnded !== undefined ? openEnded : false;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;
      var heightHalf = height / 2;
      var x,
          y,
          vertices = [],
          uvs = [];
      for (y = 0; y <= heightSegments; y++) {
        var verticesRow = [];
        var uvsRow = [];
        var v = y / heightSegments;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (x = 0; x <= radialSegments; x++) {
          var u = x / radialSegments;
          var vertex = new THREE.Vector3();
          vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
          vertex.y = -v * height + heightHalf;
          vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
          this.vertices.push(vertex);
          verticesRow.push(this.vertices.length - 1);
          uvsRow.push(new THREE.Vector2(u, 1 - v));
        }
        vertices.push(verticesRow);
        uvs.push(uvsRow);
      }
      var tanTheta = (radiusBottom - radiusTop) / height;
      var na,
          nb;
      for (x = 0; x < radialSegments; x++) {
        if (radiusTop !== 0) {
          na = this.vertices[vertices[0][x]].clone();
          nb = this.vertices[vertices[0][x + 1]].clone();
        } else {
          na = this.vertices[vertices[1][x]].clone();
          nb = this.vertices[vertices[1][x + 1]].clone();
        }
        na.setY(Math.sqrt(na.x * na.x + na.z * na.z) * tanTheta).normalize();
        nb.setY(Math.sqrt(nb.x * nb.x + nb.z * nb.z) * tanTheta).normalize();
        for (y = 0; y < heightSegments; y++) {
          var v1 = vertices[y][x];
          var v2 = vertices[y + 1][x];
          var v3 = vertices[y + 1][x + 1];
          var v4 = vertices[y][x + 1];
          var n1 = na.clone();
          var n2 = na.clone();
          var n3 = nb.clone();
          var n4 = nb.clone();
          var uv1 = uvs[y][x].clone();
          var uv2 = uvs[y + 1][x].clone();
          var uv3 = uvs[y + 1][x + 1].clone();
          var uv4 = uvs[y][x + 1].clone();
          this.faces.push(new THREE.Face3(v1, v2, v4, [n1, n2, n4]));
          this.faceVertexUvs[0].push([uv1, uv2, uv4]);
          this.faces.push(new THREE.Face3(v2, v3, v4, [n2.clone(), n3, n4.clone()]));
          this.faceVertexUvs[0].push([uv2.clone(), uv3, uv4.clone()]);
        }
      }
      if (openEnded === false && radiusTop > 0) {
        this.vertices.push(new THREE.Vector3(0, heightHalf, 0));
        for (x = 0; x < radialSegments; x++) {
          var v1 = vertices[0][x];
          var v2 = vertices[0][x + 1];
          var v3 = this.vertices.length - 1;
          var n1 = new THREE.Vector3(0, 1, 0);
          var n2 = new THREE.Vector3(0, 1, 0);
          var n3 = new THREE.Vector3(0, 1, 0);
          var uv1 = uvs[0][x].clone();
          var uv2 = uvs[0][x + 1].clone();
          var uv3 = new THREE.Vector2(uv2.x, 0);
          this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3]));
          this.faceVertexUvs[0].push([uv1, uv2, uv3]);
        }
      }
      if (openEnded === false && radiusBottom > 0) {
        this.vertices.push(new THREE.Vector3(0, -heightHalf, 0));
        for (x = 0; x < radialSegments; x++) {
          var v1 = vertices[heightSegments][x + 1];
          var v2 = vertices[heightSegments][x];
          var v3 = this.vertices.length - 1;
          var n1 = new THREE.Vector3(0, -1, 0);
          var n2 = new THREE.Vector3(0, -1, 0);
          var n3 = new THREE.Vector3(0, -1, 0);
          var uv1 = uvs[heightSegments][x + 1].clone();
          var uv2 = uvs[heightSegments][x].clone();
          var uv3 = new THREE.Vector2(uv2.x, 1);
          this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3]));
          this.faceVertexUvs[0].push([uv1, uv2, uv3]);
        }
      }
      this.computeFaceNormals();
    };
    THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
    THREE.ExtrudeGeometry = function(shapes, options) {
      if (typeof(shapes) === "undefined") {
        shapes = [];
        return;
      }
      THREE.Geometry.call(this);
      this.type = 'ExtrudeGeometry';
      shapes = shapes instanceof Array ? shapes : [shapes];
      this.addShapeList(shapes, options);
      this.computeFaceNormals();
    };
    THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
    THREE.ExtrudeGeometry.prototype.addShapeList = function(shapes, options) {
      var sl = shapes.length;
      for (var s = 0; s < sl; s++) {
        var shape = shapes[s];
        this.addShape(shape, options);
      }
    };
    THREE.ExtrudeGeometry.prototype.addShape = function(shape, options) {
      var amount = options.amount !== undefined ? options.amount : 100;
      var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
      var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
      var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
      var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      var steps = options.steps !== undefined ? options.steps : 1;
      var extrudePath = options.extrudePath;
      var extrudePts,
          extrudeByPath = false;
      var material = options.material;
      var extrudeMaterial = options.extrudeMaterial;
      var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;
      var splineTube,
          binormal,
          normal,
          position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);
        binormal = new THREE.Vector3();
        normal = new THREE.Vector3();
        position2 = new THREE.Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
      }
      var ahole,
          h,
          hl;
      var scope = this;
      var shapesOffset = this.vertices.length;
      var shapePoints = shape.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !THREE.Shape.Utils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          if (THREE.Shape.Utils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
        reverse = false;
      }
      var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);
      var contour = vertices;
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec)
          THREE.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size).add(pt);
      }
      var b,
          bs,
          t,
          z,
          vert,
          vlen = vertices.length,
          face,
          flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        var EPSILON = 0.0000000001;
        var v_trans_x,
            v_trans_y,
            shrink_by = 1;
        var v_prev_x = inPt.x - inPrev.x,
            v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x,
            v_next_y = inNext.y - inPt.y;
        var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
        var colinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
        if (Math.abs(colinear0) > EPSILON) {
          var v_prev_len = Math.sqrt(v_prev_lensq);
          var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
          var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
          var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
          var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
          var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
          v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
          var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
          if (v_trans_lensq <= 2) {
            return new THREE.Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          var direction_eq = false;
          if (v_prev_x > EPSILON) {
            if (v_next_x > EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -EPSILON) {
              if (v_next_x < -EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) == Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new THREE.Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      var contourMovements = [];
      for (var i = 0,
          il = contour.length,
          j = il - 1,
          k = i + 1; i < il; i++, j++, k++) {
        if (j === il)
          j = 0;
        if (k === il)
          k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      var holesMovements = [],
          oneHoleMovements,
          verticesMovements = contourMovements.concat();
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = [];
        for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (b = 0; b < bevelSegments; b++) {
        t = b / bevelSegments;
        z = bevelThickness * (1 - t);
        bs = bevelSize * (Math.sin(t * Math.PI / 2));
        for (i = 0, il = contour.length; i < il; i++) {
          vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, -z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (i = 0, il = ahole.length; i < il; i++) {
            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            v(vert.x, vert.y, -z);
          }
        }
      }
      bs = bevelSize;
      for (i = 0; i < vlen; i++) {
        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      var s;
      for (s = 1; s <= steps; s++) {
        for (i = 0; i < vlen; i++) {
          vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, amount / steps * s);
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (b = bevelSegments - 1; b >= 0; b--) {
        t = b / bevelSegments;
        z = bevelThickness * (1 - t);
        bs = bevelSize * Math.sin(t * Math.PI / 2);
        for (i = 0, il = contour.length; i < il; i++) {
          vert = scalePt2(contour[i], contourMovements[i], bs);
          v(vert.x, vert.y, amount + z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (i = 0, il = ahole.length; i < il; i++) {
            vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
            if (!extrudeByPath) {
              v(vert.x, vert.y, amount + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        if (bevelEnabled) {
          var layer = 0;
          var offset = vlen * layer;
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[2], face[1], face[0]);
          }
          for (i = 0; i < flen; i++) {
            face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
      }
      function buildSideFaces() {
        var layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
      }
      function sidewalls(contour, layeroffset) {
        var j,
            k;
        i = contour.length;
        while (--i >= 0) {
          j = i;
          k = i - 1;
          if (k < 0)
            k = contour.length - 1;
          var s = 0,
              sl = steps + bevelSegments * 2;
          for (s = 0; s < sl; s++) {
            var slen1 = vlen * s;
            var slen2 = vlen * (s + 1);
            var a = layeroffset + j + slen1,
                b = layeroffset + k + slen1,
                c = layeroffset + k + slen2,
                d = layeroffset + j + slen2;
            f4(a, b, c, d, contour, s, sl, j, k);
          }
        }
      }
      function v(x, y, z) {
        scope.vertices.push(new THREE.Vector3(x, y, z));
      }
      function f3(a, b, c) {
        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        scope.faces.push(new THREE.Face3(a, b, c, null, null, material));
        var uvs = uvgen.generateTopUV(scope, a, b, c);
        scope.faceVertexUvs[0].push(uvs);
      }
      function f4(a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2) {
        a += shapesOffset;
        b += shapesOffset;
        c += shapesOffset;
        d += shapesOffset;
        scope.faces.push(new THREE.Face3(a, b, d, null, null, extrudeMaterial));
        scope.faces.push(new THREE.Face3(b, c, d, null, null, extrudeMaterial));
        var uvs = uvgen.generateSideWallUV(scope, a, b, c, d);
        scope.faceVertexUvs[0].push([uvs[0], uvs[1], uvs[3]]);
        scope.faceVertexUvs[0].push([uvs[1], uvs[2], uvs[3]]);
      }
    };
    THREE.ExtrudeGeometry.WorldUVGenerator = {
      generateTopUV: function(geometry, indexA, indexB, indexC) {
        var vertices = geometry.vertices;
        var a = vertices[indexA];
        var b = vertices[indexB];
        var c = vertices[indexC];
        return [new THREE.Vector2(a.x, a.y), new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y)];
      },
      generateSideWallUV: function(geometry, indexA, indexB, indexC, indexD) {
        var vertices = geometry.vertices;
        var a = vertices[indexA];
        var b = vertices[indexB];
        var c = vertices[indexC];
        var d = vertices[indexD];
        if (Math.abs(a.y - b.y) < 0.01) {
          return [new THREE.Vector2(a.x, 1 - a.z), new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z)];
        } else {
          return [new THREE.Vector2(a.y, 1 - a.z), new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y, 1 - d.z)];
        }
      }
    };
    THREE.ShapeGeometry = function(shapes, options) {
      THREE.Geometry.call(this);
      this.type = 'ShapeGeometry';
      if (shapes instanceof Array === false)
        shapes = [shapes];
      this.addShapeList(shapes, options);
      this.computeFaceNormals();
    };
    THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
    THREE.ShapeGeometry.prototype.addShapeList = function(shapes, options) {
      for (var i = 0,
          l = shapes.length; i < l; i++) {
        this.addShape(shapes[i], options);
      }
      return this;
    };
    THREE.ShapeGeometry.prototype.addShape = function(shape, options) {
      if (options === undefined)
        options = {};
      var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
      var material = options.material;
      var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;
      var i,
          l,
          hole;
      var shapesOffset = this.vertices.length;
      var shapePoints = shape.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !THREE.Shape.Utils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (i = 0, l = holes.length; i < l; i++) {
          hole = holes[i];
          if (THREE.Shape.Utils.isClockWise(hole)) {
            holes[i] = hole.reverse();
          }
        }
        reverse = false;
      }
      var faces = THREE.Shape.Utils.triangulateShape(vertices, holes);
      var contour = vertices;
      for (i = 0, l = holes.length; i < l; i++) {
        hole = holes[i];
        vertices = vertices.concat(hole);
      }
      var vert,
          vlen = vertices.length;
      var face,
          flen = faces.length;
      for (i = 0; i < vlen; i++) {
        vert = vertices[i];
        this.vertices.push(new THREE.Vector3(vert.x, vert.y, 0));
      }
      for (i = 0; i < flen; i++) {
        face = faces[i];
        var a = face[0] + shapesOffset;
        var b = face[1] + shapesOffset;
        var c = face[2] + shapesOffset;
        this.faces.push(new THREE.Face3(a, b, c, null, null, material));
        this.faceVertexUvs[0].push(uvgen.generateTopUV(this, a, b, c));
      }
    };
    THREE.LatheGeometry = function(points, segments, phiStart, phiLength) {
      THREE.Geometry.call(this);
      this.type = 'LatheGeometry';
      this.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
      };
      segments = segments || 12;
      phiStart = phiStart || 0;
      phiLength = phiLength || 2 * Math.PI;
      var inversePointLength = 1.0 / (points.length - 1);
      var inverseSegments = 1.0 / segments;
      for (var i = 0,
          il = segments; i <= il; i++) {
        var phi = phiStart + i * inverseSegments * phiLength;
        var c = Math.cos(phi),
            s = Math.sin(phi);
        for (var j = 0,
            jl = points.length; j < jl; j++) {
          var pt = points[j];
          var vertex = new THREE.Vector3();
          vertex.x = c * pt.x - s * pt.y;
          vertex.y = s * pt.x + c * pt.y;
          vertex.z = pt.z;
          this.vertices.push(vertex);
        }
      }
      var np = points.length;
      for (var i = 0,
          il = segments; i < il; i++) {
        for (var j = 0,
            jl = points.length - 1; j < jl; j++) {
          var base = j + np * i;
          var a = base;
          var b = base + np;
          var c = base + 1 + np;
          var d = base + 1;
          var u0 = i * inverseSegments;
          var v0 = j * inversePointLength;
          var u1 = u0 + inverseSegments;
          var v1 = v0 + inversePointLength;
          this.faces.push(new THREE.Face3(a, b, d));
          this.faceVertexUvs[0].push([new THREE.Vector2(u0, v0), new THREE.Vector2(u1, v0), new THREE.Vector2(u0, v1)]);
          this.faces.push(new THREE.Face3(b, c, d));
          this.faceVertexUvs[0].push([new THREE.Vector2(u1, v0), new THREE.Vector2(u1, v1), new THREE.Vector2(u0, v1)]);
        }
      }
      this.mergeVertices();
      this.computeFaceNormals();
      this.computeVertexNormals();
    };
    THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
    THREE.PlaneGeometry = function(width, height, widthSegments, heightSegments) {
      console.info('THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.');
      THREE.Geometry.call(this);
      this.type = 'PlaneGeometry';
      this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
      };
      this.fromBufferGeometry(new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments));
    };
    THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
    THREE.PlaneBufferGeometry = function(width, height, widthSegments, heightSegments) {
      THREE.BufferGeometry.call(this);
      this.type = 'PlaneBufferGeometry';
      this.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
      };
      var width_half = width / 2;
      var height_half = height / 2;
      var gridX = widthSegments || 1;
      var gridY = heightSegments || 1;
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var segment_width = width / gridX;
      var segment_height = height / gridY;
      var vertices = new Float32Array(gridX1 * gridY1 * 3);
      var normals = new Float32Array(gridX1 * gridY1 * 3);
      var uvs = new Float32Array(gridX1 * gridY1 * 2);
      var offset = 0;
      var offset2 = 0;
      for (var iy = 0; iy < gridY1; iy++) {
        var y = iy * segment_height - height_half;
        for (var ix = 0; ix < gridX1; ix++) {
          var x = ix * segment_width - width_half;
          vertices[offset] = x;
          vertices[offset + 1] = -y;
          normals[offset + 2] = 1;
          uvs[offset2] = ix / gridX;
          uvs[offset2 + 1] = 1 - (iy / gridY);
          offset += 3;
          offset2 += 2;
        }
      }
      offset = 0;
      var indices = new ((vertices.length / 3) > 65535 ? Uint32Array : Uint16Array)(gridX * gridY * 6);
      for (var iy = 0; iy < gridY; iy++) {
        for (var ix = 0; ix < gridX; ix++) {
          var a = ix + gridX1 * iy;
          var b = ix + gridX1 * (iy + 1);
          var c = (ix + 1) + gridX1 * (iy + 1);
          var d = (ix + 1) + gridX1 * iy;
          indices[offset] = a;
          indices[offset + 1] = b;
          indices[offset + 2] = d;
          indices[offset + 3] = b;
          indices[offset + 4] = c;
          indices[offset + 5] = d;
          offset += 6;
        }
      }
      this.addAttribute('index', new THREE.BufferAttribute(indices, 1));
      this.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      this.addAttribute('normal', new THREE.BufferAttribute(normals, 3));
      this.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    };
    THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
    THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
    THREE.RingGeometry = function(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'RingGeometry';
      this.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      innerRadius = innerRadius || 0;
      outerRadius = outerRadius || 50;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
      thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
      phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 8;
      var i,
          o,
          uvs = [],
          radius = innerRadius,
          radiusStep = ((outerRadius - innerRadius) / phiSegments);
      for (i = 0; i < phiSegments + 1; i++) {
        for (o = 0; o < thetaSegments + 1; o++) {
          var vertex = new THREE.Vector3();
          var segment = thetaStart + o / thetaSegments * thetaLength;
          vertex.x = radius * Math.cos(segment);
          vertex.y = radius * Math.sin(segment);
          this.vertices.push(vertex);
          uvs.push(new THREE.Vector2((vertex.x / outerRadius + 1) / 2, (vertex.y / outerRadius + 1) / 2));
        }
        radius += radiusStep;
      }
      var n = new THREE.Vector3(0, 0, 1);
      for (i = 0; i < phiSegments; i++) {
        var thetaSegment = i * (thetaSegments + 1);
        for (o = 0; o < thetaSegments; o++) {
          var segment = o + thetaSegment;
          var v1 = segment;
          var v2 = segment + thetaSegments + 1;
          var v3 = segment + thetaSegments + 2;
          this.faces.push(new THREE.Face3(v1, v2, v3, [n.clone(), n.clone(), n.clone()]));
          this.faceVertexUvs[0].push([uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone()]);
          v1 = segment;
          v2 = segment + thetaSegments + 2;
          v3 = segment + 1;
          this.faces.push(new THREE.Face3(v1, v2, v3, [n.clone(), n.clone(), n.clone()]));
          this.faceVertexUvs[0].push([uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone()]);
        }
      }
      this.computeFaceNormals();
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    };
    THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
    THREE.SphereGeometry = function(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
      THREE.Geometry.call(this);
      this.type = 'SphereGeometry';
      this.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      radius = radius || 50;
      widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
      heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
      phiStart = phiStart !== undefined ? phiStart : 0;
      phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
      thetaStart = thetaStart !== undefined ? thetaStart : 0;
      thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
      var x,
          y,
          vertices = [],
          uvs = [];
      for (y = 0; y <= heightSegments; y++) {
        var verticesRow = [];
        var uvsRow = [];
        for (x = 0; x <= widthSegments; x++) {
          var u = x / widthSegments;
          var v = y / heightSegments;
          var vertex = new THREE.Vector3();
          vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
          vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          this.vertices.push(vertex);
          verticesRow.push(this.vertices.length - 1);
          uvsRow.push(new THREE.Vector2(u, 1 - v));
        }
        vertices.push(verticesRow);
        uvs.push(uvsRow);
      }
      for (y = 0; y < heightSegments; y++) {
        for (x = 0; x < widthSegments; x++) {
          var v1 = vertices[y][x + 1];
          var v2 = vertices[y][x];
          var v3 = vertices[y + 1][x];
          var v4 = vertices[y + 1][x + 1];
          var n1 = this.vertices[v1].clone().normalize();
          var n2 = this.vertices[v2].clone().normalize();
          var n3 = this.vertices[v3].clone().normalize();
          var n4 = this.vertices[v4].clone().normalize();
          var uv1 = uvs[y][x + 1].clone();
          var uv2 = uvs[y][x].clone();
          var uv3 = uvs[y + 1][x].clone();
          var uv4 = uvs[y + 1][x + 1].clone();
          if (Math.abs(this.vertices[v1].y) === radius) {
            uv1.x = (uv1.x + uv2.x) / 2;
            this.faces.push(new THREE.Face3(v1, v3, v4, [n1, n3, n4]));
            this.faceVertexUvs[0].push([uv1, uv3, uv4]);
          } else if (Math.abs(this.vertices[v3].y) === radius) {
            uv3.x = (uv3.x + uv4.x) / 2;
            this.faces.push(new THREE.Face3(v1, v2, v3, [n1, n2, n3]));
            this.faceVertexUvs[0].push([uv1, uv2, uv3]);
          } else {
            this.faces.push(new THREE.Face3(v1, v2, v4, [n1, n2, n4]));
            this.faceVertexUvs[0].push([uv1, uv2, uv4]);
            this.faces.push(new THREE.Face3(v2, v3, v4, [n2.clone(), n3, n4.clone()]));
            this.faceVertexUvs[0].push([uv2.clone(), uv3, uv4.clone()]);
          }
        }
      }
      this.computeFaceNormals();
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
    };
    THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
    THREE.TextGeometry = function(text, parameters) {
      parameters = parameters || {};
      var textShapes = THREE.FontUtils.generateShapes(text, parameters);
      parameters.amount = parameters.height !== undefined ? parameters.height : 50;
      if (parameters.bevelThickness === undefined)
        parameters.bevelThickness = 10;
      if (parameters.bevelSize === undefined)
        parameters.bevelSize = 8;
      if (parameters.bevelEnabled === undefined)
        parameters.bevelEnabled = false;
      THREE.ExtrudeGeometry.call(this, textShapes, parameters);
      this.type = 'TextGeometry';
    };
    THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
    THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;
    THREE.TorusGeometry = function(radius, tube, radialSegments, tubularSegments, arc) {
      THREE.Geometry.call(this);
      this.type = 'TorusGeometry';
      this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
      };
      radius = radius || 100;
      tube = tube || 40;
      radialSegments = radialSegments || 8;
      tubularSegments = tubularSegments || 6;
      arc = arc || Math.PI * 2;
      var center = new THREE.Vector3(),
          uvs = [],
          normals = [];
      for (var j = 0; j <= radialSegments; j++) {
        for (var i = 0; i <= tubularSegments; i++) {
          var u = i / tubularSegments * arc;
          var v = j / radialSegments * Math.PI * 2;
          center.x = radius * Math.cos(u);
          center.y = radius * Math.sin(u);
          var vertex = new THREE.Vector3();
          vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
          vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
          vertex.z = tube * Math.sin(v);
          this.vertices.push(vertex);
          uvs.push(new THREE.Vector2(i / tubularSegments, j / radialSegments));
          normals.push(vertex.clone().sub(center).normalize());
        }
      }
      for (var j = 1; j <= radialSegments; j++) {
        for (var i = 1; i <= tubularSegments; i++) {
          var a = (tubularSegments + 1) * j + i - 1;
          var b = (tubularSegments + 1) * (j - 1) + i - 1;
          var c = (tubularSegments + 1) * (j - 1) + i;
          var d = (tubularSegments + 1) * j + i;
          var face = new THREE.Face3(a, b, d, [normals[a].clone(), normals[b].clone(), normals[d].clone()]);
          this.faces.push(face);
          this.faceVertexUvs[0].push([uvs[a].clone(), uvs[b].clone(), uvs[d].clone()]);
          face = new THREE.Face3(b, c, d, [normals[b].clone(), normals[c].clone(), normals[d].clone()]);
          this.faces.push(face);
          this.faceVertexUvs[0].push([uvs[b].clone(), uvs[c].clone(), uvs[d].clone()]);
        }
      }
      this.computeFaceNormals();
    };
    THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
    THREE.TorusKnotGeometry = function(radius, tube, radialSegments, tubularSegments, p, q, heightScale) {
      THREE.Geometry.call(this);
      this.type = 'TorusKnotGeometry';
      this.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        p: p,
        q: q,
        heightScale: heightScale
      };
      radius = radius || 100;
      tube = tube || 40;
      radialSegments = radialSegments || 64;
      tubularSegments = tubularSegments || 8;
      p = p || 2;
      q = q || 3;
      heightScale = heightScale || 1;
      var grid = new Array(radialSegments);
      var tang = new THREE.Vector3();
      var n = new THREE.Vector3();
      var bitan = new THREE.Vector3();
      for (var i = 0; i < radialSegments; ++i) {
        grid[i] = new Array(tubularSegments);
        var u = i / radialSegments * 2 * p * Math.PI;
        var p1 = getPos(u, q, p, radius, heightScale);
        var p2 = getPos(u + 0.01, q, p, radius, heightScale);
        tang.subVectors(p2, p1);
        n.addVectors(p2, p1);
        bitan.crossVectors(tang, n);
        n.crossVectors(bitan, tang);
        bitan.normalize();
        n.normalize();
        for (var j = 0; j < tubularSegments; ++j) {
          var v = j / tubularSegments * 2 * Math.PI;
          var cx = -tube * Math.cos(v);
          var cy = tube * Math.sin(v);
          var pos = new THREE.Vector3();
          pos.x = p1.x + cx * n.x + cy * bitan.x;
          pos.y = p1.y + cx * n.y + cy * bitan.y;
          pos.z = p1.z + cx * n.z + cy * bitan.z;
          grid[i][j] = this.vertices.push(pos) - 1;
        }
      }
      for (var i = 0; i < radialSegments; ++i) {
        for (var j = 0; j < tubularSegments; ++j) {
          var ip = (i + 1) % radialSegments;
          var jp = (j + 1) % tubularSegments;
          var a = grid[i][j];
          var b = grid[ip][j];
          var c = grid[ip][jp];
          var d = grid[i][jp];
          var uva = new THREE.Vector2(i / radialSegments, j / tubularSegments);
          var uvb = new THREE.Vector2((i + 1) / radialSegments, j / tubularSegments);
          var uvc = new THREE.Vector2((i + 1) / radialSegments, (j + 1) / tubularSegments);
          var uvd = new THREE.Vector2(i / radialSegments, (j + 1) / tubularSegments);
          this.faces.push(new THREE.Face3(a, b, d));
          this.faceVertexUvs[0].push([uva, uvb, uvd]);
          this.faces.push(new THREE.Face3(b, c, d));
          this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
      this.computeFaceNormals();
      this.computeVertexNormals();
      function getPos(u, in_q, in_p, radius, heightScale) {
        var cu = Math.cos(u);
        var su = Math.sin(u);
        var quOverP = in_q / in_p * u;
        var cs = Math.cos(quOverP);
        var tx = radius * (2 + cs) * 0.5 * cu;
        var ty = radius * (2 + cs) * su * 0.5;
        var tz = heightScale * radius * Math.sin(quOverP) * 0.5;
        return new THREE.Vector3(tx, ty, tz);
      }
    };
    THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
    THREE.TubeGeometry = function(path, segments, radius, radialSegments, closed, taper) {
      THREE.Geometry.call(this);
      this.type = 'TubeGeometry';
      this.parameters = {
        path: path,
        segments: segments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed
      };
      segments = segments || 64;
      radius = radius || 1;
      radialSegments = radialSegments || 8;
      closed = closed || false;
      taper = taper || THREE.TubeGeometry.NoTaper;
      var grid = [];
      var scope = this,
          tangent,
          normal,
          binormal,
          numpoints = segments + 1,
          u,
          v,
          r,
          cx,
          cy,
          pos,
          pos2 = new THREE.Vector3(),
          i,
          j,
          ip,
          jp,
          a,
          b,
          c,
          d,
          uva,
          uvb,
          uvc,
          uvd;
      var frames = new THREE.TubeGeometry.FrenetFrames(path, segments, closed),
          tangents = frames.tangents,
          normals = frames.normals,
          binormals = frames.binormals;
      this.tangents = tangents;
      this.normals = normals;
      this.binormals = binormals;
      function vert(x, y, z) {
        return scope.vertices.push(new THREE.Vector3(x, y, z)) - 1;
      }
      for (i = 0; i < numpoints; i++) {
        grid[i] = [];
        u = i / (numpoints - 1);
        pos = path.getPointAt(u);
        tangent = tangents[i];
        normal = normals[i];
        binormal = binormals[i];
        r = radius * taper(u);
        for (j = 0; j < radialSegments; j++) {
          v = j / radialSegments * 2 * Math.PI;
          cx = -r * Math.cos(v);
          cy = r * Math.sin(v);
          pos2.copy(pos);
          pos2.x += cx * normal.x + cy * binormal.x;
          pos2.y += cx * normal.y + cy * binormal.y;
          pos2.z += cx * normal.z + cy * binormal.z;
          grid[i][j] = vert(pos2.x, pos2.y, pos2.z);
        }
      }
      for (i = 0; i < segments; i++) {
        for (j = 0; j < radialSegments; j++) {
          ip = (closed) ? (i + 1) % segments : i + 1;
          jp = (j + 1) % radialSegments;
          a = grid[i][j];
          b = grid[ip][j];
          c = grid[ip][jp];
          d = grid[i][jp];
          uva = new THREE.Vector2(i / segments, j / radialSegments);
          uvb = new THREE.Vector2((i + 1) / segments, j / radialSegments);
          uvc = new THREE.Vector2((i + 1) / segments, (j + 1) / radialSegments);
          uvd = new THREE.Vector2(i / segments, (j + 1) / radialSegments);
          this.faces.push(new THREE.Face3(a, b, d));
          this.faceVertexUvs[0].push([uva, uvb, uvd]);
          this.faces.push(new THREE.Face3(b, c, d));
          this.faceVertexUvs[0].push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
      this.computeFaceNormals();
      this.computeVertexNormals();
    };
    THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
    THREE.TubeGeometry.NoTaper = function(u) {
      return 1;
    };
    THREE.TubeGeometry.SinusoidalTaper = function(u) {
      return Math.sin(Math.PI * u);
    };
    THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {
      var normal = new THREE.Vector3(),
          tangents = [],
          normals = [],
          binormals = [],
          vec = new THREE.Vector3(),
          mat = new THREE.Matrix4(),
          numpoints = segments + 1,
          theta,
          epsilon = 0.0001,
          smallest,
          tx,
          ty,
          tz,
          i,
          u;
      this.tangents = tangents;
      this.normals = normals;
      this.binormals = binormals;
      for (i = 0; i < numpoints; i++) {
        u = i / (numpoints - 1);
        tangents[i] = path.getTangentAt(u);
        tangents[i].normalize();
      }
      initialNormal3();
      function initialNormal3() {
        normals[0] = new THREE.Vector3();
        binormals[0] = new THREE.Vector3();
        smallest = Number.MAX_VALUE;
        tx = Math.abs(tangents[0].x);
        ty = Math.abs(tangents[0].y);
        tz = Math.abs(tangents[0].z);
        if (tx <= smallest) {
          smallest = tx;
          normal.set(1, 0, 0);
        }
        if (ty <= smallest) {
          smallest = ty;
          normal.set(0, 1, 0);
        }
        if (tz <= smallest) {
          normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
      }
      for (i = 1; i < numpoints; i++) {
        normals[i] = normals[i - 1].clone();
        binormals[i] = binormals[i - 1].clone();
        vec.crossVectors(tangents[i - 1], tangents[i]);
        if (vec.length() > epsilon) {
          vec.normalize();
          theta = Math.acos(THREE.Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
          normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
      if (closed) {
        theta = Math.acos(THREE.Math.clamp(normals[0].dot(normals[numpoints - 1]), -1, 1));
        theta /= (numpoints - 1);
        if (tangents[0].dot(vec.crossVectors(normals[0], normals[numpoints - 1])) > 0) {
          theta = -theta;
        }
        for (i = 1; i < numpoints; i++) {
          normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
          binormals[i].crossVectors(tangents[i], normals[i]);
        }
      }
    };
    THREE.PolyhedronGeometry = function(vertices, indices, radius, detail) {
      THREE.Geometry.call(this);
      this.type = 'PolyhedronGeometry';
      this.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
      };
      radius = radius || 1;
      detail = detail || 0;
      var that = this;
      for (var i = 0,
          l = vertices.length; i < l; i += 3) {
        prepare(new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]));
      }
      var p = this.vertices;
      var faces = [];
      for (var i = 0,
          j = 0,
          l = indices.length; i < l; i += 3, j++) {
        var v1 = p[indices[i]];
        var v2 = p[indices[i + 1]];
        var v3 = p[indices[i + 2]];
        faces[j] = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()]);
      }
      var centroid = new THREE.Vector3();
      for (var i = 0,
          l = faces.length; i < l; i++) {
        subdivide(faces[i], detail);
      }
      for (var i = 0,
          l = this.faceVertexUvs[0].length; i < l; i++) {
        var uvs = this.faceVertexUvs[0][i];
        var x0 = uvs[0].x;
        var x1 = uvs[1].x;
        var x2 = uvs[2].x;
        var max = Math.max(x0, Math.max(x1, x2));
        var min = Math.min(x0, Math.min(x1, x2));
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2)
            uvs[0].x += 1;
          if (x1 < 0.2)
            uvs[1].x += 1;
          if (x2 < 0.2)
            uvs[2].x += 1;
        }
      }
      for (var i = 0,
          l = this.vertices.length; i < l; i++) {
        this.vertices[i].multiplyScalar(radius);
      }
      this.mergeVertices();
      this.computeFaceNormals();
      this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
      function prepare(vector) {
        var vertex = vector.normalize().clone();
        vertex.index = that.vertices.push(vertex) - 1;
        var u = azimuth(vector) / 2 / Math.PI + 0.5;
        var v = inclination(vector) / Math.PI + 0.5;
        vertex.uv = new THREE.Vector2(u, 1 - v);
        return vertex;
      }
      function make(v1, v2, v3) {
        var face = new THREE.Face3(v1.index, v2.index, v3.index, [v1.clone(), v2.clone(), v3.clone()]);
        that.faces.push(face);
        centroid.copy(v1).add(v2).add(v3).divideScalar(3);
        var azi = azimuth(centroid);
        that.faceVertexUvs[0].push([correctUV(v1.uv, v1, azi), correctUV(v2.uv, v2, azi), correctUV(v3.uv, v3, azi)]);
      }
      function subdivide(face, detail) {
        var cols = Math.pow(2, detail);
        var a = prepare(that.vertices[face.a]);
        var b = prepare(that.vertices[face.b]);
        var c = prepare(that.vertices[face.c]);
        var v = [];
        for (var i = 0; i <= cols; i++) {
          v[i] = [];
          var aj = prepare(a.clone().lerp(c, i / cols));
          var bj = prepare(b.clone().lerp(c, i / cols));
          var rows = cols - i;
          for (var j = 0; j <= rows; j++) {
            if (j == 0 && i == cols) {
              v[i][j] = aj;
            } else {
              v[i][j] = prepare(aj.clone().lerp(bj, j / rows));
            }
          }
        }
        for (var i = 0; i < cols; i++) {
          for (var j = 0; j < 2 * (cols - i) - 1; j++) {
            var k = Math.floor(j / 2);
            if (j % 2 == 0) {
              make(v[i][k + 1], v[i + 1][k], v[i][k]);
            } else {
              make(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k]);
            }
          }
        }
      }
      function azimuth(vector) {
        return Math.atan2(vector.z, -vector.x);
      }
      function inclination(vector) {
        return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
      }
      function correctUV(uv, vector, azimuth) {
        if ((azimuth < 0) && (uv.x === 1))
          uv = new THREE.Vector2(uv.x - 1, uv.y);
        if ((vector.x === 0) && (vector.z === 0))
          uv = new THREE.Vector2(azimuth / 2 / Math.PI + 0.5, uv.y);
        return uv.clone();
      }
    };
    THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
    THREE.DodecahedronGeometry = function(radius, detail) {
      this.parameters = {
        radius: radius,
        detail: detail
      };
      var t = (1 + Math.sqrt(5)) / 2;
      var r = 1 / t;
      var vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
      var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
    };
    THREE.DodecahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
    THREE.IcosahedronGeometry = function(radius, detail) {
      var t = (1 + Math.sqrt(5)) / 2;
      var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
      var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'IcosahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
    THREE.OctahedronGeometry = function(radius, detail) {
      this.parameters = {
        radius: radius,
        detail: detail
      };
      var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
      var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'OctahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
    THREE.TetrahedronGeometry = function(radius, detail) {
      var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
      var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
      THREE.PolyhedronGeometry.call(this, vertices, indices, radius, detail);
      this.type = 'TetrahedronGeometry';
      this.parameters = {
        radius: radius,
        detail: detail
      };
    };
    THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
    THREE.ParametricGeometry = function(func, slices, stacks) {
      THREE.Geometry.call(this);
      this.type = 'ParametricGeometry';
      this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
      };
      var verts = this.vertices;
      var faces = this.faces;
      var uvs = this.faceVertexUvs[0];
      var i,
          j,
          p;
      var u,
          v;
      var sliceCount = slices + 1;
      for (i = 0; i <= stacks; i++) {
        v = i / stacks;
        for (j = 0; j <= slices; j++) {
          u = j / slices;
          p = func(u, v);
          verts.push(p);
        }
      }
      var a,
          b,
          c,
          d;
      var uva,
          uvb,
          uvc,
          uvd;
      for (i = 0; i < stacks; i++) {
        for (j = 0; j < slices; j++) {
          a = i * sliceCount + j;
          b = i * sliceCount + j + 1;
          c = (i + 1) * sliceCount + j + 1;
          d = (i + 1) * sliceCount + j;
          uva = new THREE.Vector2(j / slices, i / stacks);
          uvb = new THREE.Vector2((j + 1) / slices, i / stacks);
          uvc = new THREE.Vector2((j + 1) / slices, (i + 1) / stacks);
          uvd = new THREE.Vector2(j / slices, (i + 1) / stacks);
          faces.push(new THREE.Face3(a, b, d));
          uvs.push([uva, uvb, uvd]);
          faces.push(new THREE.Face3(b, c, d));
          uvs.push([uvb.clone(), uvc, uvd.clone()]);
        }
      }
      this.computeFaceNormals();
      this.computeVertexNormals();
    };
    THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
    THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
    THREE.AxisHelper = function(size) {
      size = size || 1;
      var vertices = new Float32Array([0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size]);
      var colors = new Float32Array([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1]);
      var geometry = new THREE.BufferGeometry();
      geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
      geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
      var material = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
      THREE.Line.call(this, geometry, material, THREE.LinePieces);
    };
    THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
    THREE.ArrowHelper = (function() {
      var lineGeometry = new THREE.Geometry();
      lineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
      var coneGeometry = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);
      coneGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));
      return function(dir, origin, length, color, headLength, headWidth) {
        THREE.Object3D.call(this);
        if (color === undefined)
          color = 0xffff00;
        if (length === undefined)
          length = 1;
        if (headLength === undefined)
          headLength = 0.2 * length;
        if (headWidth === undefined)
          headWidth = 0.2 * headLength;
        this.position.copy(origin);
        this.line = new THREE.Line(lineGeometry, new THREE.LineBasicMaterial({color: color}));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new THREE.Mesh(coneGeometry, new THREE.MeshBasicMaterial({color: color}));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
      };
    }());
    THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
    THREE.ArrowHelper.prototype.setDirection = (function() {
      var axis = new THREE.Vector3();
      var radians;
      return function(dir) {
        if (dir.y > 0.99999) {
          this.quaternion.set(0, 0, 0, 1);
        } else if (dir.y < -0.99999) {
          this.quaternion.set(1, 0, 0, 0);
        } else {
          axis.set(dir.z, 0, -dir.x).normalize();
          radians = Math.acos(dir.y);
          this.quaternion.setFromAxisAngle(axis, radians);
        }
      };
    }());
    THREE.ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
      if (headLength === undefined)
        headLength = 0.2 * length;
      if (headWidth === undefined)
        headWidth = 0.2 * headLength;
      this.line.scale.set(1, length - headLength, 1);
      this.line.updateMatrix();
      this.cone.scale.set(headWidth, headLength, headWidth);
      this.cone.position.y = length;
      this.cone.updateMatrix();
    };
    THREE.ArrowHelper.prototype.setColor = function(color) {
      this.line.material.color.set(color);
      this.cone.material.color.set(color);
    };
    THREE.BoxHelper = function(object) {
      var geometry = new THREE.BufferGeometry();
      geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(72), 3));
      THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({color: 0xffff00}), THREE.LinePieces);
      if (object !== undefined) {
        this.update(object);
      }
    };
    THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
    THREE.BoxHelper.prototype.update = function(object) {
      var geometry = object.geometry;
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }
      var min = geometry.boundingBox.min;
      var max = geometry.boundingBox.max;
      var vertices = this.geometry.attributes.position.array;
      vertices[0] = max.x;
      vertices[1] = max.y;
      vertices[2] = max.z;
      vertices[3] = min.x;
      vertices[4] = max.y;
      vertices[5] = max.z;
      vertices[6] = min.x;
      vertices[7] = max.y;
      vertices[8] = max.z;
      vertices[9] = min.x;
      vertices[10] = min.y;
      vertices[11] = max.z;
      vertices[12] = min.x;
      vertices[13] = min.y;
      vertices[14] = max.z;
      vertices[15] = max.x;
      vertices[16] = min.y;
      vertices[17] = max.z;
      vertices[18] = max.x;
      vertices[19] = min.y;
      vertices[20] = max.z;
      vertices[21] = max.x;
      vertices[22] = max.y;
      vertices[23] = max.z;
      vertices[24] = max.x;
      vertices[25] = max.y;
      vertices[26] = min.z;
      vertices[27] = min.x;
      vertices[28] = max.y;
      vertices[29] = min.z;
      vertices[30] = min.x;
      vertices[31] = max.y;
      vertices[32] = min.z;
      vertices[33] = min.x;
      vertices[34] = min.y;
      vertices[35] = min.z;
      vertices[36] = min.x;
      vertices[37] = min.y;
      vertices[38] = min.z;
      vertices[39] = max.x;
      vertices[40] = min.y;
      vertices[41] = min.z;
      vertices[42] = max.x;
      vertices[43] = min.y;
      vertices[44] = min.z;
      vertices[45] = max.x;
      vertices[46] = max.y;
      vertices[47] = min.z;
      vertices[48] = max.x;
      vertices[49] = max.y;
      vertices[50] = max.z;
      vertices[51] = max.x;
      vertices[52] = max.y;
      vertices[53] = min.z;
      vertices[54] = min.x;
      vertices[55] = max.y;
      vertices[56] = max.z;
      vertices[57] = min.x;
      vertices[58] = max.y;
      vertices[59] = min.z;
      vertices[60] = min.x;
      vertices[61] = min.y;
      vertices[62] = max.z;
      vertices[63] = min.x;
      vertices[64] = min.y;
      vertices[65] = min.z;
      vertices[66] = max.x;
      vertices[67] = min.y;
      vertices[68] = max.z;
      vertices[69] = max.x;
      vertices[70] = min.y;
      vertices[71] = min.z;
      this.geometry.attributes.position.needsUpdate = true;
      this.geometry.computeBoundingSphere();
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.BoundingBoxHelper = function(object, hex) {
      var color = (hex !== undefined) ? hex : 0x888888;
      this.object = object;
      this.box = new THREE.Box3();
      THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
        color: color,
        wireframe: true
      }));
    };
    THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
    THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
    THREE.BoundingBoxHelper.prototype.update = function() {
      this.box.setFromObject(this.object);
      this.box.size(this.scale);
      this.box.center(this.position);
    };
    THREE.CameraHelper = function(camera) {
      var geometry = new THREE.Geometry();
      var material = new THREE.LineBasicMaterial({
        color: 0xffffff,
        vertexColors: THREE.FaceColors
      });
      var pointMap = {};
      var hexFrustum = 0xffaa00;
      var hexCone = 0xff0000;
      var hexUp = 0x00aaff;
      var hexTarget = 0xffffff;
      var hexCross = 0x333333;
      addLine("n1", "n2", hexFrustum);
      addLine("n2", "n4", hexFrustum);
      addLine("n4", "n3", hexFrustum);
      addLine("n3", "n1", hexFrustum);
      addLine("f1", "f2", hexFrustum);
      addLine("f2", "f4", hexFrustum);
      addLine("f4", "f3", hexFrustum);
      addLine("f3", "f1", hexFrustum);
      addLine("n1", "f1", hexFrustum);
      addLine("n2", "f2", hexFrustum);
      addLine("n3", "f3", hexFrustum);
      addLine("n4", "f4", hexFrustum);
      addLine("p", "n1", hexCone);
      addLine("p", "n2", hexCone);
      addLine("p", "n3", hexCone);
      addLine("p", "n4", hexCone);
      addLine("u1", "u2", hexUp);
      addLine("u2", "u3", hexUp);
      addLine("u3", "u1", hexUp);
      addLine("c", "t", hexTarget);
      addLine("p", "c", hexCross);
      addLine("cn1", "cn2", hexCross);
      addLine("cn3", "cn4", hexCross);
      addLine("cf1", "cf2", hexCross);
      addLine("cf3", "cf4", hexCross);
      function addLine(a, b, hex) {
        addPoint(a, hex);
        addPoint(b, hex);
      }
      function addPoint(id, hex) {
        geometry.vertices.push(new THREE.Vector3());
        geometry.colors.push(new THREE.Color(hex));
        if (pointMap[id] === undefined) {
          pointMap[id] = [];
        }
        pointMap[id].push(geometry.vertices.length - 1);
      }
      THREE.Line.call(this, geometry, material, THREE.LinePieces);
      this.camera = camera;
      this.matrix = camera.matrixWorld;
      this.matrixAutoUpdate = false;
      this.pointMap = pointMap;
      this.update();
    };
    THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
    THREE.CameraHelper.prototype.update = function() {
      var geometry,
          pointMap;
      var vector = new THREE.Vector3();
      var camera = new THREE.Camera();
      var setPoint = function(point, x, y, z) {
        vector.set(x, y, z).unproject(camera);
        var points = pointMap[point];
        if (points !== undefined) {
          for (var i = 0,
              il = points.length; i < il; i++) {
            geometry.vertices[points[i]].copy(vector);
          }
        }
      };
      return function() {
        geometry = this.geometry;
        pointMap = this.pointMap;
        var w = 1,
            h = 1;
        camera.projectionMatrix.copy(this.camera.projectionMatrix);
        setPoint("c", 0, 0, -1);
        setPoint("t", 0, 0, 1);
        setPoint("n1", -w, -h, -1);
        setPoint("n2", w, -h, -1);
        setPoint("n3", -w, h, -1);
        setPoint("n4", w, h, -1);
        setPoint("f1", -w, -h, 1);
        setPoint("f2", w, -h, 1);
        setPoint("f3", -w, h, 1);
        setPoint("f4", w, h, 1);
        setPoint("u1", w * 0.7, h * 1.1, -1);
        setPoint("u2", -w * 0.7, h * 1.1, -1);
        setPoint("u3", 0, h * 2, -1);
        setPoint("cf1", -w, 0, 1);
        setPoint("cf2", w, 0, 1);
        setPoint("cf3", 0, -h, 1);
        setPoint("cf4", 0, h, 1);
        setPoint("cn1", -w, 0, -1);
        setPoint("cn2", w, 0, -1);
        setPoint("cn3", 0, -h, -1);
        setPoint("cn4", 0, h, -1);
        geometry.verticesNeedUpdate = true;
      };
    }();
    THREE.DirectionalLightHelper = function(light, size) {
      THREE.Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      size = size || 1;
      var geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(-size, size, 0), new THREE.Vector3(size, size, 0), new THREE.Vector3(size, -size, 0), new THREE.Vector3(-size, -size, 0), new THREE.Vector3(-size, size, 0));
      var material = new THREE.LineBasicMaterial({fog: false});
      material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      this.lightPlane = new THREE.Line(geometry, material);
      this.add(this.lightPlane);
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());
      material = new THREE.LineBasicMaterial({fog: false});
      material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      this.targetLine = new THREE.Line(geometry, material);
      this.add(this.targetLine);
      this.update();
    };
    THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
    THREE.DirectionalLightHelper.prototype.dispose = function() {
      this.lightPlane.geometry.dispose();
      this.lightPlane.material.dispose();
      this.targetLine.geometry.dispose();
      this.targetLine.material.dispose();
    };
    THREE.DirectionalLightHelper.prototype.update = function() {
      var v1 = new THREE.Vector3();
      var v2 = new THREE.Vector3();
      var v3 = new THREE.Vector3();
      return function() {
        v1.setFromMatrixPosition(this.light.matrixWorld);
        v2.setFromMatrixPosition(this.light.target.matrixWorld);
        v3.subVectors(v2, v1);
        this.lightPlane.lookAt(v3);
        this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.targetLine.geometry.vertices[1].copy(v3);
        this.targetLine.geometry.verticesNeedUpdate = true;
        this.targetLine.material.color.copy(this.lightPlane.material.color);
      };
    }();
    THREE.EdgesHelper = function(object, hex, thresholdAngle) {
      var color = (hex !== undefined) ? hex : 0xffffff;
      thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;
      var thresholdDot = Math.cos(THREE.Math.degToRad(thresholdAngle));
      var edge = [0, 0],
          hash = {};
      var sortFunction = function(a, b) {
        return a - b;
      };
      var keys = ['a', 'b', 'c'];
      var geometry = new THREE.BufferGeometry();
      var geometry2;
      if (object.geometry instanceof THREE.BufferGeometry) {
        geometry2 = new THREE.Geometry();
        geometry2.fromBufferGeometry(object.geometry);
      } else {
        geometry2 = object.geometry.clone();
      }
      geometry2.mergeVertices();
      geometry2.computeFaceNormals();
      var vertices = geometry2.vertices;
      var faces = geometry2.faces;
      var numEdges = 0;
      for (var i = 0,
          l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0; j < 3; j++) {
          edge[0] = face[keys[j]];
          edge[1] = face[keys[(j + 1) % 3]];
          edge.sort(sortFunction);
          var key = edge.toString();
          if (hash[key] === undefined) {
            hash[key] = {
              vert1: edge[0],
              vert2: edge[1],
              face1: i,
              face2: undefined
            };
            numEdges++;
          } else {
            hash[key].face2 = i;
          }
        }
      }
      var coords = new Float32Array(numEdges * 2 * 3);
      var index = 0;
      for (var key in hash) {
        var h = hash[key];
        if (h.face2 === undefined || faces[h.face1].normal.dot(faces[h.face2].normal) <= thresholdDot) {
          var vertex = vertices[h.vert1];
          coords[index++] = vertex.x;
          coords[index++] = vertex.y;
          coords[index++] = vertex.z;
          vertex = vertices[h.vert2];
          coords[index++] = vertex.x;
          coords[index++] = vertex.y;
          coords[index++] = vertex.z;
        }
      }
      geometry.addAttribute('position', new THREE.BufferAttribute(coords, 3));
      THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({color: color}), THREE.LinePieces);
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
    THREE.FaceNormalsHelper = function(object, size, hex, linewidth) {
      this.object = object;
      this.size = (size !== undefined) ? size : 1;
      var color = (hex !== undefined) ? hex : 0xffff00;
      var width = (linewidth !== undefined) ? linewidth : 1;
      var geometry = new THREE.Geometry();
      var faces = this.object.geometry.faces;
      for (var i = 0,
          l = faces.length; i < l; i++) {
        geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());
      }
      THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
      }), THREE.LinePieces);
      this.matrixAutoUpdate = false;
      this.normalMatrix = new THREE.Matrix3();
      this.update();
    };
    THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
    THREE.FaceNormalsHelper.prototype.update = function() {
      var vertices = this.geometry.vertices;
      var object = this.object;
      var objectVertices = object.geometry.vertices;
      var objectFaces = object.geometry.faces;
      var objectWorldMatrix = object.matrixWorld;
      object.updateMatrixWorld(true);
      this.normalMatrix.getNormalMatrix(objectWorldMatrix);
      for (var i = 0,
          i2 = 0,
          l = objectFaces.length; i < l; i++, i2 += 2) {
        var face = objectFaces[i];
        vertices[i2].copy(objectVertices[face.a]).add(objectVertices[face.b]).add(objectVertices[face.c]).divideScalar(3).applyMatrix4(objectWorldMatrix);
        vertices[i2 + 1].copy(face.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(vertices[i2]);
      }
      this.geometry.verticesNeedUpdate = true;
      return this;
    };
    THREE.GridHelper = function(size, step) {
      var geometry = new THREE.Geometry();
      var material = new THREE.LineBasicMaterial({vertexColors: THREE.VertexColors});
      this.color1 = new THREE.Color(0x444444);
      this.color2 = new THREE.Color(0x888888);
      for (var i = -size; i <= size; i += step) {
        geometry.vertices.push(new THREE.Vector3(-size, 0, i), new THREE.Vector3(size, 0, i), new THREE.Vector3(i, 0, -size), new THREE.Vector3(i, 0, size));
        var color = i === 0 ? this.color1 : this.color2;
        geometry.colors.push(color, color, color, color);
      }
      THREE.Line.call(this, geometry, material, THREE.LinePieces);
    };
    THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.GridHelper.prototype.constructor = THREE.GridHelper;
    THREE.GridHelper.prototype.setColors = function(colorCenterLine, colorGrid) {
      this.color1.set(colorCenterLine);
      this.color2.set(colorGrid);
      this.geometry.colorsNeedUpdate = true;
    };
    THREE.HemisphereLightHelper = function(light, sphereSize) {
      THREE.Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      this.colors = [new THREE.Color(), new THREE.Color()];
      var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
      geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
      for (var i = 0,
          il = 8; i < il; i++) {
        geometry.faces[i].color = this.colors[i < 4 ? 0 : 1];
      }
      var material = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: true
      });
      this.lightSphere = new THREE.Mesh(geometry, material);
      this.add(this.lightSphere);
      this.update();
    };
    THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
    THREE.HemisphereLightHelper.prototype.dispose = function() {
      this.lightSphere.geometry.dispose();
      this.lightSphere.material.dispose();
    };
    THREE.HemisphereLightHelper.prototype.update = function() {
      var vector = new THREE.Vector3();
      return function() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
        this.lightSphere.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
        this.lightSphere.geometry.colorsNeedUpdate = true;
      };
    }();
    THREE.PointLightHelper = function(light, sphereSize) {
      this.light = light;
      this.light.updateMatrixWorld();
      var geometry = new THREE.SphereGeometry(sphereSize, 4, 2);
      var material = new THREE.MeshBasicMaterial({
        wireframe: true,
        fog: false
      });
      material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      THREE.Mesh.call(this, geometry, material);
      this.matrix = this.light.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
    THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
    THREE.PointLightHelper.prototype.dispose = function() {
      this.geometry.dispose();
      this.material.dispose();
    };
    THREE.PointLightHelper.prototype.update = function() {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    };
    THREE.SkeletonHelper = function(object) {
      this.bones = this.getBoneList(object);
      var geometry = new THREE.Geometry();
      for (var i = 0; i < this.bones.length; i++) {
        var bone = this.bones[i];
        if (bone.parent instanceof THREE.Bone) {
          geometry.vertices.push(new THREE.Vector3());
          geometry.vertices.push(new THREE.Vector3());
          geometry.colors.push(new THREE.Color(0, 0, 1));
          geometry.colors.push(new THREE.Color(0, 1, 0));
        }
      }
      var material = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        depthTest: false,
        depthWrite: false,
        transparent: true
      });
      THREE.Line.call(this, geometry, material, THREE.LinePieces);
      this.root = object;
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
      this.update();
    };
    THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
    THREE.SkeletonHelper.prototype.getBoneList = function(object) {
      var boneList = [];
      if (object instanceof THREE.Bone) {
        boneList.push(object);
      }
      for (var i = 0; i < object.children.length; i++) {
        boneList.push.apply(boneList, this.getBoneList(object.children[i]));
      }
      return boneList;
    };
    THREE.SkeletonHelper.prototype.update = function() {
      var geometry = this.geometry;
      var matrixWorldInv = new THREE.Matrix4().getInverse(this.root.matrixWorld);
      var boneMatrix = new THREE.Matrix4();
      var j = 0;
      for (var i = 0; i < this.bones.length; i++) {
        var bone = this.bones[i];
        if (bone.parent instanceof THREE.Bone) {
          boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
          geometry.vertices[j].setFromMatrixPosition(boneMatrix);
          boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
          geometry.vertices[j + 1].setFromMatrixPosition(boneMatrix);
          j += 2;
        }
      }
      geometry.verticesNeedUpdate = true;
      geometry.computeBoundingSphere();
    };
    THREE.SpotLightHelper = function(light) {
      THREE.Object3D.call(this);
      this.light = light;
      this.light.updateMatrixWorld();
      this.matrix = light.matrixWorld;
      this.matrixAutoUpdate = false;
      var geometry = new THREE.CylinderGeometry(0, 1, 1, 8, 1, true);
      geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));
      geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
      var material = new THREE.MeshBasicMaterial({
        wireframe: true,
        fog: false
      });
      this.cone = new THREE.Mesh(geometry, material);
      this.add(this.cone);
      this.update();
    };
    THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
    THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
    THREE.SpotLightHelper.prototype.dispose = function() {
      this.cone.geometry.dispose();
      this.cone.material.dispose();
    };
    THREE.SpotLightHelper.prototype.update = function() {
      var vector = new THREE.Vector3();
      var vector2 = new THREE.Vector3();
      return function() {
        var coneLength = this.light.distance ? this.light.distance : 10000;
        var coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        vector.setFromMatrixPosition(this.light.matrixWorld);
        vector2.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(vector2.sub(vector));
        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      };
    }();
    THREE.VertexNormalsHelper = function(object, size, hex, linewidth) {
      this.object = object;
      this.size = (size !== undefined) ? size : 1;
      var color = (hex !== undefined) ? hex : 0xff0000;
      var width = (linewidth !== undefined) ? linewidth : 1;
      var geometry = new THREE.Geometry();
      var faces = object.geometry.faces;
      for (var i = 0,
          l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0,
            jl = face.vertexNormals.length; j < jl; j++) {
          geometry.vertices.push(new THREE.Vector3(), new THREE.Vector3());
        }
      }
      THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
      }), THREE.LinePieces);
      this.matrixAutoUpdate = false;
      this.normalMatrix = new THREE.Matrix3();
      this.update();
    };
    THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
    THREE.VertexNormalsHelper.prototype.update = (function(object) {
      var v1 = new THREE.Vector3();
      return function(object) {
        var keys = ['a', 'b', 'c', 'd'];
        this.object.updateMatrixWorld(true);
        this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        var vertices = this.geometry.vertices;
        var verts = this.object.geometry.vertices;
        var faces = this.object.geometry.faces;
        var worldMatrix = this.object.matrixWorld;
        var idx = 0;
        for (var i = 0,
            l = faces.length; i < l; i++) {
          var face = faces[i];
          for (var j = 0,
              jl = face.vertexNormals.length; j < jl; j++) {
            var vertexId = face[keys[j]];
            var vertex = verts[vertexId];
            var normal = face.vertexNormals[j];
            vertices[idx].copy(vertex).applyMatrix4(worldMatrix);
            v1.copy(normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
            v1.add(vertices[idx]);
            idx = idx + 1;
            vertices[idx].copy(v1);
            idx = idx + 1;
          }
        }
        this.geometry.verticesNeedUpdate = true;
        return this;
      };
    }());
    THREE.VertexTangentsHelper = function(object, size, hex, linewidth) {
      this.object = object;
      this.size = (size !== undefined) ? size : 1;
      var color = (hex !== undefined) ? hex : 0x0000ff;
      var width = (linewidth !== undefined) ? linewidth : 1;
      var geometry = new THREE.Geometry();
      var faces = object.geometry.faces;
      for (var i = 0,
          l = faces.length; i < l; i++) {
        var face = faces[i];
        for (var j = 0,
            jl = face.vertexTangents.length; j < jl; j++) {
          geometry.vertices.push(new THREE.Vector3());
          geometry.vertices.push(new THREE.Vector3());
        }
      }
      THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({
        color: color,
        linewidth: width
      }), THREE.LinePieces);
      this.matrixAutoUpdate = false;
      this.update();
    };
    THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;
    THREE.VertexTangentsHelper.prototype.update = (function(object) {
      var v1 = new THREE.Vector3();
      return function(object) {
        var keys = ['a', 'b', 'c', 'd'];
        this.object.updateMatrixWorld(true);
        var vertices = this.geometry.vertices;
        var verts = this.object.geometry.vertices;
        var faces = this.object.geometry.faces;
        var worldMatrix = this.object.matrixWorld;
        var idx = 0;
        for (var i = 0,
            l = faces.length; i < l; i++) {
          var face = faces[i];
          for (var j = 0,
              jl = face.vertexTangents.length; j < jl; j++) {
            var vertexId = face[keys[j]];
            var vertex = verts[vertexId];
            var tangent = face.vertexTangents[j];
            vertices[idx].copy(vertex).applyMatrix4(worldMatrix);
            v1.copy(tangent).transformDirection(worldMatrix).multiplyScalar(this.size);
            v1.add(vertices[idx]);
            idx = idx + 1;
            vertices[idx].copy(v1);
            idx = idx + 1;
          }
        }
        this.geometry.verticesNeedUpdate = true;
        return this;
      };
    }());
    THREE.WireframeHelper = function(object, hex) {
      var color = (hex !== undefined) ? hex : 0xffffff;
      var edge = [0, 0],
          hash = {};
      var sortFunction = function(a, b) {
        return a - b;
      };
      var keys = ['a', 'b', 'c'];
      var geometry = new THREE.BufferGeometry();
      if (object.geometry instanceof THREE.Geometry) {
        var vertices = object.geometry.vertices;
        var faces = object.geometry.faces;
        var numEdges = 0;
        var edges = new Uint32Array(6 * faces.length);
        for (var i = 0,
            l = faces.length; i < l; i++) {
          var face = faces[i];
          for (var j = 0; j < 3; j++) {
            edge[0] = face[keys[j]];
            edge[1] = face[keys[(j + 1) % 3]];
            edge.sort(sortFunction);
            var key = edge.toString();
            if (hash[key] === undefined) {
              edges[2 * numEdges] = edge[0];
              edges[2 * numEdges + 1] = edge[1];
              hash[key] = true;
              numEdges++;
            }
          }
        }
        var coords = new Float32Array(numEdges * 2 * 3);
        for (var i = 0,
            l = numEdges; i < l; i++) {
          for (var j = 0; j < 2; j++) {
            var vertex = vertices[edges[2 * i + j]];
            var index = 6 * i + 3 * j;
            coords[index + 0] = vertex.x;
            coords[index + 1] = vertex.y;
            coords[index + 2] = vertex.z;
          }
        }
        geometry.addAttribute('position', new THREE.BufferAttribute(coords, 3));
      } else if (object.geometry instanceof THREE.BufferGeometry) {
        if (object.geometry.attributes.index !== undefined) {
          var vertices = object.geometry.attributes.position.array;
          var indices = object.geometry.attributes.index.array;
          var drawcalls = object.geometry.drawcalls;
          var numEdges = 0;
          if (drawcalls.length === 0) {
            drawcalls = [{
              count: indices.length,
              index: 0,
              start: 0
            }];
          }
          var edges = new Uint32Array(2 * indices.length);
          for (var o = 0,
              ol = drawcalls.length; o < ol; ++o) {
            var start = drawcalls[o].start;
            var count = drawcalls[o].count;
            var index = drawcalls[o].index;
            for (var i = start,
                il = start + count; i < il; i += 3) {
              for (var j = 0; j < 3; j++) {
                edge[0] = index + indices[i + j];
                edge[1] = index + indices[i + (j + 1) % 3];
                edge.sort(sortFunction);
                var key = edge.toString();
                if (hash[key] === undefined) {
                  edges[2 * numEdges] = edge[0];
                  edges[2 * numEdges + 1] = edge[1];
                  hash[key] = true;
                  numEdges++;
                }
              }
            }
          }
          var coords = new Float32Array(numEdges * 2 * 3);
          for (var i = 0,
              l = numEdges; i < l; i++) {
            for (var j = 0; j < 2; j++) {
              var index = 6 * i + 3 * j;
              var index2 = 3 * edges[2 * i + j];
              coords[index + 0] = vertices[index2];
              coords[index + 1] = vertices[index2 + 1];
              coords[index + 2] = vertices[index2 + 2];
            }
          }
          geometry.addAttribute('position', new THREE.BufferAttribute(coords, 3));
        } else {
          var vertices = object.geometry.attributes.position.array;
          var numEdges = vertices.length / 3;
          var numTris = numEdges / 3;
          var coords = new Float32Array(numEdges * 2 * 3);
          for (var i = 0,
              l = numTris; i < l; i++) {
            for (var j = 0; j < 3; j++) {
              var index = 18 * i + 6 * j;
              var index1 = 9 * i + 3 * j;
              coords[index + 0] = vertices[index1];
              coords[index + 1] = vertices[index1 + 1];
              coords[index + 2] = vertices[index1 + 2];
              var index2 = 9 * i + 3 * ((j + 1) % 3);
              coords[index + 3] = vertices[index2];
              coords[index + 4] = vertices[index2 + 1];
              coords[index + 5] = vertices[index2 + 2];
            }
          }
          geometry.addAttribute('position', new THREE.BufferAttribute(coords, 3));
        }
      }
      THREE.Line.call(this, geometry, new THREE.LineBasicMaterial({color: color}), THREE.LinePieces);
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    };
    THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
    THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
    THREE.ImmediateRenderObject = function() {
      THREE.Object3D.call(this);
      this.render = function(renderCallback) {};
    };
    THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
    THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
    THREE.MorphBlendMesh = function(geometry, material) {
      THREE.Mesh.call(this, geometry, material);
      this.animationsMap = {};
      this.animationsList = [];
      var numFrames = this.geometry.morphTargets.length;
      var name = "__default";
      var startFrame = 0;
      var endFrame = numFrames - 1;
      var fps = numFrames / 1;
      this.createAnimation(name, startFrame, endFrame, fps);
      this.setAnimationWeight(name, 1);
    };
    THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
    THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
    THREE.MorphBlendMesh.prototype.createAnimation = function(name, start, end, fps) {
      var animation = {
        startFrame: start,
        endFrame: end,
        length: end - start + 1,
        fps: fps,
        duration: (end - start) / fps,
        lastFrame: 0,
        currentFrame: 0,
        active: false,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: false,
        mirroredLoop: false
      };
      this.animationsMap[name] = animation;
      this.animationsList.push(animation);
    };
    THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(fps) {
      var pattern = /([a-z]+)_?(\d+)/;
      var firstAnimation,
          frameRanges = {};
      var geometry = this.geometry;
      for (var i = 0,
          il = geometry.morphTargets.length; i < il; i++) {
        var morph = geometry.morphTargets[i];
        var chunks = morph.name.match(pattern);
        if (chunks && chunks.length > 1) {
          var name = chunks[1];
          if (!frameRanges[name])
            frameRanges[name] = {
              start: Infinity,
              end: -Infinity
            };
          var range = frameRanges[name];
          if (i < range.start)
            range.start = i;
          if (i > range.end)
            range.end = i;
          if (!firstAnimation)
            firstAnimation = name;
        }
      }
      for (var name in frameRanges) {
        var range = frameRanges[name];
        this.createAnimation(name, range.start, range.end, fps);
      }
      this.firstAnimation = firstAnimation;
    };
    THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.direction = 1;
        animation.directionBackwards = false;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.direction = -1;
        animation.directionBackwards = true;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationFPS = function(name, fps) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.fps = fps;
        animation.duration = (animation.end - animation.start) / animation.fps;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationDuration = function(name, duration) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.duration = duration;
        animation.fps = (animation.end - animation.start) / animation.duration;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationWeight = function(name, weight) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.weight = weight;
      }
    };
    THREE.MorphBlendMesh.prototype.setAnimationTime = function(name, time) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.time = time;
      }
    };
    THREE.MorphBlendMesh.prototype.getAnimationTime = function(name) {
      var time = 0;
      var animation = this.animationsMap[name];
      if (animation) {
        time = animation.time;
      }
      return time;
    };
    THREE.MorphBlendMesh.prototype.getAnimationDuration = function(name) {
      var duration = -1;
      var animation = this.animationsMap[name];
      if (animation) {
        duration = animation.duration;
      }
      return duration;
    };
    THREE.MorphBlendMesh.prototype.playAnimation = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.time = 0;
        animation.active = true;
      } else {
        THREE.warn("THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()");
      }
    };
    THREE.MorphBlendMesh.prototype.stopAnimation = function(name) {
      var animation = this.animationsMap[name];
      if (animation) {
        animation.active = false;
      }
    };
    THREE.MorphBlendMesh.prototype.update = function(delta) {
      for (var i = 0,
          il = this.animationsList.length; i < il; i++) {
        var animation = this.animationsList[i];
        if (!animation.active)
          continue;
        var frameTime = animation.duration / animation.length;
        animation.time += animation.direction * delta;
        if (animation.mirroredLoop) {
          if (animation.time > animation.duration || animation.time < 0) {
            animation.direction *= -1;
            if (animation.time > animation.duration) {
              animation.time = animation.duration;
              animation.directionBackwards = true;
            }
            if (animation.time < 0) {
              animation.time = 0;
              animation.directionBackwards = false;
            }
          }
        } else {
          animation.time = animation.time % animation.duration;
          if (animation.time < 0)
            animation.time += animation.duration;
        }
        var keyframe = animation.startFrame + THREE.Math.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);
        var weight = animation.weight;
        if (keyframe !== animation.currentFrame) {
          this.morphTargetInfluences[animation.lastFrame] = 0;
          this.morphTargetInfluences[animation.currentFrame] = 1 * weight;
          this.morphTargetInfluences[keyframe] = 0;
          animation.lastFrame = animation.currentFrame;
          animation.currentFrame = keyframe;
        }
        var mix = (animation.time % frameTime) / frameTime;
        if (animation.directionBackwards)
          mix = 1 - mix;
        this.morphTargetInfluences[animation.currentFrame] = mix * weight;
        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;
      }
    };
    this["THREE"] = THREE;
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("1", ["d", "3", "e", "5"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('d');
  var Troxel = {
    blueprints: null,
    webgl: function() {
      try {
        var canvas = document.createElement('canvas');
        return !!(window.WebGLRenderingContext && (canvas.getContext('webgl' || canvas.getContext('experimental-webgl'))));
      } catch (e) {
        return false;
      }
    },
    renderBlueprint: function(blueprintId, domElement, options, cb) {
      blueprintId = blueprintId.toLowerCase();
      if (!Troxel.webgl()) {
        console.warn("WebGL is not supported by your browser");
        if (typeof cb === 'function') {
          return cb(new Error("WebGl is not supported"));
        }
      }
      $.getJSON('https://troxel.js.org/trove-blueprints/index.json', function(meta) {
        $.getJSON('https://troxel.js.org/trove-blueprints/' + meta.latest + '.json', function(data) {
          Troxel.blueprints = data;
          var model = data[blueprintId];
          var result = {error: new Error("blueprintId " + blueprintId + " not found")};
          if (model != null) {
            result = Troxel.renderBase64(model, domElement, options, blueprintId);
          } else {
            console.warn("blueprintId " + blueprintId + " not found");
          }
          if (typeof cb === 'function') {
            cb(result.error, result.options);
          }
        });
      });
    },
    renderBase64: function(base64, domElement, options, blueprintId) {
      var Base64IO = $__require('3');
      var Renderer = $__require('e');
      if (options == null) {
        options = {};
      }
      if (!Troxel.webgl()) {
        console.warn("WebGL is not supported by your browser");
        return {error: new Error("WebGL is not supported by your browser")};
      }
      domElement = $(domElement).empty().css('position', 'relative');
      var io = null;
      try {
        io = new Base64IO(base64);
      } catch (e) {
        console.warn("passed String is not a valid base64 encoded voxel model");
        return {error: new Error("passed String is not a valid base64 encoded voxel model")};
      }
      var renderer = new Renderer(io, true, domElement, options.renderMode || 0, options.renderWireframes || 0, options.rendererAntialias || true, options.rendererSSAO || false);
      var THREE = $__require('5');
      if (options.rendererClearColor != null) {
        renderer.renderer.setClearColor(options.rendererClearColor);
      }
      if (options.ambientLightColor != null) {
        renderer.ambientLight.color = new THREE.Color(options.ambientLightColor);
      }
      if (options.directionalLightColor != null) {
        renderer.directionalLight.color = new THREE.Color(options.directionalLightColor);
      }
      if (options.directionalLightIntensity != null) {
        renderer.directionalLight.intensity = options.directionalLightIntensity;
      }
      if ((options.directionalLightVector != null) && (options.directionalLightVector.x != null) && (options.directionalLightVector.y != null) && (options.directionalLightVector.z != null)) {
        renderer.directionalLight.position.set(options.directionalLightVector.x, options.directionalLightVector.y, options.directionalLightVector.z).normalize();
      }
      if (options.pointLightColor != null) {
        renderer.pointLight.color = new THREE.Color(options.pointLightColor);
      }
      if (options.pointLightIntensity != null) {
        renderer.pointLight.intensity = options.pointLightIntensity;
      }
      if ((options.autoRotate == null) || options.autoRotate) {
        renderer.controls.autoRotate = true;
        renderer.controls.autoRotateSpeed = options.autoRotateSpeed || -4.0;
      }
      if ((options.controls != null) && !options.controls) {
        renderer.controls.mode = false;
      }
      if ((options.noZoom != null) && options.noZoom) {
        renderer.controls.noZoom = true;
      }
      if ((options.noPan != null) && options.noPan) {
        renderer.controls.noPan = true;
      }
      if ((options.noRotate != null) && options.noRotate) {
        renderer.controls.noRotate = true;
      }
      if ((options.showInfoLabel == null) || options.showInfoLabel) {
        var link = blueprintId != null ? '#b=' + blueprintId : '#m=' + base64;
        var info = $("<div><a href='http://chrmoritz.github.io/Troxel/" + link + "' target='_blank' class='troxelLink'>Open this model in Troxel</a></div>");
        domElement.append(info.css({
          position: 'absolute',
          bottom: '0px',
          width: '100%',
          textAlign: 'center'
        }));
      }
      var resultOptions = {};
      var _resultOptions = {
        rendererClearColor: 0x888888,
        ambientLightColor: 0x606060,
        directionalLightColor: 0xffffff,
        directionalLightIntensity: 0.3,
        directionalLightVector: {
          x: -0.5,
          y: -0.5,
          z: 1
        },
        pointLightColor: 0xffffff,
        pointLightIntensity: 0.7,
        base64: base64,
        controls: true,
        autoRotate: true,
        autoRotateSpeed: -4.0,
        noZoom: false,
        noPan: false,
        noRotate: false,
        renderMode: 0,
        renderWireframes: 0
      };
      _resultOptions.blueprint = blueprintId || null;
      Object.defineProperties(resultOptions, {
        "base64": {
          set: function(s) {
            _resultOptions.base64 = s;
            io = new Base64IO(s);
            renderer.reload(io.voxels, io.x, io.y, io.z, true, false);
          },
          get: function() {
            return _resultOptions.base64;
          }
        },
        "blueprint": {
          set: function(s) {
            _resultOptions.blueprint = s.toLowerCase();
            resultOptions.base64 = Troxel.blueprints[s.toLowerCase()];
          },
          get: function() {
            return _resultOptions.blueprint;
          }
        },
        "renderMode": {
          set: function(s) {
            _resultOptions.renderMode = s;
            renderer.renderMode = s;
            renderer.reload(io.voxels, io.x, io.y, io.z, false, false);
          },
          get: function() {
            return _resultOptions.renderMode;
          }
        },
        "renderWireframes": {
          set: function(s) {
            _resultOptions.renderWireframes = s;
            renderer.renderWireframes = s;
            renderer.reload(io.voxels, io.x, io.y, io.z, false, false);
          },
          get: function() {
            return _resultOptions.renderWireframes;
          }
        },
        "rendererClearColor": {
          set: function(s) {
            _resultOptions.rendererClearColor = s;
            renderer.renderer.setClearColor(s);
            renderer.render();
          },
          get: function() {
            return _resultOptions.rendererClearColor;
          }
        },
        "ambientLightColor": {
          set: function(s) {
            _resultOptions.ambientLightColor = s;
            renderer.ambientLight.color = new THREE.Color(s);
            renderer.render();
          },
          get: function() {
            return _resultOptions.ambientLightColor;
          }
        },
        "directionalLightColor": {
          set: function(s) {
            _resultOptions.directionalLightColor = s;
            renderer.directionalLight.color = new THREE.Color(s);
            renderer.render();
          },
          get: function() {
            return _resultOptions.directionalLightColor;
          }
        },
        "directionalLightIntensity": {
          set: function(s) {
            _resultOptions.directionalLightIntensity = s;
            renderer.directionalLight.intensity = s;
            renderer.render();
          },
          get: function() {
            return _resultOptions.directionalLightIntensity;
          }
        },
        "directionalLightVector": {
          set: function(s) {
            if ((s.x != null) && (s.y != null) && (s.z != null)) {
              _resultOptions.directionalLightVector = s;
              renderer.directionalLight.position.set(s.x, s.y, s.z).normalize();
              renderer.render();
            }
          },
          get: function() {
            return _resultOptions.directionalLightVector;
          }
        },
        "pointLightColor": {
          set: function(s) {
            _resultOptions.pointLightColor = s;
            renderer.pointLight.color = new THREE.Color(s);
            renderer.render();
          },
          get: function() {
            return _resultOptions.pointLightColor;
          }
        },
        "pointLightIntensity": {
          set: function(s) {
            _resultOptions.pointLightIntensity = s;
            renderer.pointLight.intensity = s;
            renderer.render();
          },
          get: function() {
            return _resultOptions.pointLightIntensity;
          }
        },
        "autoRotate": {
          set: function(s) {
            _resultOptions.autoRotate = s;
            renderer.controls.autoRotate = s;
            renderer.render();
          },
          get: function() {
            return _resultOptions.autoRotate;
          }
        },
        "autoRotateSpeed": {
          set: function(s) {
            if (renderer.controls.autoRotate) {
              _resultOptions.autoRotateSpeed = s;
              renderer.controls.autoRotateSpeed = s;
              renderer.render();
            }
          },
          get: function() {
            return _resultOptions.autoRotateSpeed;
          }
        },
        "controls": {
          set: function(s) {
            _resultOptions.controls = s;
            renderer.controls.mode = s;
            renderer.render();
          },
          get: function() {
            return _resultOptions.controls;
          }
        },
        "noZoom": {
          set: function(s) {
            _resultOptions.noZoom = s;
            renderer.controls.noZoom = s;
            renderer.render();
          },
          get: function() {
            return _resultOptions.noZoom;
          }
        },
        "noPan": {
          set: function(s) {
            _resultOptions.noPan = s;
            renderer.controls.noPan = s;
            renderer.render();
          },
          get: function() {
            return _resultOptions.noPan;
          }
        },
        "noRotate": {
          set: function(s) {
            _resultOptions.noRotate = s;
            renderer.controls.noRotate = s;
            renderer.render();
          },
          get: function() {
            return _resultOptions.noRotate;
          }
        }
      });
      return {
        error: null,
        options: resultOptions
      };
    }
  };
  module.exports = Troxel;
  $(function() {
    $('div[data-troxel-blueprint]').each(function() {
      Troxel.renderBlueprint($(this).data('troxel-blueprint'), this, $(this).data('troxel-options'));
    });
    return $('div[data-troxel-base64]').each(function() {
      Troxel.renderBase64($(this).data('troxel-base64'), this, $(this).data('troxel-options'));
    });
  });
  return module.exports;
});

})
(function(factory) {
  if (typeof define == 'function' && define.amd)
    define([], factory);
  else if (typeof module == 'object' && module.exports && typeof require == 'function')
    module.exports = factory();
  else
    Troxel = factory();
});